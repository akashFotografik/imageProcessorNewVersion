
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserCompany
 * 
 */
export type UserCompany = $Result.DefaultSelection<Prisma.$UserCompanyPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Leave
 * 
 */
export type Leave = $Result.DefaultSelection<Prisma.$LeavePayload>
/**
 * Model WorkingDay
 * 
 */
export type WorkingDay = $Result.DefaultSelection<Prisma.$WorkingDayPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model ChatMember
 * 
 */
export type ChatMember = $Result.DefaultSelection<Prisma.$ChatMemberPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model InventoryMovement
 * 
 */
export type InventoryMovement = $Result.DefaultSelection<Prisma.$InventoryMovementPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model SupplierItem
 * 
 */
export type SupplierItem = $Result.DefaultSelection<Prisma.$SupplierItemPayload>
/**
 * Model GatePass
 * 
 */
export type GatePass = $Result.DefaultSelection<Prisma.$GatePassPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model PerformanceReview
 * 
 */
export type PerformanceReview = $Result.DefaultSelection<Prisma.$PerformanceReviewPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model CreditsRecharge
 * 
 */
export type CreditsRecharge = $Result.DefaultSelection<Prisma.$CreditsRechargePayload>
/**
 * Model TransactionHistory
 * 
 */
export type TransactionHistory = $Result.DefaultSelection<Prisma.$TransactionHistoryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  MANAGER: 'MANAGER',
  EMPLOYEE: 'EMPLOYEE',
  INTERN: 'INTERN',
  ADMIN: 'ADMIN',
  DIRECTOR: 'DIRECTOR'
};

export type Role = (typeof Role)[keyof typeof Role]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  HALF_DAY: 'HALF_DAY',
  WORK_FROM_HOME: 'WORK_FROM_HOME'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const LeaveStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const LeaveType: {
  SICK_LEAVE: 'SICK_LEAVE',
  CASUAL_LEAVE: 'CASUAL_LEAVE',
  ANNUAL_LEAVE: 'ANNUAL_LEAVE',
  MATERNITY_LEAVE: 'MATERNITY_LEAVE',
  PATERNITY_LEAVE: 'PATERNITY_LEAVE',
  EMERGENCY_LEAVE: 'EMERGENCY_LEAVE',
  UNPAID_LEAVE: 'UNPAID_LEAVE'
};

export type LeaveType = (typeof LeaveType)[keyof typeof LeaveType]


export const TaskStatus: {
  TODO: 'TODO',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  ON_HOLD: 'ON_HOLD'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const TaskPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type TaskPriority = (typeof TaskPriority)[keyof typeof TaskPriority]


export const GatePassType: {
  EMPLOYEE: 'EMPLOYEE',
  INTERVIEW: 'INTERVIEW',
  VISITOR: 'VISITOR',
  OFFICIAL: 'OFFICIAL'
};

export type GatePassType = (typeof GatePassType)[keyof typeof GatePassType]


export const GatePassStatus: {
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type GatePassStatus = (typeof GatePassStatus)[keyof typeof GatePassStatus]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  FILE: 'FILE',
  VOICE: 'VOICE'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const ChatType: {
  PERSONAL: 'PERSONAL',
  GROUP: 'GROUP',
  GENERAL: 'GENERAL'
};

export type ChatType = (typeof ChatType)[keyof typeof ChatType]


export const InventoryMovementType: {
  IN: 'IN',
  OUT: 'OUT',
  ADJUSTMENT: 'ADJUSTMENT',
  RETURN: 'RETURN'
};

export type InventoryMovementType = (typeof InventoryMovementType)[keyof typeof InventoryMovementType]


export const DocumentType: {
  CONTRACT: 'CONTRACT',
  INVOICE: 'INVOICE',
  RECEIPT: 'RECEIPT',
  POLICY: 'POLICY',
  CERTIFICATE: 'CERTIFICATE',
  REPORT: 'REPORT',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const AuditLogAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  VIEW: 'VIEW',
  DOWNLOAD: 'DOWNLOAD',
  UPLOAD: 'UPLOAD'
};

export type AuditLogAction = (typeof AuditLogAction)[keyof typeof AuditLogAction]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type LeaveType = $Enums.LeaveType

export const LeaveType: typeof $Enums.LeaveType

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type TaskPriority = $Enums.TaskPriority

export const TaskPriority: typeof $Enums.TaskPriority

export type GatePassType = $Enums.GatePassType

export const GatePassType: typeof $Enums.GatePassType

export type GatePassStatus = $Enums.GatePassStatus

export const GatePassStatus: typeof $Enums.GatePassStatus

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type ChatType = $Enums.ChatType

export const ChatType: typeof $Enums.ChatType

export type InventoryMovementType = $Enums.InventoryMovementType

export const InventoryMovementType: typeof $Enums.InventoryMovementType

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type AuditLogAction = $Enums.AuditLogAction

export const AuditLogAction: typeof $Enums.AuditLogAction

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCompany`: Exposes CRUD operations for the **UserCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCompanies
    * const userCompanies = await prisma.userCompany.findMany()
    * ```
    */
  get userCompany(): Prisma.UserCompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave`: Exposes CRUD operations for the **Leave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaves
    * const leaves = await prisma.leave.findMany()
    * ```
    */
  get leave(): Prisma.LeaveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workingDay`: Exposes CRUD operations for the **WorkingDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkingDays
    * const workingDays = await prisma.workingDay.findMany()
    * ```
    */
  get workingDay(): Prisma.WorkingDayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMember`: Exposes CRUD operations for the **ChatMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMembers
    * const chatMembers = await prisma.chatMember.findMany()
    * ```
    */
  get chatMember(): Prisma.ChatMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryMovement`: Exposes CRUD operations for the **InventoryMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryMovements
    * const inventoryMovements = await prisma.inventoryMovement.findMany()
    * ```
    */
  get inventoryMovement(): Prisma.InventoryMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierItem`: Exposes CRUD operations for the **SupplierItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierItems
    * const supplierItems = await prisma.supplierItem.findMany()
    * ```
    */
  get supplierItem(): Prisma.SupplierItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gatePass`: Exposes CRUD operations for the **GatePass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GatePasses
    * const gatePasses = await prisma.gatePass.findMany()
    * ```
    */
  get gatePass(): Prisma.GatePassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceReview`: Exposes CRUD operations for the **PerformanceReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceReviews
    * const performanceReviews = await prisma.performanceReview.findMany()
    * ```
    */
  get performanceReview(): Prisma.PerformanceReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditsRecharge`: Exposes CRUD operations for the **CreditsRecharge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditsRecharges
    * const creditsRecharges = await prisma.creditsRecharge.findMany()
    * ```
    */
  get creditsRecharge(): Prisma.CreditsRechargeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionHistory`: Exposes CRUD operations for the **TransactionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionHistories
    * const transactionHistories = await prisma.transactionHistory.findMany()
    * ```
    */
  get transactionHistory(): Prisma.TransactionHistoryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserCompany: 'UserCompany',
    Company: 'Company',
    Service: 'Service',
    Department: 'Department',
    Attendance: 'Attendance',
    Leave: 'Leave',
    WorkingDay: 'WorkingDay',
    Task: 'Task',
    Chat: 'Chat',
    ChatMember: 'ChatMember',
    Message: 'Message',
    InventoryItem: 'InventoryItem',
    InventoryMovement: 'InventoryMovement',
    Supplier: 'Supplier',
    SupplierItem: 'SupplierItem',
    GatePass: 'GatePass',
    Document: 'Document',
    PerformanceReview: 'PerformanceReview',
    AuditLog: 'AuditLog',
    CreditsRecharge: 'CreditsRecharge',
    TransactionHistory: 'TransactionHistory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userCompany" | "company" | "service" | "department" | "attendance" | "leave" | "workingDay" | "task" | "chat" | "chatMember" | "message" | "inventoryItem" | "inventoryMovement" | "supplier" | "supplierItem" | "gatePass" | "document" | "performanceReview" | "auditLog" | "creditsRecharge" | "transactionHistory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserCompany: {
        payload: Prisma.$UserCompanyPayload<ExtArgs>
        fields: Prisma.UserCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          findFirst: {
            args: Prisma.UserCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          findMany: {
            args: Prisma.UserCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>[]
          }
          create: {
            args: Prisma.UserCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          createMany: {
            args: Prisma.UserCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>[]
          }
          delete: {
            args: Prisma.UserCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          update: {
            args: Prisma.UserCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          deleteMany: {
            args: Prisma.UserCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>[]
          }
          upsert: {
            args: Prisma.UserCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          aggregate: {
            args: Prisma.UserCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCompany>
          }
          groupBy: {
            args: Prisma.UserCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<UserCompanyCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Leave: {
        payload: Prisma.$LeavePayload<ExtArgs>
        fields: Prisma.LeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findFirst: {
            args: Prisma.LeaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findMany: {
            args: Prisma.LeaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          create: {
            args: Prisma.LeaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          createMany: {
            args: Prisma.LeaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          delete: {
            args: Prisma.LeaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          update: {
            args: Prisma.LeaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          deleteMany: {
            args: Prisma.LeaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          upsert: {
            args: Prisma.LeaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          aggregate: {
            args: Prisma.LeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave>
          }
          groupBy: {
            args: Prisma.LeaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveCountAggregateOutputType> | number
          }
        }
      }
      WorkingDay: {
        payload: Prisma.$WorkingDayPayload<ExtArgs>
        fields: Prisma.WorkingDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkingDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkingDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDayPayload>
          }
          findFirst: {
            args: Prisma.WorkingDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkingDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDayPayload>
          }
          findMany: {
            args: Prisma.WorkingDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDayPayload>[]
          }
          create: {
            args: Prisma.WorkingDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDayPayload>
          }
          createMany: {
            args: Prisma.WorkingDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkingDayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDayPayload>[]
          }
          delete: {
            args: Prisma.WorkingDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDayPayload>
          }
          update: {
            args: Prisma.WorkingDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDayPayload>
          }
          deleteMany: {
            args: Prisma.WorkingDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkingDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkingDayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDayPayload>[]
          }
          upsert: {
            args: Prisma.WorkingDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDayPayload>
          }
          aggregate: {
            args: Prisma.WorkingDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkingDay>
          }
          groupBy: {
            args: Prisma.WorkingDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkingDayGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkingDayCountArgs<ExtArgs>
            result: $Utils.Optional<WorkingDayCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      ChatMember: {
        payload: Prisma.$ChatMemberPayload<ExtArgs>
        fields: Prisma.ChatMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          findFirst: {
            args: Prisma.ChatMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          findMany: {
            args: Prisma.ChatMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>[]
          }
          create: {
            args: Prisma.ChatMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          createMany: {
            args: Prisma.ChatMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>[]
          }
          delete: {
            args: Prisma.ChatMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          update: {
            args: Prisma.ChatMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          deleteMany: {
            args: Prisma.ChatMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>[]
          }
          upsert: {
            args: Prisma.ChatMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          aggregate: {
            args: Prisma.ChatMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMember>
          }
          groupBy: {
            args: Prisma.ChatMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMemberCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryMovement: {
        payload: Prisma.$InventoryMovementPayload<ExtArgs>
        fields: Prisma.InventoryMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findFirst: {
            args: Prisma.InventoryMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findMany: {
            args: Prisma.InventoryMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          create: {
            args: Prisma.InventoryMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          createMany: {
            args: Prisma.InventoryMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          delete: {
            args: Prisma.InventoryMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          update: {
            args: Prisma.InventoryMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          deleteMany: {
            args: Prisma.InventoryMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          upsert: {
            args: Prisma.InventoryMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          aggregate: {
            args: Prisma.InventoryMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryMovement>
          }
          groupBy: {
            args: Prisma.InventoryMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryMovementCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      SupplierItem: {
        payload: Prisma.$SupplierItemPayload<ExtArgs>
        fields: Prisma.SupplierItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPayload>
          }
          findFirst: {
            args: Prisma.SupplierItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPayload>
          }
          findMany: {
            args: Prisma.SupplierItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPayload>[]
          }
          create: {
            args: Prisma.SupplierItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPayload>
          }
          createMany: {
            args: Prisma.SupplierItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPayload>[]
          }
          delete: {
            args: Prisma.SupplierItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPayload>
          }
          update: {
            args: Prisma.SupplierItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPayload>
          }
          deleteMany: {
            args: Prisma.SupplierItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPayload>[]
          }
          upsert: {
            args: Prisma.SupplierItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPayload>
          }
          aggregate: {
            args: Prisma.SupplierItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierItem>
          }
          groupBy: {
            args: Prisma.SupplierItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierItemCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierItemCountAggregateOutputType> | number
          }
        }
      }
      GatePass: {
        payload: Prisma.$GatePassPayload<ExtArgs>
        fields: Prisma.GatePassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GatePassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GatePassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePassPayload>
          }
          findFirst: {
            args: Prisma.GatePassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GatePassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePassPayload>
          }
          findMany: {
            args: Prisma.GatePassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePassPayload>[]
          }
          create: {
            args: Prisma.GatePassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePassPayload>
          }
          createMany: {
            args: Prisma.GatePassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GatePassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePassPayload>[]
          }
          delete: {
            args: Prisma.GatePassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePassPayload>
          }
          update: {
            args: Prisma.GatePassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePassPayload>
          }
          deleteMany: {
            args: Prisma.GatePassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GatePassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GatePassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePassPayload>[]
          }
          upsert: {
            args: Prisma.GatePassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePassPayload>
          }
          aggregate: {
            args: Prisma.GatePassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGatePass>
          }
          groupBy: {
            args: Prisma.GatePassGroupByArgs<ExtArgs>
            result: $Utils.Optional<GatePassGroupByOutputType>[]
          }
          count: {
            args: Prisma.GatePassCountArgs<ExtArgs>
            result: $Utils.Optional<GatePassCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      PerformanceReview: {
        payload: Prisma.$PerformanceReviewPayload<ExtArgs>
        fields: Prisma.PerformanceReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          findFirst: {
            args: Prisma.PerformanceReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          findMany: {
            args: Prisma.PerformanceReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>[]
          }
          create: {
            args: Prisma.PerformanceReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          createMany: {
            args: Prisma.PerformanceReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>[]
          }
          delete: {
            args: Prisma.PerformanceReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          update: {
            args: Prisma.PerformanceReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          aggregate: {
            args: Prisma.PerformanceReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceReview>
          }
          groupBy: {
            args: Prisma.PerformanceReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceReviewCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceReviewCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      CreditsRecharge: {
        payload: Prisma.$CreditsRechargePayload<ExtArgs>
        fields: Prisma.CreditsRechargeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditsRechargeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsRechargePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditsRechargeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsRechargePayload>
          }
          findFirst: {
            args: Prisma.CreditsRechargeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsRechargePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditsRechargeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsRechargePayload>
          }
          findMany: {
            args: Prisma.CreditsRechargeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsRechargePayload>[]
          }
          create: {
            args: Prisma.CreditsRechargeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsRechargePayload>
          }
          createMany: {
            args: Prisma.CreditsRechargeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditsRechargeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsRechargePayload>[]
          }
          delete: {
            args: Prisma.CreditsRechargeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsRechargePayload>
          }
          update: {
            args: Prisma.CreditsRechargeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsRechargePayload>
          }
          deleteMany: {
            args: Prisma.CreditsRechargeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditsRechargeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditsRechargeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsRechargePayload>[]
          }
          upsert: {
            args: Prisma.CreditsRechargeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditsRechargePayload>
          }
          aggregate: {
            args: Prisma.CreditsRechargeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditsRecharge>
          }
          groupBy: {
            args: Prisma.CreditsRechargeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditsRechargeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditsRechargeCountArgs<ExtArgs>
            result: $Utils.Optional<CreditsRechargeCountAggregateOutputType> | number
          }
        }
      }
      TransactionHistory: {
        payload: Prisma.$TransactionHistoryPayload<ExtArgs>
        fields: Prisma.TransactionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>
          }
          findFirst: {
            args: Prisma.TransactionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>
          }
          findMany: {
            args: Prisma.TransactionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>[]
          }
          create: {
            args: Prisma.TransactionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>
          }
          createMany: {
            args: Prisma.TransactionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>[]
          }
          delete: {
            args: Prisma.TransactionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>
          }
          update: {
            args: Prisma.TransactionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.TransactionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>[]
          }
          upsert: {
            args: Prisma.TransactionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionHistoryPayload>
          }
          aggregate: {
            args: Prisma.TransactionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionHistory>
          }
          groupBy: {
            args: Prisma.TransactionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionHistoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userCompany?: UserCompanyOmit
    company?: CompanyOmit
    service?: ServiceOmit
    department?: DepartmentOmit
    attendance?: AttendanceOmit
    leave?: LeaveOmit
    workingDay?: WorkingDayOmit
    task?: TaskOmit
    chat?: ChatOmit
    chatMember?: ChatMemberOmit
    message?: MessageOmit
    inventoryItem?: InventoryItemOmit
    inventoryMovement?: InventoryMovementOmit
    supplier?: SupplierOmit
    supplierItem?: SupplierItemOmit
    gatePass?: GatePassOmit
    document?: DocumentOmit
    performanceReview?: PerformanceReviewOmit
    auditLog?: AuditLogOmit
    creditsRecharge?: CreditsRechargeOmit
    transactionHistory?: TransactionHistoryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    enabledServices: number
    userCompanies: number
    headedDepartments: number
    attendances: number
    auditLogs: number
    chatMembers: number
    documentUploads: number
    gatePassesCreated: number
    gatePassesFor: number
    leaves: number
    sentMessages: number
    reviewsGiven: number
    performanceReviews: number
    tasksAssigned: number
    tasksCreated: number
    creditsRecharges: number
    subordinates: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enabledServices?: boolean | UserCountOutputTypeCountEnabledServicesArgs
    userCompanies?: boolean | UserCountOutputTypeCountUserCompaniesArgs
    headedDepartments?: boolean | UserCountOutputTypeCountHeadedDepartmentsArgs
    attendances?: boolean | UserCountOutputTypeCountAttendancesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    chatMembers?: boolean | UserCountOutputTypeCountChatMembersArgs
    documentUploads?: boolean | UserCountOutputTypeCountDocumentUploadsArgs
    gatePassesCreated?: boolean | UserCountOutputTypeCountGatePassesCreatedArgs
    gatePassesFor?: boolean | UserCountOutputTypeCountGatePassesForArgs
    leaves?: boolean | UserCountOutputTypeCountLeavesArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    reviewsGiven?: boolean | UserCountOutputTypeCountReviewsGivenArgs
    performanceReviews?: boolean | UserCountOutputTypeCountPerformanceReviewsArgs
    tasksAssigned?: boolean | UserCountOutputTypeCountTasksAssignedArgs
    tasksCreated?: boolean | UserCountOutputTypeCountTasksCreatedArgs
    creditsRecharges?: boolean | UserCountOutputTypeCountCreditsRechargesArgs
    subordinates?: boolean | UserCountOutputTypeCountSubordinatesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnabledServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCompanyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHeadedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGatePassesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GatePassWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGatePassesForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GatePassWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPerformanceReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreditsRechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditsRechargeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    userCompanies: number
    services: number
    auditLogs: number
    chats: number
    departments: number
    documents: number
    gatePasses: number
    inventoryItems: number
    suppliers: number
    workingDays: number
    creditsRecharges: number
    transactionHistory: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCompanies?: boolean | CompanyCountOutputTypeCountUserCompaniesArgs
    services?: boolean | CompanyCountOutputTypeCountServicesArgs
    auditLogs?: boolean | CompanyCountOutputTypeCountAuditLogsArgs
    chats?: boolean | CompanyCountOutputTypeCountChatsArgs
    departments?: boolean | CompanyCountOutputTypeCountDepartmentsArgs
    documents?: boolean | CompanyCountOutputTypeCountDocumentsArgs
    gatePasses?: boolean | CompanyCountOutputTypeCountGatePassesArgs
    inventoryItems?: boolean | CompanyCountOutputTypeCountInventoryItemsArgs
    suppliers?: boolean | CompanyCountOutputTypeCountSuppliersArgs
    workingDays?: boolean | CompanyCountOutputTypeCountWorkingDaysArgs
    creditsRecharges?: boolean | CompanyCountOutputTypeCountCreditsRechargesArgs
    transactionHistory?: boolean | CompanyCountOutputTypeCountTransactionHistoryArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUserCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCompanyWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountGatePassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GatePassWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWorkingDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkingDayWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCreditsRechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditsRechargeWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTransactionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionHistoryWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    transactions: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | ServiceCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionHistoryWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    tasks: number
    users: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | DepartmentCountOutputTypeCountTasksArgs
    users?: boolean | DepartmentCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    members: number
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ChatCountOutputTypeCountMembersArgs
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMemberWhereInput
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type InventoryItemCountOutputType
   */

  export type InventoryItemCountOutputType = {
    movements: number
    supplierItems: number
  }

  export type InventoryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | InventoryItemCountOutputTypeCountMovementsArgs
    supplierItems?: boolean | InventoryItemCountOutputTypeCountSupplierItemsArgs
  }

  // Custom InputTypes
  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItemCountOutputType
     */
    select?: InventoryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountSupplierItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierItemWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    items: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SupplierCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    salary: number | null
    workingHoursPerDay: number | null
    Salary: number | null
  }

  export type UserSumAggregateOutputType = {
    salary: number | null
    workingHoursPerDay: number | null
    Salary: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firebaseId: string | null
    email: string | null
    fullName: string | null
    phone: string | null
    profileImage: string | null
    employeeId: string | null
    designation: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    dateOfJoining: Date | null
    dateOfBirth: Date | null
    address: string | null
    emergencyContact: string | null
    salary: number | null
    workingHoursPerDay: number | null
    createdAt: Date | null
    updatedAt: Date | null
    departmentId: string | null
    managerId: string | null
    Salary: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firebaseId: string | null
    email: string | null
    fullName: string | null
    phone: string | null
    profileImage: string | null
    employeeId: string | null
    designation: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    dateOfJoining: Date | null
    dateOfBirth: Date | null
    address: string | null
    emergencyContact: string | null
    salary: number | null
    workingHoursPerDay: number | null
    createdAt: Date | null
    updatedAt: Date | null
    departmentId: string | null
    managerId: string | null
    Salary: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firebaseId: number
    email: number
    fullName: number
    phone: number
    profileImage: number
    employeeId: number
    designation: number
    role: number
    isActive: number
    dateOfJoining: number
    dateOfBirth: number
    address: number
    emergencyContact: number
    salary: number
    workingHoursPerDay: number
    createdAt: number
    updatedAt: number
    departmentId: number
    managerId: number
    Salary: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    salary?: true
    workingHoursPerDay?: true
    Salary?: true
  }

  export type UserSumAggregateInputType = {
    salary?: true
    workingHoursPerDay?: true
    Salary?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firebaseId?: true
    email?: true
    fullName?: true
    phone?: true
    profileImage?: true
    employeeId?: true
    designation?: true
    role?: true
    isActive?: true
    dateOfJoining?: true
    dateOfBirth?: true
    address?: true
    emergencyContact?: true
    salary?: true
    workingHoursPerDay?: true
    createdAt?: true
    updatedAt?: true
    departmentId?: true
    managerId?: true
    Salary?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firebaseId?: true
    email?: true
    fullName?: true
    phone?: true
    profileImage?: true
    employeeId?: true
    designation?: true
    role?: true
    isActive?: true
    dateOfJoining?: true
    dateOfBirth?: true
    address?: true
    emergencyContact?: true
    salary?: true
    workingHoursPerDay?: true
    createdAt?: true
    updatedAt?: true
    departmentId?: true
    managerId?: true
    Salary?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firebaseId?: true
    email?: true
    fullName?: true
    phone?: true
    profileImage?: true
    employeeId?: true
    designation?: true
    role?: true
    isActive?: true
    dateOfJoining?: true
    dateOfBirth?: true
    address?: true
    emergencyContact?: true
    salary?: true
    workingHoursPerDay?: true
    createdAt?: true
    updatedAt?: true
    departmentId?: true
    managerId?: true
    Salary?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firebaseId: string | null
    email: string
    fullName: string
    phone: string | null
    profileImage: string | null
    employeeId: string | null
    designation: string | null
    role: $Enums.Role
    isActive: boolean
    dateOfJoining: Date | null
    dateOfBirth: Date | null
    address: string | null
    emergencyContact: string | null
    salary: number | null
    workingHoursPerDay: number | null
    createdAt: Date
    updatedAt: Date
    departmentId: string | null
    managerId: string | null
    Salary: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    email?: boolean
    fullName?: boolean
    phone?: boolean
    profileImage?: boolean
    employeeId?: boolean
    designation?: boolean
    role?: boolean
    isActive?: boolean
    dateOfJoining?: boolean
    dateOfBirth?: boolean
    address?: boolean
    emergencyContact?: boolean
    salary?: boolean
    workingHoursPerDay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departmentId?: boolean
    managerId?: boolean
    Salary?: boolean
    enabledServices?: boolean | User$enabledServicesArgs<ExtArgs>
    userCompanies?: boolean | User$userCompaniesArgs<ExtArgs>
    headedDepartments?: boolean | User$headedDepartmentsArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    chatMembers?: boolean | User$chatMembersArgs<ExtArgs>
    documentUploads?: boolean | User$documentUploadsArgs<ExtArgs>
    gatePassesCreated?: boolean | User$gatePassesCreatedArgs<ExtArgs>
    gatePassesFor?: boolean | User$gatePassesForArgs<ExtArgs>
    leaves?: boolean | User$leavesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    performanceReviews?: boolean | User$performanceReviewsArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    creditsRecharges?: boolean | User$creditsRechargesArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    subordinates?: boolean | User$subordinatesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    email?: boolean
    fullName?: boolean
    phone?: boolean
    profileImage?: boolean
    employeeId?: boolean
    designation?: boolean
    role?: boolean
    isActive?: boolean
    dateOfJoining?: boolean
    dateOfBirth?: boolean
    address?: boolean
    emergencyContact?: boolean
    salary?: boolean
    workingHoursPerDay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departmentId?: boolean
    managerId?: boolean
    Salary?: boolean
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firebaseId?: boolean
    email?: boolean
    fullName?: boolean
    phone?: boolean
    profileImage?: boolean
    employeeId?: boolean
    designation?: boolean
    role?: boolean
    isActive?: boolean
    dateOfJoining?: boolean
    dateOfBirth?: boolean
    address?: boolean
    emergencyContact?: boolean
    salary?: boolean
    workingHoursPerDay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departmentId?: boolean
    managerId?: boolean
    Salary?: boolean
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firebaseId?: boolean
    email?: boolean
    fullName?: boolean
    phone?: boolean
    profileImage?: boolean
    employeeId?: boolean
    designation?: boolean
    role?: boolean
    isActive?: boolean
    dateOfJoining?: boolean
    dateOfBirth?: boolean
    address?: boolean
    emergencyContact?: boolean
    salary?: boolean
    workingHoursPerDay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departmentId?: boolean
    managerId?: boolean
    Salary?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firebaseId" | "email" | "fullName" | "phone" | "profileImage" | "employeeId" | "designation" | "role" | "isActive" | "dateOfJoining" | "dateOfBirth" | "address" | "emergencyContact" | "salary" | "workingHoursPerDay" | "createdAt" | "updatedAt" | "departmentId" | "managerId" | "Salary", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enabledServices?: boolean | User$enabledServicesArgs<ExtArgs>
    userCompanies?: boolean | User$userCompaniesArgs<ExtArgs>
    headedDepartments?: boolean | User$headedDepartmentsArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    chatMembers?: boolean | User$chatMembersArgs<ExtArgs>
    documentUploads?: boolean | User$documentUploadsArgs<ExtArgs>
    gatePassesCreated?: boolean | User$gatePassesCreatedArgs<ExtArgs>
    gatePassesFor?: boolean | User$gatePassesForArgs<ExtArgs>
    leaves?: boolean | User$leavesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    performanceReviews?: boolean | User$performanceReviewsArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    creditsRecharges?: boolean | User$creditsRechargesArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    subordinates?: boolean | User$subordinatesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      enabledServices: Prisma.$TransactionHistoryPayload<ExtArgs>[]
      userCompanies: Prisma.$UserCompanyPayload<ExtArgs>[]
      headedDepartments: Prisma.$DepartmentPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      chatMembers: Prisma.$ChatMemberPayload<ExtArgs>[]
      documentUploads: Prisma.$DocumentPayload<ExtArgs>[]
      gatePassesCreated: Prisma.$GatePassPayload<ExtArgs>[]
      gatePassesFor: Prisma.$GatePassPayload<ExtArgs>[]
      leaves: Prisma.$LeavePayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      reviewsGiven: Prisma.$PerformanceReviewPayload<ExtArgs>[]
      performanceReviews: Prisma.$PerformanceReviewPayload<ExtArgs>[]
      tasksAssigned: Prisma.$TaskPayload<ExtArgs>[]
      tasksCreated: Prisma.$TaskPayload<ExtArgs>[]
      creditsRecharges: Prisma.$CreditsRechargePayload<ExtArgs>[]
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      manager: Prisma.$UserPayload<ExtArgs> | null
      subordinates: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firebaseId: string | null
      email: string
      fullName: string
      phone: string | null
      profileImage: string | null
      employeeId: string | null
      designation: string | null
      role: $Enums.Role
      isActive: boolean
      dateOfJoining: Date | null
      dateOfBirth: Date | null
      address: string | null
      emergencyContact: string | null
      salary: number | null
      workingHoursPerDay: number | null
      createdAt: Date
      updatedAt: Date
      departmentId: string | null
      managerId: string | null
      Salary: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enabledServices<T extends User$enabledServicesArgs<ExtArgs> = {}>(args?: Subset<T, User$enabledServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userCompanies<T extends User$userCompaniesArgs<ExtArgs> = {}>(args?: Subset<T, User$userCompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    headedDepartments<T extends User$headedDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$headedDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends User$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, User$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatMembers<T extends User$chatMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$chatMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentUploads<T extends User$documentUploadsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentUploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gatePassesCreated<T extends User$gatePassesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$gatePassesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gatePassesFor<T extends User$gatePassesForArgs<ExtArgs> = {}>(args?: Subset<T, User$gatePassesForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaves<T extends User$leavesArgs<ExtArgs> = {}>(args?: Subset<T, User$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewsGiven<T extends User$reviewsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performanceReviews<T extends User$performanceReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$performanceReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasksAssigned<T extends User$tasksAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasksCreated<T extends User$tasksCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditsRecharges<T extends User$creditsRechargesArgs<ExtArgs> = {}>(args?: Subset<T, User$creditsRechargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    department<T extends User$departmentArgs<ExtArgs> = {}>(args?: Subset<T, User$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    manager<T extends User$managerArgs<ExtArgs> = {}>(args?: Subset<T, User$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subordinates<T extends User$subordinatesArgs<ExtArgs> = {}>(args?: Subset<T, User$subordinatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firebaseId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly employeeId: FieldRef<"User", 'String'>
    readonly designation: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly dateOfJoining: FieldRef<"User", 'DateTime'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly address: FieldRef<"User", 'String'>
    readonly emergencyContact: FieldRef<"User", 'String'>
    readonly salary: FieldRef<"User", 'Float'>
    readonly workingHoursPerDay: FieldRef<"User", 'Float'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly departmentId: FieldRef<"User", 'String'>
    readonly managerId: FieldRef<"User", 'String'>
    readonly Salary: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.enabledServices
   */
  export type User$enabledServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    where?: TransactionHistoryWhereInput
    orderBy?: TransactionHistoryOrderByWithRelationInput | TransactionHistoryOrderByWithRelationInput[]
    cursor?: TransactionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionHistoryScalarFieldEnum | TransactionHistoryScalarFieldEnum[]
  }

  /**
   * User.userCompanies
   */
  export type User$userCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    where?: UserCompanyWhereInput
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    cursor?: UserCompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCompanyScalarFieldEnum | UserCompanyScalarFieldEnum[]
  }

  /**
   * User.headedDepartments
   */
  export type User$headedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * User.attendances
   */
  export type User$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.chatMembers
   */
  export type User$chatMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    where?: ChatMemberWhereInput
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    cursor?: ChatMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMemberScalarFieldEnum | ChatMemberScalarFieldEnum[]
  }

  /**
   * User.documentUploads
   */
  export type User$documentUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.gatePassesCreated
   */
  export type User$gatePassesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    where?: GatePassWhereInput
    orderBy?: GatePassOrderByWithRelationInput | GatePassOrderByWithRelationInput[]
    cursor?: GatePassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GatePassScalarFieldEnum | GatePassScalarFieldEnum[]
  }

  /**
   * User.gatePassesFor
   */
  export type User$gatePassesForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    where?: GatePassWhereInput
    orderBy?: GatePassOrderByWithRelationInput | GatePassOrderByWithRelationInput[]
    cursor?: GatePassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GatePassScalarFieldEnum | GatePassScalarFieldEnum[]
  }

  /**
   * User.leaves
   */
  export type User$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.reviewsGiven
   */
  export type User$reviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    where?: PerformanceReviewWhereInput
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    cursor?: PerformanceReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * User.performanceReviews
   */
  export type User$performanceReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    where?: PerformanceReviewWhereInput
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    cursor?: PerformanceReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * User.tasksAssigned
   */
  export type User$tasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.tasksCreated
   */
  export type User$tasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.creditsRecharges
   */
  export type User$creditsRechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
    where?: CreditsRechargeWhereInput
    orderBy?: CreditsRechargeOrderByWithRelationInput | CreditsRechargeOrderByWithRelationInput[]
    cursor?: CreditsRechargeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditsRechargeScalarFieldEnum | CreditsRechargeScalarFieldEnum[]
  }

  /**
   * User.department
   */
  export type User$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * User.manager
   */
  export type User$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.subordinates
   */
  export type User$subordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserCompany
   */

  export type AggregateUserCompany = {
    _count: UserCompanyCountAggregateOutputType | null
    _min: UserCompanyMinAggregateOutputType | null
    _max: UserCompanyMaxAggregateOutputType | null
  }

  export type UserCompanyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    joinedAt: Date | null
    leftAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCompanyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    joinedAt: Date | null
    leftAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCompanyCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    role: number
    isActive: number
    joinedAt: number
    leftAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserCompanyMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    role?: true
    isActive?: true
    joinedAt?: true
    leftAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCompanyMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    role?: true
    isActive?: true
    joinedAt?: true
    leftAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCompanyCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    role?: true
    isActive?: true
    joinedAt?: true
    leftAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCompany to aggregate.
     */
    where?: UserCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCompanies to fetch.
     */
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCompanies
    **/
    _count?: true | UserCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCompanyMaxAggregateInputType
  }

  export type GetUserCompanyAggregateType<T extends UserCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCompany[P]>
      : GetScalarType<T[P], AggregateUserCompany[P]>
  }




  export type UserCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCompanyWhereInput
    orderBy?: UserCompanyOrderByWithAggregationInput | UserCompanyOrderByWithAggregationInput[]
    by: UserCompanyScalarFieldEnum[] | UserCompanyScalarFieldEnum
    having?: UserCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCompanyCountAggregateInputType | true
    _min?: UserCompanyMinAggregateInputType
    _max?: UserCompanyMaxAggregateInputType
  }

  export type UserCompanyGroupByOutputType = {
    id: string
    userId: string
    companyId: string
    role: $Enums.Role
    isActive: boolean
    joinedAt: Date
    leftAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCompanyCountAggregateOutputType | null
    _min: UserCompanyMinAggregateOutputType | null
    _max: UserCompanyMaxAggregateOutputType | null
  }

  type GetUserCompanyGroupByPayload<T extends UserCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], UserCompanyGroupByOutputType[P]>
        }
      >
    >


  export type UserCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    role?: boolean
    isActive?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCompany"]>

  export type UserCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    role?: boolean
    isActive?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCompany"]>

  export type UserCompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    role?: boolean
    isActive?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCompany"]>

  export type UserCompanySelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    role?: boolean
    isActive?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserCompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyId" | "role" | "isActive" | "joinedAt" | "leftAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userCompany"]>
  export type UserCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type UserCompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type UserCompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $UserCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCompany"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string
      role: $Enums.Role
      isActive: boolean
      joinedAt: Date
      leftAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userCompany"]>
    composites: {}
  }

  type UserCompanyGetPayload<S extends boolean | null | undefined | UserCompanyDefaultArgs> = $Result.GetResult<Prisma.$UserCompanyPayload, S>

  type UserCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCompanyCountAggregateInputType | true
    }

  export interface UserCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCompany'], meta: { name: 'UserCompany' } }
    /**
     * Find zero or one UserCompany that matches the filter.
     * @param {UserCompanyFindUniqueArgs} args - Arguments to find a UserCompany
     * @example
     * // Get one UserCompany
     * const userCompany = await prisma.userCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCompanyFindUniqueArgs>(args: SelectSubset<T, UserCompanyFindUniqueArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCompany that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCompanyFindUniqueOrThrowArgs} args - Arguments to find a UserCompany
     * @example
     * // Get one UserCompany
     * const userCompany = await prisma.userCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyFindFirstArgs} args - Arguments to find a UserCompany
     * @example
     * // Get one UserCompany
     * const userCompany = await prisma.userCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCompanyFindFirstArgs>(args?: SelectSubset<T, UserCompanyFindFirstArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyFindFirstOrThrowArgs} args - Arguments to find a UserCompany
     * @example
     * // Get one UserCompany
     * const userCompany = await prisma.userCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCompanies
     * const userCompanies = await prisma.userCompany.findMany()
     * 
     * // Get first 10 UserCompanies
     * const userCompanies = await prisma.userCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCompanyWithIdOnly = await prisma.userCompany.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCompanyFindManyArgs>(args?: SelectSubset<T, UserCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCompany.
     * @param {UserCompanyCreateArgs} args - Arguments to create a UserCompany.
     * @example
     * // Create one UserCompany
     * const UserCompany = await prisma.userCompany.create({
     *   data: {
     *     // ... data to create a UserCompany
     *   }
     * })
     * 
     */
    create<T extends UserCompanyCreateArgs>(args: SelectSubset<T, UserCompanyCreateArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCompanies.
     * @param {UserCompanyCreateManyArgs} args - Arguments to create many UserCompanies.
     * @example
     * // Create many UserCompanies
     * const userCompany = await prisma.userCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCompanyCreateManyArgs>(args?: SelectSubset<T, UserCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCompanies and returns the data saved in the database.
     * @param {UserCompanyCreateManyAndReturnArgs} args - Arguments to create many UserCompanies.
     * @example
     * // Create many UserCompanies
     * const userCompany = await prisma.userCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCompanies and only return the `id`
     * const userCompanyWithIdOnly = await prisma.userCompany.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserCompany.
     * @param {UserCompanyDeleteArgs} args - Arguments to delete one UserCompany.
     * @example
     * // Delete one UserCompany
     * const UserCompany = await prisma.userCompany.delete({
     *   where: {
     *     // ... filter to delete one UserCompany
     *   }
     * })
     * 
     */
    delete<T extends UserCompanyDeleteArgs>(args: SelectSubset<T, UserCompanyDeleteArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCompany.
     * @param {UserCompanyUpdateArgs} args - Arguments to update one UserCompany.
     * @example
     * // Update one UserCompany
     * const userCompany = await prisma.userCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCompanyUpdateArgs>(args: SelectSubset<T, UserCompanyUpdateArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCompanies.
     * @param {UserCompanyDeleteManyArgs} args - Arguments to filter UserCompanies to delete.
     * @example
     * // Delete a few UserCompanies
     * const { count } = await prisma.userCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCompanyDeleteManyArgs>(args?: SelectSubset<T, UserCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCompanies
     * const userCompany = await prisma.userCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCompanyUpdateManyArgs>(args: SelectSubset<T, UserCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCompanies and returns the data updated in the database.
     * @param {UserCompanyUpdateManyAndReturnArgs} args - Arguments to update many UserCompanies.
     * @example
     * // Update many UserCompanies
     * const userCompany = await prisma.userCompany.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserCompanies and only return the `id`
     * const userCompanyWithIdOnly = await prisma.userCompany.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserCompany.
     * @param {UserCompanyUpsertArgs} args - Arguments to update or create a UserCompany.
     * @example
     * // Update or create a UserCompany
     * const userCompany = await prisma.userCompany.upsert({
     *   create: {
     *     // ... data to create a UserCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCompany we want to update
     *   }
     * })
     */
    upsert<T extends UserCompanyUpsertArgs>(args: SelectSubset<T, UserCompanyUpsertArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyCountArgs} args - Arguments to filter UserCompanies to count.
     * @example
     * // Count the number of UserCompanies
     * const count = await prisma.userCompany.count({
     *   where: {
     *     // ... the filter for the UserCompanies we want to count
     *   }
     * })
    **/
    count<T extends UserCompanyCountArgs>(
      args?: Subset<T, UserCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCompanyAggregateArgs>(args: Subset<T, UserCompanyAggregateArgs>): Prisma.PrismaPromise<GetUserCompanyAggregateType<T>>

    /**
     * Group by UserCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCompanyGroupByArgs['orderBy'] }
        : { orderBy?: UserCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCompany model
   */
  readonly fields: UserCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCompany model
   */
  interface UserCompanyFieldRefs {
    readonly id: FieldRef<"UserCompany", 'String'>
    readonly userId: FieldRef<"UserCompany", 'String'>
    readonly companyId: FieldRef<"UserCompany", 'String'>
    readonly role: FieldRef<"UserCompany", 'Role'>
    readonly isActive: FieldRef<"UserCompany", 'Boolean'>
    readonly joinedAt: FieldRef<"UserCompany", 'DateTime'>
    readonly leftAt: FieldRef<"UserCompany", 'DateTime'>
    readonly createdAt: FieldRef<"UserCompany", 'DateTime'>
    readonly updatedAt: FieldRef<"UserCompany", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserCompany findUnique
   */
  export type UserCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter, which UserCompany to fetch.
     */
    where: UserCompanyWhereUniqueInput
  }

  /**
   * UserCompany findUniqueOrThrow
   */
  export type UserCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter, which UserCompany to fetch.
     */
    where: UserCompanyWhereUniqueInput
  }

  /**
   * UserCompany findFirst
   */
  export type UserCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter, which UserCompany to fetch.
     */
    where?: UserCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCompanies to fetch.
     */
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCompanies.
     */
    cursor?: UserCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCompanies.
     */
    distinct?: UserCompanyScalarFieldEnum | UserCompanyScalarFieldEnum[]
  }

  /**
   * UserCompany findFirstOrThrow
   */
  export type UserCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter, which UserCompany to fetch.
     */
    where?: UserCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCompanies to fetch.
     */
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCompanies.
     */
    cursor?: UserCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCompanies.
     */
    distinct?: UserCompanyScalarFieldEnum | UserCompanyScalarFieldEnum[]
  }

  /**
   * UserCompany findMany
   */
  export type UserCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter, which UserCompanies to fetch.
     */
    where?: UserCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCompanies to fetch.
     */
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCompanies.
     */
    cursor?: UserCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCompanies.
     */
    skip?: number
    distinct?: UserCompanyScalarFieldEnum | UserCompanyScalarFieldEnum[]
  }

  /**
   * UserCompany create
   */
  export type UserCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCompany.
     */
    data: XOR<UserCompanyCreateInput, UserCompanyUncheckedCreateInput>
  }

  /**
   * UserCompany createMany
   */
  export type UserCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCompanies.
     */
    data: UserCompanyCreateManyInput | UserCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCompany createManyAndReturn
   */
  export type UserCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * The data used to create many UserCompanies.
     */
    data: UserCompanyCreateManyInput | UserCompanyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCompany update
   */
  export type UserCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCompany.
     */
    data: XOR<UserCompanyUpdateInput, UserCompanyUncheckedUpdateInput>
    /**
     * Choose, which UserCompany to update.
     */
    where: UserCompanyWhereUniqueInput
  }

  /**
   * UserCompany updateMany
   */
  export type UserCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCompanies.
     */
    data: XOR<UserCompanyUpdateManyMutationInput, UserCompanyUncheckedUpdateManyInput>
    /**
     * Filter which UserCompanies to update
     */
    where?: UserCompanyWhereInput
    /**
     * Limit how many UserCompanies to update.
     */
    limit?: number
  }

  /**
   * UserCompany updateManyAndReturn
   */
  export type UserCompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * The data used to update UserCompanies.
     */
    data: XOR<UserCompanyUpdateManyMutationInput, UserCompanyUncheckedUpdateManyInput>
    /**
     * Filter which UserCompanies to update
     */
    where?: UserCompanyWhereInput
    /**
     * Limit how many UserCompanies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCompany upsert
   */
  export type UserCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCompany to update in case it exists.
     */
    where: UserCompanyWhereUniqueInput
    /**
     * In case the UserCompany found by the `where` argument doesn't exist, create a new UserCompany with this data.
     */
    create: XOR<UserCompanyCreateInput, UserCompanyUncheckedCreateInput>
    /**
     * In case the UserCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCompanyUpdateInput, UserCompanyUncheckedUpdateInput>
  }

  /**
   * UserCompany delete
   */
  export type UserCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter which UserCompany to delete.
     */
    where: UserCompanyWhereUniqueInput
  }

  /**
   * UserCompany deleteMany
   */
  export type UserCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCompanies to delete
     */
    where?: UserCompanyWhereInput
    /**
     * Limit how many UserCompanies to delete.
     */
    limit?: number
  }

  /**
   * UserCompany without action
   */
  export type UserCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    totalCredits: number | null
    usedCredits: number | null
  }

  export type CompanySumAggregateOutputType = {
    totalCredits: number | null
    usedCredits: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    website: string | null
    logo: string | null
    industry: string | null
    gstNumber: string | null
    panNumber: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    Country: string | null
    totalCredits: number | null
    usedCredits: number | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    website: string | null
    logo: string | null
    industry: string | null
    gstNumber: string | null
    panNumber: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    Country: string | null
    totalCredits: number | null
    usedCredits: number | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    email: number
    website: number
    logo: number
    industry: number
    gstNumber: number
    panNumber: number
    isActive: number
    createdAt: number
    updatedAt: number
    Country: number
    totalCredits: number
    usedCredits: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    totalCredits?: true
    usedCredits?: true
  }

  export type CompanySumAggregateInputType = {
    totalCredits?: true
    usedCredits?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    logo?: true
    industry?: true
    gstNumber?: true
    panNumber?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    Country?: true
    totalCredits?: true
    usedCredits?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    logo?: true
    industry?: true
    gstNumber?: true
    panNumber?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    Country?: true
    totalCredits?: true
    usedCredits?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    logo?: true
    industry?: true
    gstNumber?: true
    panNumber?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    Country?: true
    totalCredits?: true
    usedCredits?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    address: string | null
    phone: string | null
    email: string | null
    website: string | null
    logo: string | null
    industry: string | null
    gstNumber: string | null
    panNumber: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    Country: string | null
    totalCredits: number
    usedCredits: number
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    logo?: boolean
    industry?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Country?: boolean
    totalCredits?: boolean
    usedCredits?: boolean
    userCompanies?: boolean | Company$userCompaniesArgs<ExtArgs>
    services?: boolean | Company$servicesArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    chats?: boolean | Company$chatsArgs<ExtArgs>
    departments?: boolean | Company$departmentsArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    gatePasses?: boolean | Company$gatePassesArgs<ExtArgs>
    inventoryItems?: boolean | Company$inventoryItemsArgs<ExtArgs>
    suppliers?: boolean | Company$suppliersArgs<ExtArgs>
    workingDays?: boolean | Company$workingDaysArgs<ExtArgs>
    creditsRecharges?: boolean | Company$creditsRechargesArgs<ExtArgs>
    transactionHistory?: boolean | Company$transactionHistoryArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    logo?: boolean
    industry?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Country?: boolean
    totalCredits?: boolean
    usedCredits?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    logo?: boolean
    industry?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Country?: boolean
    totalCredits?: boolean
    usedCredits?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    logo?: boolean
    industry?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Country?: boolean
    totalCredits?: boolean
    usedCredits?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phone" | "email" | "website" | "logo" | "industry" | "gstNumber" | "panNumber" | "isActive" | "createdAt" | "updatedAt" | "Country" | "totalCredits" | "usedCredits", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCompanies?: boolean | Company$userCompaniesArgs<ExtArgs>
    services?: boolean | Company$servicesArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    chats?: boolean | Company$chatsArgs<ExtArgs>
    departments?: boolean | Company$departmentsArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    gatePasses?: boolean | Company$gatePassesArgs<ExtArgs>
    inventoryItems?: boolean | Company$inventoryItemsArgs<ExtArgs>
    suppliers?: boolean | Company$suppliersArgs<ExtArgs>
    workingDays?: boolean | Company$workingDaysArgs<ExtArgs>
    creditsRecharges?: boolean | Company$creditsRechargesArgs<ExtArgs>
    transactionHistory?: boolean | Company$transactionHistoryArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      userCompanies: Prisma.$UserCompanyPayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      gatePasses: Prisma.$GatePassPayload<ExtArgs>[]
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      suppliers: Prisma.$SupplierPayload<ExtArgs>[]
      workingDays: Prisma.$WorkingDayPayload<ExtArgs>[]
      creditsRecharges: Prisma.$CreditsRechargePayload<ExtArgs>[]
      transactionHistory: Prisma.$TransactionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      phone: string | null
      email: string | null
      website: string | null
      logo: string | null
      industry: string | null
      gstNumber: string | null
      panNumber: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      Country: string | null
      totalCredits: number
      usedCredits: number
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userCompanies<T extends Company$userCompaniesArgs<ExtArgs> = {}>(args?: Subset<T, Company$userCompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends Company$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Company$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Company$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chats<T extends Company$chatsArgs<ExtArgs> = {}>(args?: Subset<T, Company$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departments<T extends Company$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Company$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gatePasses<T extends Company$gatePassesArgs<ExtArgs> = {}>(args?: Subset<T, Company$gatePassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryItems<T extends Company$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Company$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suppliers<T extends Company$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Company$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workingDays<T extends Company$workingDaysArgs<ExtArgs> = {}>(args?: Subset<T, Company$workingDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditsRecharges<T extends Company$creditsRechargesArgs<ExtArgs> = {}>(args?: Subset<T, Company$creditsRechargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionHistory<T extends Company$transactionHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Company$transactionHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly website: FieldRef<"Company", 'String'>
    readonly logo: FieldRef<"Company", 'String'>
    readonly industry: FieldRef<"Company", 'String'>
    readonly gstNumber: FieldRef<"Company", 'String'>
    readonly panNumber: FieldRef<"Company", 'String'>
    readonly isActive: FieldRef<"Company", 'Boolean'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
    readonly Country: FieldRef<"Company", 'String'>
    readonly totalCredits: FieldRef<"Company", 'Float'>
    readonly usedCredits: FieldRef<"Company", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.userCompanies
   */
  export type Company$userCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    where?: UserCompanyWhereInput
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    cursor?: UserCompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCompanyScalarFieldEnum | UserCompanyScalarFieldEnum[]
  }

  /**
   * Company.services
   */
  export type Company$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Company.auditLogs
   */
  export type Company$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Company.chats
   */
  export type Company$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Company.departments
   */
  export type Company$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Company.documents
   */
  export type Company$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Company.gatePasses
   */
  export type Company$gatePassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    where?: GatePassWhereInput
    orderBy?: GatePassOrderByWithRelationInput | GatePassOrderByWithRelationInput[]
    cursor?: GatePassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GatePassScalarFieldEnum | GatePassScalarFieldEnum[]
  }

  /**
   * Company.inventoryItems
   */
  export type Company$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Company.suppliers
   */
  export type Company$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Company.workingDays
   */
  export type Company$workingDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayInclude<ExtArgs> | null
    where?: WorkingDayWhereInput
    orderBy?: WorkingDayOrderByWithRelationInput | WorkingDayOrderByWithRelationInput[]
    cursor?: WorkingDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkingDayScalarFieldEnum | WorkingDayScalarFieldEnum[]
  }

  /**
   * Company.creditsRecharges
   */
  export type Company$creditsRechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
    where?: CreditsRechargeWhereInput
    orderBy?: CreditsRechargeOrderByWithRelationInput | CreditsRechargeOrderByWithRelationInput[]
    cursor?: CreditsRechargeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditsRechargeScalarFieldEnum | CreditsRechargeScalarFieldEnum[]
  }

  /**
   * Company.transactionHistory
   */
  export type Company$transactionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    where?: TransactionHistoryWhereInput
    orderBy?: TransactionHistoryOrderByWithRelationInput | TransactionHistoryOrderByWithRelationInput[]
    cursor?: TransactionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionHistoryScalarFieldEnum | TransactionHistoryScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: number | null
  }

  export type ServiceSumAggregateOutputType = {
    price: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    isActive: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transactions?: boolean | Service$transactionsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "isActive" | "createdAt" | "updatedAt" | "companyId", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transactions?: boolean | Service$transactionsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      transactions: Prisma.$TransactionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Service$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Service$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Float'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
    readonly companyId: FieldRef<"Service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.transactions
   */
  export type Service$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    where?: TransactionHistoryWhereInput
    orderBy?: TransactionHistoryOrderByWithRelationInput | TransactionHistoryOrderByWithRelationInput[]
    cursor?: TransactionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionHistoryScalarFieldEnum | TransactionHistoryScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    headOfDeptId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    headOfDeptId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    headOfDeptId: number
    isActive: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    headOfDeptId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    headOfDeptId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    headOfDeptId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    headOfDeptId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    headOfDeptId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    headOfDept?: boolean | Department$headOfDeptArgs<ExtArgs>
    tasks?: boolean | Department$tasksArgs<ExtArgs>
    users?: boolean | Department$usersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    headOfDeptId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    headOfDept?: boolean | Department$headOfDeptArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    headOfDeptId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    headOfDept?: boolean | Department$headOfDeptArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    headOfDeptId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "headOfDeptId" | "isActive" | "createdAt" | "updatedAt" | "companyId", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    headOfDept?: boolean | Department$headOfDeptArgs<ExtArgs>
    tasks?: boolean | Department$tasksArgs<ExtArgs>
    users?: boolean | Department$usersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    headOfDept?: boolean | Department$headOfDeptArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    headOfDept?: boolean | Department$headOfDeptArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      headOfDept: Prisma.$UserPayload<ExtArgs> | null
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      headOfDeptId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    headOfDept<T extends Department$headOfDeptArgs<ExtArgs> = {}>(args?: Subset<T, Department$headOfDeptArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Department$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Department$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Department$usersArgs<ExtArgs> = {}>(args?: Subset<T, Department$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly headOfDeptId: FieldRef<"Department", 'String'>
    readonly isActive: FieldRef<"Department", 'Boolean'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
    readonly companyId: FieldRef<"Department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.headOfDept
   */
  export type Department$headOfDeptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Department.tasks
   */
  export type Department$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Department.users
   */
  export type Department$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    workingHours: number | null
    overtimeHours: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    workingHours: number | null
    overtimeHours: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    clockInTime: Date | null
    clockOutTime: Date | null
    workingHours: number | null
    overtimeHours: number | null
    status: $Enums.AttendanceStatus | null
    location: string | null
    notes: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    companyId: string | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    clockInTime: Date | null
    clockOutTime: Date | null
    workingHours: number | null
    overtimeHours: number | null
    status: $Enums.AttendanceStatus | null
    location: string | null
    notes: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    companyId: string | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    clockInTime: number
    clockOutTime: number
    workingHours: number
    overtimeHours: number
    status: number
    location: number
    notes: number
    date: number
    createdAt: number
    updatedAt: number
    userId: number
    companyId: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    workingHours?: true
    overtimeHours?: true
  }

  export type AttendanceSumAggregateInputType = {
    workingHours?: true
    overtimeHours?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    clockInTime?: true
    clockOutTime?: true
    workingHours?: true
    overtimeHours?: true
    status?: true
    location?: true
    notes?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    companyId?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    clockInTime?: true
    clockOutTime?: true
    workingHours?: true
    overtimeHours?: true
    status?: true
    location?: true
    notes?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    companyId?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    clockInTime?: true
    clockOutTime?: true
    workingHours?: true
    overtimeHours?: true
    status?: true
    location?: true
    notes?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    companyId?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    clockInTime: Date | null
    clockOutTime: Date | null
    workingHours: number | null
    overtimeHours: number | null
    status: $Enums.AttendanceStatus
    location: string | null
    notes: string | null
    date: Date
    createdAt: Date
    updatedAt: Date
    userId: string
    companyId: string
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clockInTime?: boolean
    clockOutTime?: boolean
    workingHours?: boolean
    overtimeHours?: boolean
    status?: boolean
    location?: boolean
    notes?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clockInTime?: boolean
    clockOutTime?: boolean
    workingHours?: boolean
    overtimeHours?: boolean
    status?: boolean
    location?: boolean
    notes?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clockInTime?: boolean
    clockOutTime?: boolean
    workingHours?: boolean
    overtimeHours?: boolean
    status?: boolean
    location?: boolean
    notes?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    clockInTime?: boolean
    clockOutTime?: boolean
    workingHours?: boolean
    overtimeHours?: boolean
    status?: boolean
    location?: boolean
    notes?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    companyId?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clockInTime" | "clockOutTime" | "workingHours" | "overtimeHours" | "status" | "location" | "notes" | "date" | "createdAt" | "updatedAt" | "userId" | "companyId", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clockInTime: Date | null
      clockOutTime: Date | null
      workingHours: number | null
      overtimeHours: number | null
      status: $Enums.AttendanceStatus
      location: string | null
      notes: string | null
      date: Date
      createdAt: Date
      updatedAt: Date
      userId: string
      companyId: string
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly clockInTime: FieldRef<"Attendance", 'DateTime'>
    readonly clockOutTime: FieldRef<"Attendance", 'DateTime'>
    readonly workingHours: FieldRef<"Attendance", 'Float'>
    readonly overtimeHours: FieldRef<"Attendance", 'Float'>
    readonly status: FieldRef<"Attendance", 'AttendanceStatus'>
    readonly location: FieldRef<"Attendance", 'String'>
    readonly notes: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
    readonly userId: FieldRef<"Attendance", 'String'>
    readonly companyId: FieldRef<"Attendance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Leave
   */

  export type AggregateLeave = {
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  export type LeaveAvgAggregateOutputType = {
    totalDays: number | null
  }

  export type LeaveSumAggregateOutputType = {
    totalDays: number | null
  }

  export type LeaveMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    leaveType: $Enums.LeaveType | null
    reason: string | null
    status: $Enums.LeaveStatus | null
    appliedDate: Date | null
    approvedBy: string | null
    rejectedBy: string | null
    comments: string | null
    totalDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    companyId: string | null
  }

  export type LeaveMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    leaveType: $Enums.LeaveType | null
    reason: string | null
    status: $Enums.LeaveStatus | null
    appliedDate: Date | null
    approvedBy: string | null
    rejectedBy: string | null
    comments: string | null
    totalDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    companyId: string | null
  }

  export type LeaveCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    leaveType: number
    reason: number
    status: number
    appliedDate: number
    approvedBy: number
    rejectedBy: number
    comments: number
    totalDays: number
    createdAt: number
    updatedAt: number
    userId: number
    companyId: number
    _all: number
  }


  export type LeaveAvgAggregateInputType = {
    totalDays?: true
  }

  export type LeaveSumAggregateInputType = {
    totalDays?: true
  }

  export type LeaveMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    leaveType?: true
    reason?: true
    status?: true
    appliedDate?: true
    approvedBy?: true
    rejectedBy?: true
    comments?: true
    totalDays?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    companyId?: true
  }

  export type LeaveMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    leaveType?: true
    reason?: true
    status?: true
    appliedDate?: true
    approvedBy?: true
    rejectedBy?: true
    comments?: true
    totalDays?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    companyId?: true
  }

  export type LeaveCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    leaveType?: true
    reason?: true
    status?: true
    appliedDate?: true
    approvedBy?: true
    rejectedBy?: true
    comments?: true
    totalDays?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    companyId?: true
    _all?: true
  }

  export type LeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave to aggregate.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaves
    **/
    _count?: true | LeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveMaxAggregateInputType
  }

  export type GetLeaveAggregateType<T extends LeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave[P]>
      : GetScalarType<T[P], AggregateLeave[P]>
  }




  export type LeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithAggregationInput | LeaveOrderByWithAggregationInput[]
    by: LeaveScalarFieldEnum[] | LeaveScalarFieldEnum
    having?: LeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveCountAggregateInputType | true
    _avg?: LeaveAvgAggregateInputType
    _sum?: LeaveSumAggregateInputType
    _min?: LeaveMinAggregateInputType
    _max?: LeaveMaxAggregateInputType
  }

  export type LeaveGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    leaveType: $Enums.LeaveType
    reason: string
    status: $Enums.LeaveStatus
    appliedDate: Date
    approvedBy: string | null
    rejectedBy: string | null
    comments: string | null
    totalDays: number
    createdAt: Date
    updatedAt: Date
    userId: string
    companyId: string
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  type GetLeaveGroupByPayload<T extends LeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveGroupByOutputType[P]>
        }
      >
    >


  export type LeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    leaveType?: boolean
    reason?: boolean
    status?: boolean
    appliedDate?: boolean
    approvedBy?: boolean
    rejectedBy?: boolean
    comments?: boolean
    totalDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    leaveType?: boolean
    reason?: boolean
    status?: boolean
    appliedDate?: boolean
    approvedBy?: boolean
    rejectedBy?: boolean
    comments?: boolean
    totalDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    leaveType?: boolean
    reason?: boolean
    status?: boolean
    appliedDate?: boolean
    approvedBy?: boolean
    rejectedBy?: boolean
    comments?: boolean
    totalDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    leaveType?: boolean
    reason?: boolean
    status?: boolean
    appliedDate?: boolean
    approvedBy?: boolean
    rejectedBy?: boolean
    comments?: boolean
    totalDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    companyId?: boolean
  }

  export type LeaveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startDate" | "endDate" | "leaveType" | "reason" | "status" | "appliedDate" | "approvedBy" | "rejectedBy" | "comments" | "totalDays" | "createdAt" | "updatedAt" | "userId" | "companyId", ExtArgs["result"]["leave"]>
  export type LeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeaveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeaveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startDate: Date
      endDate: Date
      leaveType: $Enums.LeaveType
      reason: string
      status: $Enums.LeaveStatus
      appliedDate: Date
      approvedBy: string | null
      rejectedBy: string | null
      comments: string | null
      totalDays: number
      createdAt: Date
      updatedAt: Date
      userId: string
      companyId: string
    }, ExtArgs["result"]["leave"]>
    composites: {}
  }

  type LeaveGetPayload<S extends boolean | null | undefined | LeaveDefaultArgs> = $Result.GetResult<Prisma.$LeavePayload, S>

  type LeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveCountAggregateInputType | true
    }

  export interface LeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave'], meta: { name: 'Leave' } }
    /**
     * Find zero or one Leave that matches the filter.
     * @param {LeaveFindUniqueArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveFindUniqueArgs>(args: SelectSubset<T, LeaveFindUniqueArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveFindUniqueOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveFindFirstArgs>(args?: SelectSubset<T, LeaveFindFirstArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaves
     * const leaves = await prisma.leave.findMany()
     * 
     * // Get first 10 Leaves
     * const leaves = await prisma.leave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveWithIdOnly = await prisma.leave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveFindManyArgs>(args?: SelectSubset<T, LeaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave.
     * @param {LeaveCreateArgs} args - Arguments to create a Leave.
     * @example
     * // Create one Leave
     * const Leave = await prisma.leave.create({
     *   data: {
     *     // ... data to create a Leave
     *   }
     * })
     * 
     */
    create<T extends LeaveCreateArgs>(args: SelectSubset<T, LeaveCreateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leaves.
     * @param {LeaveCreateManyArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveCreateManyArgs>(args?: SelectSubset<T, LeaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leaves and returns the data saved in the database.
     * @param {LeaveCreateManyAndReturnArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leaves and only return the `id`
     * const leaveWithIdOnly = await prisma.leave.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leave.
     * @param {LeaveDeleteArgs} args - Arguments to delete one Leave.
     * @example
     * // Delete one Leave
     * const Leave = await prisma.leave.delete({
     *   where: {
     *     // ... filter to delete one Leave
     *   }
     * })
     * 
     */
    delete<T extends LeaveDeleteArgs>(args: SelectSubset<T, LeaveDeleteArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave.
     * @param {LeaveUpdateArgs} args - Arguments to update one Leave.
     * @example
     * // Update one Leave
     * const leave = await prisma.leave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveUpdateArgs>(args: SelectSubset<T, LeaveUpdateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leaves.
     * @param {LeaveDeleteManyArgs} args - Arguments to filter Leaves to delete.
     * @example
     * // Delete a few Leaves
     * const { count } = await prisma.leave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveDeleteManyArgs>(args?: SelectSubset<T, LeaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveUpdateManyArgs>(args: SelectSubset<T, LeaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves and returns the data updated in the database.
     * @param {LeaveUpdateManyAndReturnArgs} args - Arguments to update many Leaves.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leaves and only return the `id`
     * const leaveWithIdOnly = await prisma.leave.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leave.
     * @param {LeaveUpsertArgs} args - Arguments to update or create a Leave.
     * @example
     * // Update or create a Leave
     * const leave = await prisma.leave.upsert({
     *   create: {
     *     // ... data to create a Leave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave we want to update
     *   }
     * })
     */
    upsert<T extends LeaveUpsertArgs>(args: SelectSubset<T, LeaveUpsertArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveCountArgs} args - Arguments to filter Leaves to count.
     * @example
     * // Count the number of Leaves
     * const count = await prisma.leave.count({
     *   where: {
     *     // ... the filter for the Leaves we want to count
     *   }
     * })
    **/
    count<T extends LeaveCountArgs>(
      args?: Subset<T, LeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAggregateArgs>(args: Subset<T, LeaveAggregateArgs>): Prisma.PrismaPromise<GetLeaveAggregateType<T>>

    /**
     * Group by Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveGroupByArgs['orderBy'] }
        : { orderBy?: LeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave model
   */
  readonly fields: LeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave model
   */
  interface LeaveFieldRefs {
    readonly id: FieldRef<"Leave", 'String'>
    readonly startDate: FieldRef<"Leave", 'DateTime'>
    readonly endDate: FieldRef<"Leave", 'DateTime'>
    readonly leaveType: FieldRef<"Leave", 'LeaveType'>
    readonly reason: FieldRef<"Leave", 'String'>
    readonly status: FieldRef<"Leave", 'LeaveStatus'>
    readonly appliedDate: FieldRef<"Leave", 'DateTime'>
    readonly approvedBy: FieldRef<"Leave", 'String'>
    readonly rejectedBy: FieldRef<"Leave", 'String'>
    readonly comments: FieldRef<"Leave", 'String'>
    readonly totalDays: FieldRef<"Leave", 'Int'>
    readonly createdAt: FieldRef<"Leave", 'DateTime'>
    readonly updatedAt: FieldRef<"Leave", 'DateTime'>
    readonly userId: FieldRef<"Leave", 'String'>
    readonly companyId: FieldRef<"Leave", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Leave findUnique
   */
  export type LeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findUniqueOrThrow
   */
  export type LeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findFirst
   */
  export type LeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findFirstOrThrow
   */
  export type LeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findMany
   */
  export type LeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leaves to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave create
   */
  export type LeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave.
     */
    data: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
  }

  /**
   * Leave createMany
   */
  export type LeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave createManyAndReturn
   */
  export type LeaveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave update
   */
  export type LeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave.
     */
    data: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
    /**
     * Choose, which Leave to update.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave updateMany
   */
  export type LeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
  }

  /**
   * Leave updateManyAndReturn
   */
  export type LeaveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave upsert
   */
  export type LeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave to update in case it exists.
     */
    where: LeaveWhereUniqueInput
    /**
     * In case the Leave found by the `where` argument doesn't exist, create a new Leave with this data.
     */
    create: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
    /**
     * In case the Leave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
  }

  /**
   * Leave delete
   */
  export type LeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter which Leave to delete.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave deleteMany
   */
  export type LeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaves to delete
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to delete.
     */
    limit?: number
  }

  /**
   * Leave without action
   */
  export type LeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
  }


  /**
   * Model WorkingDay
   */

  export type AggregateWorkingDay = {
    _count: WorkingDayCountAggregateOutputType | null
    _avg: WorkingDayAvgAggregateOutputType | null
    _sum: WorkingDaySumAggregateOutputType | null
    _min: WorkingDayMinAggregateOutputType | null
    _max: WorkingDayMaxAggregateOutputType | null
  }

  export type WorkingDayAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type WorkingDaySumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type WorkingDayMinAggregateOutputType = {
    id: string | null
    dayOfWeek: number | null
    isWorking: boolean | null
    startTime: string | null
    endTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type WorkingDayMaxAggregateOutputType = {
    id: string | null
    dayOfWeek: number | null
    isWorking: boolean | null
    startTime: string | null
    endTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type WorkingDayCountAggregateOutputType = {
    id: number
    dayOfWeek: number
    isWorking: number
    startTime: number
    endTime: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type WorkingDayAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type WorkingDaySumAggregateInputType = {
    dayOfWeek?: true
  }

  export type WorkingDayMinAggregateInputType = {
    id?: true
    dayOfWeek?: true
    isWorking?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type WorkingDayMaxAggregateInputType = {
    id?: true
    dayOfWeek?: true
    isWorking?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type WorkingDayCountAggregateInputType = {
    id?: true
    dayOfWeek?: true
    isWorking?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type WorkingDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkingDay to aggregate.
     */
    where?: WorkingDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingDays to fetch.
     */
    orderBy?: WorkingDayOrderByWithRelationInput | WorkingDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkingDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkingDays
    **/
    _count?: true | WorkingDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkingDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkingDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkingDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkingDayMaxAggregateInputType
  }

  export type GetWorkingDayAggregateType<T extends WorkingDayAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkingDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkingDay[P]>
      : GetScalarType<T[P], AggregateWorkingDay[P]>
  }




  export type WorkingDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkingDayWhereInput
    orderBy?: WorkingDayOrderByWithAggregationInput | WorkingDayOrderByWithAggregationInput[]
    by: WorkingDayScalarFieldEnum[] | WorkingDayScalarFieldEnum
    having?: WorkingDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkingDayCountAggregateInputType | true
    _avg?: WorkingDayAvgAggregateInputType
    _sum?: WorkingDaySumAggregateInputType
    _min?: WorkingDayMinAggregateInputType
    _max?: WorkingDayMaxAggregateInputType
  }

  export type WorkingDayGroupByOutputType = {
    id: string
    dayOfWeek: number
    isWorking: boolean
    startTime: string | null
    endTime: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: WorkingDayCountAggregateOutputType | null
    _avg: WorkingDayAvgAggregateOutputType | null
    _sum: WorkingDaySumAggregateOutputType | null
    _min: WorkingDayMinAggregateOutputType | null
    _max: WorkingDayMaxAggregateOutputType | null
  }

  type GetWorkingDayGroupByPayload<T extends WorkingDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkingDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkingDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkingDayGroupByOutputType[P]>
            : GetScalarType<T[P], WorkingDayGroupByOutputType[P]>
        }
      >
    >


  export type WorkingDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    isWorking?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingDay"]>

  export type WorkingDaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    isWorking?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingDay"]>

  export type WorkingDaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    isWorking?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingDay"]>

  export type WorkingDaySelectScalar = {
    id?: boolean
    dayOfWeek?: boolean
    isWorking?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type WorkingDayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dayOfWeek" | "isWorking" | "startTime" | "endTime" | "createdAt" | "updatedAt" | "companyId", ExtArgs["result"]["workingDay"]>
  export type WorkingDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type WorkingDayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type WorkingDayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $WorkingDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkingDay"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dayOfWeek: number
      isWorking: boolean
      startTime: string | null
      endTime: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["workingDay"]>
    composites: {}
  }

  type WorkingDayGetPayload<S extends boolean | null | undefined | WorkingDayDefaultArgs> = $Result.GetResult<Prisma.$WorkingDayPayload, S>

  type WorkingDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkingDayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkingDayCountAggregateInputType | true
    }

  export interface WorkingDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkingDay'], meta: { name: 'WorkingDay' } }
    /**
     * Find zero or one WorkingDay that matches the filter.
     * @param {WorkingDayFindUniqueArgs} args - Arguments to find a WorkingDay
     * @example
     * // Get one WorkingDay
     * const workingDay = await prisma.workingDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkingDayFindUniqueArgs>(args: SelectSubset<T, WorkingDayFindUniqueArgs<ExtArgs>>): Prisma__WorkingDayClient<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkingDay that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkingDayFindUniqueOrThrowArgs} args - Arguments to find a WorkingDay
     * @example
     * // Get one WorkingDay
     * const workingDay = await prisma.workingDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkingDayFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkingDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkingDayClient<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkingDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDayFindFirstArgs} args - Arguments to find a WorkingDay
     * @example
     * // Get one WorkingDay
     * const workingDay = await prisma.workingDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkingDayFindFirstArgs>(args?: SelectSubset<T, WorkingDayFindFirstArgs<ExtArgs>>): Prisma__WorkingDayClient<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkingDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDayFindFirstOrThrowArgs} args - Arguments to find a WorkingDay
     * @example
     * // Get one WorkingDay
     * const workingDay = await prisma.workingDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkingDayFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkingDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkingDayClient<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkingDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkingDays
     * const workingDays = await prisma.workingDay.findMany()
     * 
     * // Get first 10 WorkingDays
     * const workingDays = await prisma.workingDay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workingDayWithIdOnly = await prisma.workingDay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkingDayFindManyArgs>(args?: SelectSubset<T, WorkingDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkingDay.
     * @param {WorkingDayCreateArgs} args - Arguments to create a WorkingDay.
     * @example
     * // Create one WorkingDay
     * const WorkingDay = await prisma.workingDay.create({
     *   data: {
     *     // ... data to create a WorkingDay
     *   }
     * })
     * 
     */
    create<T extends WorkingDayCreateArgs>(args: SelectSubset<T, WorkingDayCreateArgs<ExtArgs>>): Prisma__WorkingDayClient<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkingDays.
     * @param {WorkingDayCreateManyArgs} args - Arguments to create many WorkingDays.
     * @example
     * // Create many WorkingDays
     * const workingDay = await prisma.workingDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkingDayCreateManyArgs>(args?: SelectSubset<T, WorkingDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkingDays and returns the data saved in the database.
     * @param {WorkingDayCreateManyAndReturnArgs} args - Arguments to create many WorkingDays.
     * @example
     * // Create many WorkingDays
     * const workingDay = await prisma.workingDay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkingDays and only return the `id`
     * const workingDayWithIdOnly = await prisma.workingDay.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkingDayCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkingDayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkingDay.
     * @param {WorkingDayDeleteArgs} args - Arguments to delete one WorkingDay.
     * @example
     * // Delete one WorkingDay
     * const WorkingDay = await prisma.workingDay.delete({
     *   where: {
     *     // ... filter to delete one WorkingDay
     *   }
     * })
     * 
     */
    delete<T extends WorkingDayDeleteArgs>(args: SelectSubset<T, WorkingDayDeleteArgs<ExtArgs>>): Prisma__WorkingDayClient<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkingDay.
     * @param {WorkingDayUpdateArgs} args - Arguments to update one WorkingDay.
     * @example
     * // Update one WorkingDay
     * const workingDay = await prisma.workingDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkingDayUpdateArgs>(args: SelectSubset<T, WorkingDayUpdateArgs<ExtArgs>>): Prisma__WorkingDayClient<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkingDays.
     * @param {WorkingDayDeleteManyArgs} args - Arguments to filter WorkingDays to delete.
     * @example
     * // Delete a few WorkingDays
     * const { count } = await prisma.workingDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkingDayDeleteManyArgs>(args?: SelectSubset<T, WorkingDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkingDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkingDays
     * const workingDay = await prisma.workingDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkingDayUpdateManyArgs>(args: SelectSubset<T, WorkingDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkingDays and returns the data updated in the database.
     * @param {WorkingDayUpdateManyAndReturnArgs} args - Arguments to update many WorkingDays.
     * @example
     * // Update many WorkingDays
     * const workingDay = await prisma.workingDay.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkingDays and only return the `id`
     * const workingDayWithIdOnly = await prisma.workingDay.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkingDayUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkingDayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkingDay.
     * @param {WorkingDayUpsertArgs} args - Arguments to update or create a WorkingDay.
     * @example
     * // Update or create a WorkingDay
     * const workingDay = await prisma.workingDay.upsert({
     *   create: {
     *     // ... data to create a WorkingDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkingDay we want to update
     *   }
     * })
     */
    upsert<T extends WorkingDayUpsertArgs>(args: SelectSubset<T, WorkingDayUpsertArgs<ExtArgs>>): Prisma__WorkingDayClient<$Result.GetResult<Prisma.$WorkingDayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkingDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDayCountArgs} args - Arguments to filter WorkingDays to count.
     * @example
     * // Count the number of WorkingDays
     * const count = await prisma.workingDay.count({
     *   where: {
     *     // ... the filter for the WorkingDays we want to count
     *   }
     * })
    **/
    count<T extends WorkingDayCountArgs>(
      args?: Subset<T, WorkingDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkingDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkingDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkingDayAggregateArgs>(args: Subset<T, WorkingDayAggregateArgs>): Prisma.PrismaPromise<GetWorkingDayAggregateType<T>>

    /**
     * Group by WorkingDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkingDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkingDayGroupByArgs['orderBy'] }
        : { orderBy?: WorkingDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkingDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkingDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkingDay model
   */
  readonly fields: WorkingDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkingDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkingDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkingDay model
   */
  interface WorkingDayFieldRefs {
    readonly id: FieldRef<"WorkingDay", 'String'>
    readonly dayOfWeek: FieldRef<"WorkingDay", 'Int'>
    readonly isWorking: FieldRef<"WorkingDay", 'Boolean'>
    readonly startTime: FieldRef<"WorkingDay", 'String'>
    readonly endTime: FieldRef<"WorkingDay", 'String'>
    readonly createdAt: FieldRef<"WorkingDay", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkingDay", 'DateTime'>
    readonly companyId: FieldRef<"WorkingDay", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkingDay findUnique
   */
  export type WorkingDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayInclude<ExtArgs> | null
    /**
     * Filter, which WorkingDay to fetch.
     */
    where: WorkingDayWhereUniqueInput
  }

  /**
   * WorkingDay findUniqueOrThrow
   */
  export type WorkingDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayInclude<ExtArgs> | null
    /**
     * Filter, which WorkingDay to fetch.
     */
    where: WorkingDayWhereUniqueInput
  }

  /**
   * WorkingDay findFirst
   */
  export type WorkingDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayInclude<ExtArgs> | null
    /**
     * Filter, which WorkingDay to fetch.
     */
    where?: WorkingDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingDays to fetch.
     */
    orderBy?: WorkingDayOrderByWithRelationInput | WorkingDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkingDays.
     */
    cursor?: WorkingDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkingDays.
     */
    distinct?: WorkingDayScalarFieldEnum | WorkingDayScalarFieldEnum[]
  }

  /**
   * WorkingDay findFirstOrThrow
   */
  export type WorkingDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayInclude<ExtArgs> | null
    /**
     * Filter, which WorkingDay to fetch.
     */
    where?: WorkingDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingDays to fetch.
     */
    orderBy?: WorkingDayOrderByWithRelationInput | WorkingDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkingDays.
     */
    cursor?: WorkingDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkingDays.
     */
    distinct?: WorkingDayScalarFieldEnum | WorkingDayScalarFieldEnum[]
  }

  /**
   * WorkingDay findMany
   */
  export type WorkingDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayInclude<ExtArgs> | null
    /**
     * Filter, which WorkingDays to fetch.
     */
    where?: WorkingDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingDays to fetch.
     */
    orderBy?: WorkingDayOrderByWithRelationInput | WorkingDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkingDays.
     */
    cursor?: WorkingDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingDays.
     */
    skip?: number
    distinct?: WorkingDayScalarFieldEnum | WorkingDayScalarFieldEnum[]
  }

  /**
   * WorkingDay create
   */
  export type WorkingDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkingDay.
     */
    data: XOR<WorkingDayCreateInput, WorkingDayUncheckedCreateInput>
  }

  /**
   * WorkingDay createMany
   */
  export type WorkingDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkingDays.
     */
    data: WorkingDayCreateManyInput | WorkingDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkingDay createManyAndReturn
   */
  export type WorkingDayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * The data used to create many WorkingDays.
     */
    data: WorkingDayCreateManyInput | WorkingDayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkingDay update
   */
  export type WorkingDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkingDay.
     */
    data: XOR<WorkingDayUpdateInput, WorkingDayUncheckedUpdateInput>
    /**
     * Choose, which WorkingDay to update.
     */
    where: WorkingDayWhereUniqueInput
  }

  /**
   * WorkingDay updateMany
   */
  export type WorkingDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkingDays.
     */
    data: XOR<WorkingDayUpdateManyMutationInput, WorkingDayUncheckedUpdateManyInput>
    /**
     * Filter which WorkingDays to update
     */
    where?: WorkingDayWhereInput
    /**
     * Limit how many WorkingDays to update.
     */
    limit?: number
  }

  /**
   * WorkingDay updateManyAndReturn
   */
  export type WorkingDayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * The data used to update WorkingDays.
     */
    data: XOR<WorkingDayUpdateManyMutationInput, WorkingDayUncheckedUpdateManyInput>
    /**
     * Filter which WorkingDays to update
     */
    where?: WorkingDayWhereInput
    /**
     * Limit how many WorkingDays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkingDay upsert
   */
  export type WorkingDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkingDay to update in case it exists.
     */
    where: WorkingDayWhereUniqueInput
    /**
     * In case the WorkingDay found by the `where` argument doesn't exist, create a new WorkingDay with this data.
     */
    create: XOR<WorkingDayCreateInput, WorkingDayUncheckedCreateInput>
    /**
     * In case the WorkingDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkingDayUpdateInput, WorkingDayUncheckedUpdateInput>
  }

  /**
   * WorkingDay delete
   */
  export type WorkingDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayInclude<ExtArgs> | null
    /**
     * Filter which WorkingDay to delete.
     */
    where: WorkingDayWhereUniqueInput
  }

  /**
   * WorkingDay deleteMany
   */
  export type WorkingDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkingDays to delete
     */
    where?: WorkingDayWhereInput
    /**
     * Limit how many WorkingDays to delete.
     */
    limit?: number
  }

  /**
   * WorkingDay without action
   */
  export type WorkingDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDay
     */
    select?: WorkingDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDay
     */
    omit?: WorkingDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDayInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    estimatedHours: number | null
    actualHours: number | null
    progress: number | null
  }

  export type TaskSumAggregateOutputType = {
    estimatedHours: number | null
    actualHours: number | null
    progress: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.TaskPriority | null
    startDate: Date | null
    dueDate: Date | null
    completedAt: Date | null
    estimatedHours: number | null
    actualHours: number | null
    progress: number | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedToId: string | null
    createdById: string | null
    departmentId: string | null
    companyId: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.TaskPriority | null
    startDate: Date | null
    dueDate: Date | null
    completedAt: Date | null
    estimatedHours: number | null
    actualHours: number | null
    progress: number | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedToId: string | null
    createdById: string | null
    departmentId: string | null
    companyId: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    startDate: number
    dueDate: number
    completedAt: number
    estimatedHours: number
    actualHours: number
    progress: number
    createdAt: number
    updatedAt: number
    assignedToId: number
    createdById: number
    departmentId: number
    companyId: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    estimatedHours?: true
    actualHours?: true
    progress?: true
  }

  export type TaskSumAggregateInputType = {
    estimatedHours?: true
    actualHours?: true
    progress?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    dueDate?: true
    completedAt?: true
    estimatedHours?: true
    actualHours?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    createdById?: true
    departmentId?: true
    companyId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    dueDate?: true
    completedAt?: true
    estimatedHours?: true
    actualHours?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    createdById?: true
    departmentId?: true
    companyId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    dueDate?: true
    completedAt?: true
    estimatedHours?: true
    actualHours?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    createdById?: true
    departmentId?: true
    companyId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.TaskStatus
    priority: $Enums.TaskPriority
    startDate: Date | null
    dueDate: Date | null
    completedAt: Date | null
    estimatedHours: number | null
    actualHours: number | null
    progress: number
    createdAt: Date
    updatedAt: Date
    assignedToId: string
    createdById: string
    departmentId: string | null
    companyId: string
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    dueDate?: boolean
    completedAt?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    createdById?: boolean
    departmentId?: boolean
    companyId?: boolean
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | Task$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    dueDate?: boolean
    completedAt?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    createdById?: boolean
    departmentId?: boolean
    companyId?: boolean
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | Task$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    dueDate?: boolean
    completedAt?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    createdById?: boolean
    departmentId?: boolean
    companyId?: boolean
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | Task$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    dueDate?: boolean
    completedAt?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    createdById?: boolean
    departmentId?: boolean
    companyId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "priority" | "startDate" | "dueDate" | "completedAt" | "estimatedHours" | "actualHours" | "progress" | "createdAt" | "updatedAt" | "assignedToId" | "createdById" | "departmentId" | "companyId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | Task$departmentArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | Task$departmentArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | Task$departmentArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.TaskStatus
      priority: $Enums.TaskPriority
      startDate: Date | null
      dueDate: Date | null
      completedAt: Date | null
      estimatedHours: number | null
      actualHours: number | null
      progress: number
      createdAt: Date
      updatedAt: Date
      assignedToId: string
      createdById: string
      departmentId: string | null
      companyId: string
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends Task$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Task$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly priority: FieldRef<"Task", 'TaskPriority'>
    readonly startDate: FieldRef<"Task", 'DateTime'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly completedAt: FieldRef<"Task", 'DateTime'>
    readonly estimatedHours: FieldRef<"Task", 'Float'>
    readonly actualHours: FieldRef<"Task", 'Float'>
    readonly progress: FieldRef<"Task", 'Int'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly assignedToId: FieldRef<"Task", 'String'>
    readonly createdById: FieldRef<"Task", 'String'>
    readonly departmentId: FieldRef<"Task", 'String'>
    readonly companyId: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.department
   */
  export type Task$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ChatType | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ChatType | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    name: string | null
    type: $Enums.ChatType
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    members?: boolean | Chat$membersArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "description" | "isActive" | "createdAt" | "updatedAt" | "companyId", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Chat$membersArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ChatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      members: Prisma.$ChatMemberPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      type: $Enums.ChatType
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {ChatUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Chat$membersArgs<ExtArgs> = {}>(args?: Subset<T, Chat$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly name: FieldRef<"Chat", 'String'>
    readonly type: FieldRef<"Chat", 'ChatType'>
    readonly description: FieldRef<"Chat", 'String'>
    readonly isActive: FieldRef<"Chat", 'Boolean'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
    readonly companyId: FieldRef<"Chat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat updateManyAndReturn
   */
  export type ChatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat.members
   */
  export type Chat$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    where?: ChatMemberWhereInput
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    cursor?: ChatMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMemberScalarFieldEnum | ChatMemberScalarFieldEnum[]
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model ChatMember
   */

  export type AggregateChatMember = {
    _count: ChatMemberCountAggregateOutputType | null
    _min: ChatMemberMinAggregateOutputType | null
    _max: ChatMemberMaxAggregateOutputType | null
  }

  export type ChatMemberMinAggregateOutputType = {
    id: string | null
    isAdmin: boolean | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    chatId: string | null
    userId: string | null
  }

  export type ChatMemberMaxAggregateOutputType = {
    id: string | null
    isAdmin: boolean | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    chatId: string | null
    userId: string | null
  }

  export type ChatMemberCountAggregateOutputType = {
    id: number
    isAdmin: number
    joinedAt: number
    createdAt: number
    updatedAt: number
    chatId: number
    userId: number
    _all: number
  }


  export type ChatMemberMinAggregateInputType = {
    id?: true
    isAdmin?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
    chatId?: true
    userId?: true
  }

  export type ChatMemberMaxAggregateInputType = {
    id?: true
    isAdmin?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
    chatId?: true
    userId?: true
  }

  export type ChatMemberCountAggregateInputType = {
    id?: true
    isAdmin?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
    chatId?: true
    userId?: true
    _all?: true
  }

  export type ChatMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMember to aggregate.
     */
    where?: ChatMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMembers to fetch.
     */
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMembers
    **/
    _count?: true | ChatMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMemberMaxAggregateInputType
  }

  export type GetChatMemberAggregateType<T extends ChatMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMember[P]>
      : GetScalarType<T[P], AggregateChatMember[P]>
  }




  export type ChatMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMemberWhereInput
    orderBy?: ChatMemberOrderByWithAggregationInput | ChatMemberOrderByWithAggregationInput[]
    by: ChatMemberScalarFieldEnum[] | ChatMemberScalarFieldEnum
    having?: ChatMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMemberCountAggregateInputType | true
    _min?: ChatMemberMinAggregateInputType
    _max?: ChatMemberMaxAggregateInputType
  }

  export type ChatMemberGroupByOutputType = {
    id: string
    isAdmin: boolean
    joinedAt: Date
    createdAt: Date
    updatedAt: Date
    chatId: string
    userId: string
    _count: ChatMemberCountAggregateOutputType | null
    _min: ChatMemberMinAggregateOutputType | null
    _max: ChatMemberMaxAggregateOutputType | null
  }

  type GetChatMemberGroupByPayload<T extends ChatMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMemberGroupByOutputType[P]>
        }
      >
    >


  export type ChatMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isAdmin?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chatId?: boolean
    userId?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMember"]>

  export type ChatMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isAdmin?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chatId?: boolean
    userId?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMember"]>

  export type ChatMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isAdmin?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chatId?: boolean
    userId?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMember"]>

  export type ChatMemberSelectScalar = {
    id?: boolean
    isAdmin?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chatId?: boolean
    userId?: boolean
  }

  export type ChatMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isAdmin" | "joinedAt" | "createdAt" | "updatedAt" | "chatId" | "userId", ExtArgs["result"]["chatMember"]>
  export type ChatMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMember"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isAdmin: boolean
      joinedAt: Date
      createdAt: Date
      updatedAt: Date
      chatId: string
      userId: string
    }, ExtArgs["result"]["chatMember"]>
    composites: {}
  }

  type ChatMemberGetPayload<S extends boolean | null | undefined | ChatMemberDefaultArgs> = $Result.GetResult<Prisma.$ChatMemberPayload, S>

  type ChatMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMemberCountAggregateInputType | true
    }

  export interface ChatMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMember'], meta: { name: 'ChatMember' } }
    /**
     * Find zero or one ChatMember that matches the filter.
     * @param {ChatMemberFindUniqueArgs} args - Arguments to find a ChatMember
     * @example
     * // Get one ChatMember
     * const chatMember = await prisma.chatMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMemberFindUniqueArgs>(args: SelectSubset<T, ChatMemberFindUniqueArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMemberFindUniqueOrThrowArgs} args - Arguments to find a ChatMember
     * @example
     * // Get one ChatMember
     * const chatMember = await prisma.chatMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberFindFirstArgs} args - Arguments to find a ChatMember
     * @example
     * // Get one ChatMember
     * const chatMember = await prisma.chatMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMemberFindFirstArgs>(args?: SelectSubset<T, ChatMemberFindFirstArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberFindFirstOrThrowArgs} args - Arguments to find a ChatMember
     * @example
     * // Get one ChatMember
     * const chatMember = await prisma.chatMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMembers
     * const chatMembers = await prisma.chatMember.findMany()
     * 
     * // Get first 10 ChatMembers
     * const chatMembers = await prisma.chatMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMemberWithIdOnly = await prisma.chatMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMemberFindManyArgs>(args?: SelectSubset<T, ChatMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMember.
     * @param {ChatMemberCreateArgs} args - Arguments to create a ChatMember.
     * @example
     * // Create one ChatMember
     * const ChatMember = await prisma.chatMember.create({
     *   data: {
     *     // ... data to create a ChatMember
     *   }
     * })
     * 
     */
    create<T extends ChatMemberCreateArgs>(args: SelectSubset<T, ChatMemberCreateArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMembers.
     * @param {ChatMemberCreateManyArgs} args - Arguments to create many ChatMembers.
     * @example
     * // Create many ChatMembers
     * const chatMember = await prisma.chatMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMemberCreateManyArgs>(args?: SelectSubset<T, ChatMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMembers and returns the data saved in the database.
     * @param {ChatMemberCreateManyAndReturnArgs} args - Arguments to create many ChatMembers.
     * @example
     * // Create many ChatMembers
     * const chatMember = await prisma.chatMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMembers and only return the `id`
     * const chatMemberWithIdOnly = await prisma.chatMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMember.
     * @param {ChatMemberDeleteArgs} args - Arguments to delete one ChatMember.
     * @example
     * // Delete one ChatMember
     * const ChatMember = await prisma.chatMember.delete({
     *   where: {
     *     // ... filter to delete one ChatMember
     *   }
     * })
     * 
     */
    delete<T extends ChatMemberDeleteArgs>(args: SelectSubset<T, ChatMemberDeleteArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMember.
     * @param {ChatMemberUpdateArgs} args - Arguments to update one ChatMember.
     * @example
     * // Update one ChatMember
     * const chatMember = await prisma.chatMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMemberUpdateArgs>(args: SelectSubset<T, ChatMemberUpdateArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMembers.
     * @param {ChatMemberDeleteManyArgs} args - Arguments to filter ChatMembers to delete.
     * @example
     * // Delete a few ChatMembers
     * const { count } = await prisma.chatMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMemberDeleteManyArgs>(args?: SelectSubset<T, ChatMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMembers
     * const chatMember = await prisma.chatMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMemberUpdateManyArgs>(args: SelectSubset<T, ChatMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMembers and returns the data updated in the database.
     * @param {ChatMemberUpdateManyAndReturnArgs} args - Arguments to update many ChatMembers.
     * @example
     * // Update many ChatMembers
     * const chatMember = await prisma.chatMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMembers and only return the `id`
     * const chatMemberWithIdOnly = await prisma.chatMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMember.
     * @param {ChatMemberUpsertArgs} args - Arguments to update or create a ChatMember.
     * @example
     * // Update or create a ChatMember
     * const chatMember = await prisma.chatMember.upsert({
     *   create: {
     *     // ... data to create a ChatMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMember we want to update
     *   }
     * })
     */
    upsert<T extends ChatMemberUpsertArgs>(args: SelectSubset<T, ChatMemberUpsertArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberCountArgs} args - Arguments to filter ChatMembers to count.
     * @example
     * // Count the number of ChatMembers
     * const count = await prisma.chatMember.count({
     *   where: {
     *     // ... the filter for the ChatMembers we want to count
     *   }
     * })
    **/
    count<T extends ChatMemberCountArgs>(
      args?: Subset<T, ChatMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMemberAggregateArgs>(args: Subset<T, ChatMemberAggregateArgs>): Prisma.PrismaPromise<GetChatMemberAggregateType<T>>

    /**
     * Group by ChatMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMemberGroupByArgs['orderBy'] }
        : { orderBy?: ChatMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMember model
   */
  readonly fields: ChatMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMember model
   */
  interface ChatMemberFieldRefs {
    readonly id: FieldRef<"ChatMember", 'String'>
    readonly isAdmin: FieldRef<"ChatMember", 'Boolean'>
    readonly joinedAt: FieldRef<"ChatMember", 'DateTime'>
    readonly createdAt: FieldRef<"ChatMember", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatMember", 'DateTime'>
    readonly chatId: FieldRef<"ChatMember", 'String'>
    readonly userId: FieldRef<"ChatMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChatMember findUnique
   */
  export type ChatMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatMember to fetch.
     */
    where: ChatMemberWhereUniqueInput
  }

  /**
   * ChatMember findUniqueOrThrow
   */
  export type ChatMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatMember to fetch.
     */
    where: ChatMemberWhereUniqueInput
  }

  /**
   * ChatMember findFirst
   */
  export type ChatMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatMember to fetch.
     */
    where?: ChatMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMembers to fetch.
     */
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMembers.
     */
    cursor?: ChatMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMembers.
     */
    distinct?: ChatMemberScalarFieldEnum | ChatMemberScalarFieldEnum[]
  }

  /**
   * ChatMember findFirstOrThrow
   */
  export type ChatMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatMember to fetch.
     */
    where?: ChatMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMembers to fetch.
     */
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMembers.
     */
    cursor?: ChatMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMembers.
     */
    distinct?: ChatMemberScalarFieldEnum | ChatMemberScalarFieldEnum[]
  }

  /**
   * ChatMember findMany
   */
  export type ChatMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatMembers to fetch.
     */
    where?: ChatMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMembers to fetch.
     */
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMembers.
     */
    cursor?: ChatMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMembers.
     */
    skip?: number
    distinct?: ChatMemberScalarFieldEnum | ChatMemberScalarFieldEnum[]
  }

  /**
   * ChatMember create
   */
  export type ChatMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMember.
     */
    data: XOR<ChatMemberCreateInput, ChatMemberUncheckedCreateInput>
  }

  /**
   * ChatMember createMany
   */
  export type ChatMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMembers.
     */
    data: ChatMemberCreateManyInput | ChatMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMember createManyAndReturn
   */
  export type ChatMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMembers.
     */
    data: ChatMemberCreateManyInput | ChatMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMember update
   */
  export type ChatMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMember.
     */
    data: XOR<ChatMemberUpdateInput, ChatMemberUncheckedUpdateInput>
    /**
     * Choose, which ChatMember to update.
     */
    where: ChatMemberWhereUniqueInput
  }

  /**
   * ChatMember updateMany
   */
  export type ChatMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMembers.
     */
    data: XOR<ChatMemberUpdateManyMutationInput, ChatMemberUncheckedUpdateManyInput>
    /**
     * Filter which ChatMembers to update
     */
    where?: ChatMemberWhereInput
    /**
     * Limit how many ChatMembers to update.
     */
    limit?: number
  }

  /**
   * ChatMember updateManyAndReturn
   */
  export type ChatMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * The data used to update ChatMembers.
     */
    data: XOR<ChatMemberUpdateManyMutationInput, ChatMemberUncheckedUpdateManyInput>
    /**
     * Filter which ChatMembers to update
     */
    where?: ChatMemberWhereInput
    /**
     * Limit how many ChatMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMember upsert
   */
  export type ChatMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMember to update in case it exists.
     */
    where: ChatMemberWhereUniqueInput
    /**
     * In case the ChatMember found by the `where` argument doesn't exist, create a new ChatMember with this data.
     */
    create: XOR<ChatMemberCreateInput, ChatMemberUncheckedCreateInput>
    /**
     * In case the ChatMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMemberUpdateInput, ChatMemberUncheckedUpdateInput>
  }

  /**
   * ChatMember delete
   */
  export type ChatMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter which ChatMember to delete.
     */
    where: ChatMemberWhereUniqueInput
  }

  /**
   * ChatMember deleteMany
   */
  export type ChatMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMembers to delete
     */
    where?: ChatMemberWhereInput
    /**
     * Limit how many ChatMembers to delete.
     */
    limit?: number
  }

  /**
   * ChatMember without action
   */
  export type ChatMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMember
     */
    omit?: ChatMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    type: $Enums.MessageType | null
    fileUrl: string | null
    fileName: string | null
    isPinned: boolean | null
    replyTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    chatId: string | null
    senderId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    type: $Enums.MessageType | null
    fileUrl: string | null
    fileName: string | null
    isPinned: boolean | null
    replyTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    chatId: string | null
    senderId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    type: number
    fileUrl: number
    fileName: number
    isPinned: number
    replyTo: number
    createdAt: number
    updatedAt: number
    chatId: number
    senderId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    type?: true
    fileUrl?: true
    fileName?: true
    isPinned?: true
    replyTo?: true
    createdAt?: true
    updatedAt?: true
    chatId?: true
    senderId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    type?: true
    fileUrl?: true
    fileName?: true
    isPinned?: true
    replyTo?: true
    createdAt?: true
    updatedAt?: true
    chatId?: true
    senderId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    type?: true
    fileUrl?: true
    fileName?: true
    isPinned?: true
    replyTo?: true
    createdAt?: true
    updatedAt?: true
    chatId?: true
    senderId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string
    type: $Enums.MessageType
    fileUrl: string | null
    fileName: string | null
    isPinned: boolean
    replyTo: string | null
    createdAt: Date
    updatedAt: Date
    chatId: string
    senderId: string
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    type?: boolean
    fileUrl?: boolean
    fileName?: boolean
    isPinned?: boolean
    replyTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chatId?: boolean
    senderId?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    type?: boolean
    fileUrl?: boolean
    fileName?: boolean
    isPinned?: boolean
    replyTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chatId?: boolean
    senderId?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    type?: boolean
    fileUrl?: boolean
    fileName?: boolean
    isPinned?: boolean
    replyTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chatId?: boolean
    senderId?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    type?: boolean
    fileUrl?: boolean
    fileName?: boolean
    isPinned?: boolean
    replyTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chatId?: boolean
    senderId?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "type" | "fileUrl" | "fileName" | "isPinned" | "replyTo" | "createdAt" | "updatedAt" | "chatId" | "senderId", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      type: $Enums.MessageType
      fileUrl: string | null
      fileName: string | null
      isPinned: boolean
      replyTo: string | null
      createdAt: Date
      updatedAt: Date
      chatId: string
      senderId: string
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'MessageType'>
    readonly fileUrl: FieldRef<"Message", 'String'>
    readonly fileName: FieldRef<"Message", 'String'>
    readonly isPinned: FieldRef<"Message", 'Boolean'>
    readonly replyTo: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly chatId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    currentStock: number | null
    minimumStock: number | null
    maximumStock: number | null
    reorderLevel: number | null
    unitPrice: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    currentStock: number | null
    minimumStock: number | null
    maximumStock: number | null
    reorderLevel: number | null
    unitPrice: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    sku: string | null
    category: string | null
    unit: string | null
    currentStock: number | null
    minimumStock: number | null
    maximumStock: number | null
    reorderLevel: number | null
    unitPrice: number | null
    location: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    sku: string | null
    category: string | null
    unit: string | null
    currentStock: number | null
    minimumStock: number | null
    maximumStock: number | null
    reorderLevel: number | null
    unitPrice: number | null
    location: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    sku: number
    category: number
    unit: number
    currentStock: number
    minimumStock: number
    maximumStock: number
    reorderLevel: number
    unitPrice: number
    location: number
    isActive: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    currentStock?: true
    minimumStock?: true
    maximumStock?: true
    reorderLevel?: true
    unitPrice?: true
  }

  export type InventoryItemSumAggregateInputType = {
    currentStock?: true
    minimumStock?: true
    maximumStock?: true
    reorderLevel?: true
    unitPrice?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sku?: true
    category?: true
    unit?: true
    currentStock?: true
    minimumStock?: true
    maximumStock?: true
    reorderLevel?: true
    unitPrice?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sku?: true
    category?: true
    unit?: true
    currentStock?: true
    minimumStock?: true
    maximumStock?: true
    reorderLevel?: true
    unitPrice?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sku?: true
    category?: true
    unit?: true
    currentStock?: true
    minimumStock?: true
    maximumStock?: true
    reorderLevel?: true
    unitPrice?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    sku: string
    category: string | null
    unit: string
    currentStock: number
    minimumStock: number
    maximumStock: number | null
    reorderLevel: number | null
    unitPrice: number | null
    location: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    category?: boolean
    unit?: boolean
    currentStock?: boolean
    minimumStock?: boolean
    maximumStock?: boolean
    reorderLevel?: boolean
    unitPrice?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    movements?: boolean | InventoryItem$movementsArgs<ExtArgs>
    supplierItems?: boolean | InventoryItem$supplierItemsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    category?: boolean
    unit?: boolean
    currentStock?: boolean
    minimumStock?: boolean
    maximumStock?: boolean
    reorderLevel?: boolean
    unitPrice?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    category?: boolean
    unit?: boolean
    currentStock?: boolean
    minimumStock?: boolean
    maximumStock?: boolean
    reorderLevel?: boolean
    unitPrice?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    category?: boolean
    unit?: boolean
    currentStock?: boolean
    minimumStock?: boolean
    maximumStock?: boolean
    reorderLevel?: boolean
    unitPrice?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "sku" | "category" | "unit" | "currentStock" | "minimumStock" | "maximumStock" | "reorderLevel" | "unitPrice" | "location" | "isActive" | "createdAt" | "updatedAt" | "companyId", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    movements?: boolean | InventoryItem$movementsArgs<ExtArgs>
    supplierItems?: boolean | InventoryItem$supplierItemsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      movements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      supplierItems: Prisma.$SupplierItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      sku: string
      category: string | null
      unit: string
      currentStock: number
      minimumStock: number
      maximumStock: number | null
      reorderLevel: number | null
      unitPrice: number | null
      location: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    movements<T extends InventoryItem$movementsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supplierItems<T extends InventoryItem$supplierItemsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$supplierItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly name: FieldRef<"InventoryItem", 'String'>
    readonly description: FieldRef<"InventoryItem", 'String'>
    readonly sku: FieldRef<"InventoryItem", 'String'>
    readonly category: FieldRef<"InventoryItem", 'String'>
    readonly unit: FieldRef<"InventoryItem", 'String'>
    readonly currentStock: FieldRef<"InventoryItem", 'Float'>
    readonly minimumStock: FieldRef<"InventoryItem", 'Float'>
    readonly maximumStock: FieldRef<"InventoryItem", 'Float'>
    readonly reorderLevel: FieldRef<"InventoryItem", 'Float'>
    readonly unitPrice: FieldRef<"InventoryItem", 'Float'>
    readonly location: FieldRef<"InventoryItem", 'String'>
    readonly isActive: FieldRef<"InventoryItem", 'Boolean'>
    readonly createdAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly companyId: FieldRef<"InventoryItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem.movements
   */
  export type InventoryItem$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryItem.supplierItems
   */
  export type InventoryItem$supplierItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
    where?: SupplierItemWhereInput
    orderBy?: SupplierItemOrderByWithRelationInput | SupplierItemOrderByWithRelationInput[]
    cursor?: SupplierItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierItemScalarFieldEnum | SupplierItemScalarFieldEnum[]
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryMovement
   */

  export type AggregateInventoryMovement = {
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  export type InventoryMovementAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
  }

  export type InventoryMovementSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
  }

  export type InventoryMovementMinAggregateOutputType = {
    id: string | null
    movementType: $Enums.InventoryMovementType | null
    quantity: number | null
    unitPrice: number | null
    reference: string | null
    notes: string | null
    movedBy: string | null
    createdAt: Date | null
    itemId: string | null
  }

  export type InventoryMovementMaxAggregateOutputType = {
    id: string | null
    movementType: $Enums.InventoryMovementType | null
    quantity: number | null
    unitPrice: number | null
    reference: string | null
    notes: string | null
    movedBy: string | null
    createdAt: Date | null
    itemId: string | null
  }

  export type InventoryMovementCountAggregateOutputType = {
    id: number
    movementType: number
    quantity: number
    unitPrice: number
    reference: number
    notes: number
    movedBy: number
    createdAt: number
    itemId: number
    _all: number
  }


  export type InventoryMovementAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
  }

  export type InventoryMovementSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
  }

  export type InventoryMovementMinAggregateInputType = {
    id?: true
    movementType?: true
    quantity?: true
    unitPrice?: true
    reference?: true
    notes?: true
    movedBy?: true
    createdAt?: true
    itemId?: true
  }

  export type InventoryMovementMaxAggregateInputType = {
    id?: true
    movementType?: true
    quantity?: true
    unitPrice?: true
    reference?: true
    notes?: true
    movedBy?: true
    createdAt?: true
    itemId?: true
  }

  export type InventoryMovementCountAggregateInputType = {
    id?: true
    movementType?: true
    quantity?: true
    unitPrice?: true
    reference?: true
    notes?: true
    movedBy?: true
    createdAt?: true
    itemId?: true
    _all?: true
  }

  export type InventoryMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovement to aggregate.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryMovements
    **/
    _count?: true | InventoryMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type GetInventoryMovementAggregateType<T extends InventoryMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryMovement[P]>
      : GetScalarType<T[P], AggregateInventoryMovement[P]>
  }




  export type InventoryMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithAggregationInput | InventoryMovementOrderByWithAggregationInput[]
    by: InventoryMovementScalarFieldEnum[] | InventoryMovementScalarFieldEnum
    having?: InventoryMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryMovementCountAggregateInputType | true
    _avg?: InventoryMovementAvgAggregateInputType
    _sum?: InventoryMovementSumAggregateInputType
    _min?: InventoryMovementMinAggregateInputType
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type InventoryMovementGroupByOutputType = {
    id: string
    movementType: $Enums.InventoryMovementType
    quantity: number
    unitPrice: number | null
    reference: string | null
    notes: string | null
    movedBy: string
    createdAt: Date
    itemId: string
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  type GetInventoryMovementGroupByPayload<T extends InventoryMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
        }
      >
    >


  export type InventoryMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movementType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    reference?: boolean
    notes?: boolean
    movedBy?: boolean
    createdAt?: boolean
    itemId?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movementType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    reference?: boolean
    notes?: boolean
    movedBy?: boolean
    createdAt?: boolean
    itemId?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movementType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    reference?: boolean
    notes?: boolean
    movedBy?: boolean
    createdAt?: boolean
    itemId?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectScalar = {
    id?: boolean
    movementType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    reference?: boolean
    notes?: boolean
    movedBy?: boolean
    createdAt?: boolean
    itemId?: boolean
  }

  export type InventoryMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "movementType" | "quantity" | "unitPrice" | "reference" | "notes" | "movedBy" | "createdAt" | "itemId", ExtArgs["result"]["inventoryMovement"]>
  export type InventoryMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }

  export type $InventoryMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryMovement"
    objects: {
      item: Prisma.$InventoryItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      movementType: $Enums.InventoryMovementType
      quantity: number
      unitPrice: number | null
      reference: string | null
      notes: string | null
      movedBy: string
      createdAt: Date
      itemId: string
    }, ExtArgs["result"]["inventoryMovement"]>
    composites: {}
  }

  type InventoryMovementGetPayload<S extends boolean | null | undefined | InventoryMovementDefaultArgs> = $Result.GetResult<Prisma.$InventoryMovementPayload, S>

  type InventoryMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryMovementCountAggregateInputType | true
    }

  export interface InventoryMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryMovement'], meta: { name: 'InventoryMovement' } }
    /**
     * Find zero or one InventoryMovement that matches the filter.
     * @param {InventoryMovementFindUniqueArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryMovementFindUniqueArgs>(args: SelectSubset<T, InventoryMovementFindUniqueArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryMovementFindUniqueOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryMovementFindFirstArgs>(args?: SelectSubset<T, InventoryMovementFindFirstArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany()
     * 
     * // Get first 10 InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryMovementFindManyArgs>(args?: SelectSubset<T, InventoryMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryMovement.
     * @param {InventoryMovementCreateArgs} args - Arguments to create a InventoryMovement.
     * @example
     * // Create one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.create({
     *   data: {
     *     // ... data to create a InventoryMovement
     *   }
     * })
     * 
     */
    create<T extends InventoryMovementCreateArgs>(args: SelectSubset<T, InventoryMovementCreateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryMovements.
     * @param {InventoryMovementCreateManyArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryMovementCreateManyArgs>(args?: SelectSubset<T, InventoryMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryMovements and returns the data saved in the database.
     * @param {InventoryMovementCreateManyAndReturnArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryMovement.
     * @param {InventoryMovementDeleteArgs} args - Arguments to delete one InventoryMovement.
     * @example
     * // Delete one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.delete({
     *   where: {
     *     // ... filter to delete one InventoryMovement
     *   }
     * })
     * 
     */
    delete<T extends InventoryMovementDeleteArgs>(args: SelectSubset<T, InventoryMovementDeleteArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryMovement.
     * @param {InventoryMovementUpdateArgs} args - Arguments to update one InventoryMovement.
     * @example
     * // Update one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryMovementUpdateArgs>(args: SelectSubset<T, InventoryMovementUpdateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryMovements.
     * @param {InventoryMovementDeleteManyArgs} args - Arguments to filter InventoryMovements to delete.
     * @example
     * // Delete a few InventoryMovements
     * const { count } = await prisma.inventoryMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryMovementDeleteManyArgs>(args?: SelectSubset<T, InventoryMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryMovementUpdateManyArgs>(args: SelectSubset<T, InventoryMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements and returns the data updated in the database.
     * @param {InventoryMovementUpdateManyAndReturnArgs} args - Arguments to update many InventoryMovements.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryMovement.
     * @param {InventoryMovementUpsertArgs} args - Arguments to update or create a InventoryMovement.
     * @example
     * // Update or create a InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.upsert({
     *   create: {
     *     // ... data to create a InventoryMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryMovement we want to update
     *   }
     * })
     */
    upsert<T extends InventoryMovementUpsertArgs>(args: SelectSubset<T, InventoryMovementUpsertArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementCountArgs} args - Arguments to filter InventoryMovements to count.
     * @example
     * // Count the number of InventoryMovements
     * const count = await prisma.inventoryMovement.count({
     *   where: {
     *     // ... the filter for the InventoryMovements we want to count
     *   }
     * })
    **/
    count<T extends InventoryMovementCountArgs>(
      args?: Subset<T, InventoryMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryMovementAggregateArgs>(args: Subset<T, InventoryMovementAggregateArgs>): Prisma.PrismaPromise<GetInventoryMovementAggregateType<T>>

    /**
     * Group by InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryMovementGroupByArgs['orderBy'] }
        : { orderBy?: InventoryMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryMovement model
   */
  readonly fields: InventoryMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryMovement model
   */
  interface InventoryMovementFieldRefs {
    readonly id: FieldRef<"InventoryMovement", 'String'>
    readonly movementType: FieldRef<"InventoryMovement", 'InventoryMovementType'>
    readonly quantity: FieldRef<"InventoryMovement", 'Float'>
    readonly unitPrice: FieldRef<"InventoryMovement", 'Float'>
    readonly reference: FieldRef<"InventoryMovement", 'String'>
    readonly notes: FieldRef<"InventoryMovement", 'String'>
    readonly movedBy: FieldRef<"InventoryMovement", 'String'>
    readonly createdAt: FieldRef<"InventoryMovement", 'DateTime'>
    readonly itemId: FieldRef<"InventoryMovement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryMovement findUnique
   */
  export type InventoryMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findUniqueOrThrow
   */
  export type InventoryMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findFirst
   */
  export type InventoryMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findFirstOrThrow
   */
  export type InventoryMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findMany
   */
  export type InventoryMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovements to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement create
   */
  export type InventoryMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryMovement.
     */
    data: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
  }

  /**
   * InventoryMovement createMany
   */
  export type InventoryMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryMovement createManyAndReturn
   */
  export type InventoryMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement update
   */
  export type InventoryMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryMovement.
     */
    data: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
    /**
     * Choose, which InventoryMovement to update.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement updateMany
   */
  export type InventoryMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
  }

  /**
   * InventoryMovement updateManyAndReturn
   */
  export type InventoryMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement upsert
   */
  export type InventoryMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryMovement to update in case it exists.
     */
    where: InventoryMovementWhereUniqueInput
    /**
     * In case the InventoryMovement found by the `where` argument doesn't exist, create a new InventoryMovement with this data.
     */
    create: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
    /**
     * In case the InventoryMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
  }

  /**
   * InventoryMovement delete
   */
  export type InventoryMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter which InventoryMovement to delete.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement deleteMany
   */
  export type InventoryMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovements to delete
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to delete.
     */
    limit?: number
  }

  /**
   * InventoryMovement without action
   */
  export type InventoryMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    gstNumber: string | null
    panNumber: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    gstNumber: string | null
    panNumber: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    contactPerson: number
    email: number
    phone: number
    address: number
    gstNumber: number
    panNumber: number
    isActive: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    gstNumber?: true
    panNumber?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    gstNumber?: true
    panNumber?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    gstNumber?: true
    panNumber?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    name: string
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    gstNumber: string | null
    panNumber: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    items?: boolean | Supplier$itemsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contactPerson" | "email" | "phone" | "address" | "gstNumber" | "panNumber" | "isActive" | "createdAt" | "updatedAt" | "companyId", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Supplier$itemsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      items: Prisma.$SupplierItemPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contactPerson: string | null
      email: string | null
      phone: string | null
      address: string | null
      gstNumber: string | null
      panNumber: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Supplier$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contactPerson: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly gstNumber: FieldRef<"Supplier", 'String'>
    readonly panNumber: FieldRef<"Supplier", 'String'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
    readonly companyId: FieldRef<"Supplier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.items
   */
  export type Supplier$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
    where?: SupplierItemWhereInput
    orderBy?: SupplierItemOrderByWithRelationInput | SupplierItemOrderByWithRelationInput[]
    cursor?: SupplierItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierItemScalarFieldEnum | SupplierItemScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model SupplierItem
   */

  export type AggregateSupplierItem = {
    _count: SupplierItemCountAggregateOutputType | null
    _avg: SupplierItemAvgAggregateOutputType | null
    _sum: SupplierItemSumAggregateOutputType | null
    _min: SupplierItemMinAggregateOutputType | null
    _max: SupplierItemMaxAggregateOutputType | null
  }

  export type SupplierItemAvgAggregateOutputType = {
    supplierPrice: number | null
    leadTime: number | null
  }

  export type SupplierItemSumAggregateOutputType = {
    supplierPrice: number | null
    leadTime: number | null
  }

  export type SupplierItemMinAggregateOutputType = {
    id: string | null
    supplierPrice: number | null
    leadTime: number | null
    isPreferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    supplierId: string | null
    itemId: string | null
  }

  export type SupplierItemMaxAggregateOutputType = {
    id: string | null
    supplierPrice: number | null
    leadTime: number | null
    isPreferred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    supplierId: string | null
    itemId: string | null
  }

  export type SupplierItemCountAggregateOutputType = {
    id: number
    supplierPrice: number
    leadTime: number
    isPreferred: number
    createdAt: number
    updatedAt: number
    supplierId: number
    itemId: number
    _all: number
  }


  export type SupplierItemAvgAggregateInputType = {
    supplierPrice?: true
    leadTime?: true
  }

  export type SupplierItemSumAggregateInputType = {
    supplierPrice?: true
    leadTime?: true
  }

  export type SupplierItemMinAggregateInputType = {
    id?: true
    supplierPrice?: true
    leadTime?: true
    isPreferred?: true
    createdAt?: true
    updatedAt?: true
    supplierId?: true
    itemId?: true
  }

  export type SupplierItemMaxAggregateInputType = {
    id?: true
    supplierPrice?: true
    leadTime?: true
    isPreferred?: true
    createdAt?: true
    updatedAt?: true
    supplierId?: true
    itemId?: true
  }

  export type SupplierItemCountAggregateInputType = {
    id?: true
    supplierPrice?: true
    leadTime?: true
    isPreferred?: true
    createdAt?: true
    updatedAt?: true
    supplierId?: true
    itemId?: true
    _all?: true
  }

  export type SupplierItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierItem to aggregate.
     */
    where?: SupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierItems to fetch.
     */
    orderBy?: SupplierItemOrderByWithRelationInput | SupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierItems
    **/
    _count?: true | SupplierItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierItemMaxAggregateInputType
  }

  export type GetSupplierItemAggregateType<T extends SupplierItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierItem[P]>
      : GetScalarType<T[P], AggregateSupplierItem[P]>
  }




  export type SupplierItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierItemWhereInput
    orderBy?: SupplierItemOrderByWithAggregationInput | SupplierItemOrderByWithAggregationInput[]
    by: SupplierItemScalarFieldEnum[] | SupplierItemScalarFieldEnum
    having?: SupplierItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierItemCountAggregateInputType | true
    _avg?: SupplierItemAvgAggregateInputType
    _sum?: SupplierItemSumAggregateInputType
    _min?: SupplierItemMinAggregateInputType
    _max?: SupplierItemMaxAggregateInputType
  }

  export type SupplierItemGroupByOutputType = {
    id: string
    supplierPrice: number | null
    leadTime: number | null
    isPreferred: boolean
    createdAt: Date
    updatedAt: Date
    supplierId: string
    itemId: string
    _count: SupplierItemCountAggregateOutputType | null
    _avg: SupplierItemAvgAggregateOutputType | null
    _sum: SupplierItemSumAggregateOutputType | null
    _min: SupplierItemMinAggregateOutputType | null
    _max: SupplierItemMaxAggregateOutputType | null
  }

  type GetSupplierItemGroupByPayload<T extends SupplierItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierItemGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierItemGroupByOutputType[P]>
        }
      >
    >


  export type SupplierItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierPrice?: boolean
    leadTime?: boolean
    isPreferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplierId?: boolean
    itemId?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierItem"]>

  export type SupplierItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierPrice?: boolean
    leadTime?: boolean
    isPreferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplierId?: boolean
    itemId?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierItem"]>

  export type SupplierItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierPrice?: boolean
    leadTime?: boolean
    isPreferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplierId?: boolean
    itemId?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierItem"]>

  export type SupplierItemSelectScalar = {
    id?: boolean
    supplierPrice?: boolean
    leadTime?: boolean
    isPreferred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplierId?: boolean
    itemId?: boolean
  }

  export type SupplierItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplierPrice" | "leadTime" | "isPreferred" | "createdAt" | "updatedAt" | "supplierId" | "itemId", ExtArgs["result"]["supplierItem"]>
  export type SupplierItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $SupplierItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierItem"
    objects: {
      item: Prisma.$InventoryItemPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierPrice: number | null
      leadTime: number | null
      isPreferred: boolean
      createdAt: Date
      updatedAt: Date
      supplierId: string
      itemId: string
    }, ExtArgs["result"]["supplierItem"]>
    composites: {}
  }

  type SupplierItemGetPayload<S extends boolean | null | undefined | SupplierItemDefaultArgs> = $Result.GetResult<Prisma.$SupplierItemPayload, S>

  type SupplierItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierItemCountAggregateInputType | true
    }

  export interface SupplierItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierItem'], meta: { name: 'SupplierItem' } }
    /**
     * Find zero or one SupplierItem that matches the filter.
     * @param {SupplierItemFindUniqueArgs} args - Arguments to find a SupplierItem
     * @example
     * // Get one SupplierItem
     * const supplierItem = await prisma.supplierItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierItemFindUniqueArgs>(args: SelectSubset<T, SupplierItemFindUniqueArgs<ExtArgs>>): Prisma__SupplierItemClient<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierItemFindUniqueOrThrowArgs} args - Arguments to find a SupplierItem
     * @example
     * // Get one SupplierItem
     * const supplierItem = await prisma.supplierItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierItemClient<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemFindFirstArgs} args - Arguments to find a SupplierItem
     * @example
     * // Get one SupplierItem
     * const supplierItem = await prisma.supplierItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierItemFindFirstArgs>(args?: SelectSubset<T, SupplierItemFindFirstArgs<ExtArgs>>): Prisma__SupplierItemClient<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemFindFirstOrThrowArgs} args - Arguments to find a SupplierItem
     * @example
     * // Get one SupplierItem
     * const supplierItem = await prisma.supplierItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierItemClient<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierItems
     * const supplierItems = await prisma.supplierItem.findMany()
     * 
     * // Get first 10 SupplierItems
     * const supplierItems = await prisma.supplierItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierItemWithIdOnly = await prisma.supplierItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierItemFindManyArgs>(args?: SelectSubset<T, SupplierItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierItem.
     * @param {SupplierItemCreateArgs} args - Arguments to create a SupplierItem.
     * @example
     * // Create one SupplierItem
     * const SupplierItem = await prisma.supplierItem.create({
     *   data: {
     *     // ... data to create a SupplierItem
     *   }
     * })
     * 
     */
    create<T extends SupplierItemCreateArgs>(args: SelectSubset<T, SupplierItemCreateArgs<ExtArgs>>): Prisma__SupplierItemClient<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierItems.
     * @param {SupplierItemCreateManyArgs} args - Arguments to create many SupplierItems.
     * @example
     * // Create many SupplierItems
     * const supplierItem = await prisma.supplierItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierItemCreateManyArgs>(args?: SelectSubset<T, SupplierItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierItems and returns the data saved in the database.
     * @param {SupplierItemCreateManyAndReturnArgs} args - Arguments to create many SupplierItems.
     * @example
     * // Create many SupplierItems
     * const supplierItem = await prisma.supplierItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierItems and only return the `id`
     * const supplierItemWithIdOnly = await prisma.supplierItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierItem.
     * @param {SupplierItemDeleteArgs} args - Arguments to delete one SupplierItem.
     * @example
     * // Delete one SupplierItem
     * const SupplierItem = await prisma.supplierItem.delete({
     *   where: {
     *     // ... filter to delete one SupplierItem
     *   }
     * })
     * 
     */
    delete<T extends SupplierItemDeleteArgs>(args: SelectSubset<T, SupplierItemDeleteArgs<ExtArgs>>): Prisma__SupplierItemClient<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierItem.
     * @param {SupplierItemUpdateArgs} args - Arguments to update one SupplierItem.
     * @example
     * // Update one SupplierItem
     * const supplierItem = await prisma.supplierItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierItemUpdateArgs>(args: SelectSubset<T, SupplierItemUpdateArgs<ExtArgs>>): Prisma__SupplierItemClient<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierItems.
     * @param {SupplierItemDeleteManyArgs} args - Arguments to filter SupplierItems to delete.
     * @example
     * // Delete a few SupplierItems
     * const { count } = await prisma.supplierItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierItemDeleteManyArgs>(args?: SelectSubset<T, SupplierItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierItems
     * const supplierItem = await prisma.supplierItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierItemUpdateManyArgs>(args: SelectSubset<T, SupplierItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierItems and returns the data updated in the database.
     * @param {SupplierItemUpdateManyAndReturnArgs} args - Arguments to update many SupplierItems.
     * @example
     * // Update many SupplierItems
     * const supplierItem = await prisma.supplierItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierItems and only return the `id`
     * const supplierItemWithIdOnly = await prisma.supplierItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierItem.
     * @param {SupplierItemUpsertArgs} args - Arguments to update or create a SupplierItem.
     * @example
     * // Update or create a SupplierItem
     * const supplierItem = await prisma.supplierItem.upsert({
     *   create: {
     *     // ... data to create a SupplierItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierItem we want to update
     *   }
     * })
     */
    upsert<T extends SupplierItemUpsertArgs>(args: SelectSubset<T, SupplierItemUpsertArgs<ExtArgs>>): Prisma__SupplierItemClient<$Result.GetResult<Prisma.$SupplierItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemCountArgs} args - Arguments to filter SupplierItems to count.
     * @example
     * // Count the number of SupplierItems
     * const count = await prisma.supplierItem.count({
     *   where: {
     *     // ... the filter for the SupplierItems we want to count
     *   }
     * })
    **/
    count<T extends SupplierItemCountArgs>(
      args?: Subset<T, SupplierItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierItemAggregateArgs>(args: Subset<T, SupplierItemAggregateArgs>): Prisma.PrismaPromise<GetSupplierItemAggregateType<T>>

    /**
     * Group by SupplierItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierItemGroupByArgs['orderBy'] }
        : { orderBy?: SupplierItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierItem model
   */
  readonly fields: SupplierItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierItem model
   */
  interface SupplierItemFieldRefs {
    readonly id: FieldRef<"SupplierItem", 'String'>
    readonly supplierPrice: FieldRef<"SupplierItem", 'Float'>
    readonly leadTime: FieldRef<"SupplierItem", 'Int'>
    readonly isPreferred: FieldRef<"SupplierItem", 'Boolean'>
    readonly createdAt: FieldRef<"SupplierItem", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplierItem", 'DateTime'>
    readonly supplierId: FieldRef<"SupplierItem", 'String'>
    readonly itemId: FieldRef<"SupplierItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SupplierItem findUnique
   */
  export type SupplierItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which SupplierItem to fetch.
     */
    where: SupplierItemWhereUniqueInput
  }

  /**
   * SupplierItem findUniqueOrThrow
   */
  export type SupplierItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which SupplierItem to fetch.
     */
    where: SupplierItemWhereUniqueInput
  }

  /**
   * SupplierItem findFirst
   */
  export type SupplierItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which SupplierItem to fetch.
     */
    where?: SupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierItems to fetch.
     */
    orderBy?: SupplierItemOrderByWithRelationInput | SupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierItems.
     */
    cursor?: SupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierItems.
     */
    distinct?: SupplierItemScalarFieldEnum | SupplierItemScalarFieldEnum[]
  }

  /**
   * SupplierItem findFirstOrThrow
   */
  export type SupplierItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which SupplierItem to fetch.
     */
    where?: SupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierItems to fetch.
     */
    orderBy?: SupplierItemOrderByWithRelationInput | SupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierItems.
     */
    cursor?: SupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierItems.
     */
    distinct?: SupplierItemScalarFieldEnum | SupplierItemScalarFieldEnum[]
  }

  /**
   * SupplierItem findMany
   */
  export type SupplierItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which SupplierItems to fetch.
     */
    where?: SupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierItems to fetch.
     */
    orderBy?: SupplierItemOrderByWithRelationInput | SupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierItems.
     */
    cursor?: SupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierItems.
     */
    skip?: number
    distinct?: SupplierItemScalarFieldEnum | SupplierItemScalarFieldEnum[]
  }

  /**
   * SupplierItem create
   */
  export type SupplierItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierItem.
     */
    data: XOR<SupplierItemCreateInput, SupplierItemUncheckedCreateInput>
  }

  /**
   * SupplierItem createMany
   */
  export type SupplierItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierItems.
     */
    data: SupplierItemCreateManyInput | SupplierItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierItem createManyAndReturn
   */
  export type SupplierItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierItems.
     */
    data: SupplierItemCreateManyInput | SupplierItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierItem update
   */
  export type SupplierItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierItem.
     */
    data: XOR<SupplierItemUpdateInput, SupplierItemUncheckedUpdateInput>
    /**
     * Choose, which SupplierItem to update.
     */
    where: SupplierItemWhereUniqueInput
  }

  /**
   * SupplierItem updateMany
   */
  export type SupplierItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierItems.
     */
    data: XOR<SupplierItemUpdateManyMutationInput, SupplierItemUncheckedUpdateManyInput>
    /**
     * Filter which SupplierItems to update
     */
    where?: SupplierItemWhereInput
    /**
     * Limit how many SupplierItems to update.
     */
    limit?: number
  }

  /**
   * SupplierItem updateManyAndReturn
   */
  export type SupplierItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * The data used to update SupplierItems.
     */
    data: XOR<SupplierItemUpdateManyMutationInput, SupplierItemUncheckedUpdateManyInput>
    /**
     * Filter which SupplierItems to update
     */
    where?: SupplierItemWhereInput
    /**
     * Limit how many SupplierItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierItem upsert
   */
  export type SupplierItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierItem to update in case it exists.
     */
    where: SupplierItemWhereUniqueInput
    /**
     * In case the SupplierItem found by the `where` argument doesn't exist, create a new SupplierItem with this data.
     */
    create: XOR<SupplierItemCreateInput, SupplierItemUncheckedCreateInput>
    /**
     * In case the SupplierItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierItemUpdateInput, SupplierItemUncheckedUpdateInput>
  }

  /**
   * SupplierItem delete
   */
  export type SupplierItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
    /**
     * Filter which SupplierItem to delete.
     */
    where: SupplierItemWhereUniqueInput
  }

  /**
   * SupplierItem deleteMany
   */
  export type SupplierItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierItems to delete
     */
    where?: SupplierItemWhereInput
    /**
     * Limit how many SupplierItems to delete.
     */
    limit?: number
  }

  /**
   * SupplierItem without action
   */
  export type SupplierItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItem
     */
    select?: SupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierItem
     */
    omit?: SupplierItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemInclude<ExtArgs> | null
  }


  /**
   * Model GatePass
   */

  export type AggregateGatePass = {
    _count: GatePassCountAggregateOutputType | null
    _min: GatePassMinAggregateOutputType | null
    _max: GatePassMaxAggregateOutputType | null
  }

  export type GatePassMinAggregateOutputType = {
    id: string | null
    passNumber: string | null
    type: $Enums.GatePassType | null
    purpose: string | null
    visitorName: string | null
    visitorPhone: string | null
    visitorCompany: string | null
    vehicleNumber: string | null
    itemsCarried: string | null
    entryTime: Date | null
    exitTime: Date | null
    status: $Enums.GatePassStatus | null
    validUntil: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    createdById: string | null
    forUserId: string | null
  }

  export type GatePassMaxAggregateOutputType = {
    id: string | null
    passNumber: string | null
    type: $Enums.GatePassType | null
    purpose: string | null
    visitorName: string | null
    visitorPhone: string | null
    visitorCompany: string | null
    vehicleNumber: string | null
    itemsCarried: string | null
    entryTime: Date | null
    exitTime: Date | null
    status: $Enums.GatePassStatus | null
    validUntil: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    createdById: string | null
    forUserId: string | null
  }

  export type GatePassCountAggregateOutputType = {
    id: number
    passNumber: number
    type: number
    purpose: number
    visitorName: number
    visitorPhone: number
    visitorCompany: number
    vehicleNumber: number
    itemsCarried: number
    entryTime: number
    exitTime: number
    status: number
    validUntil: number
    notes: number
    createdAt: number
    updatedAt: number
    companyId: number
    createdById: number
    forUserId: number
    _all: number
  }


  export type GatePassMinAggregateInputType = {
    id?: true
    passNumber?: true
    type?: true
    purpose?: true
    visitorName?: true
    visitorPhone?: true
    visitorCompany?: true
    vehicleNumber?: true
    itemsCarried?: true
    entryTime?: true
    exitTime?: true
    status?: true
    validUntil?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    createdById?: true
    forUserId?: true
  }

  export type GatePassMaxAggregateInputType = {
    id?: true
    passNumber?: true
    type?: true
    purpose?: true
    visitorName?: true
    visitorPhone?: true
    visitorCompany?: true
    vehicleNumber?: true
    itemsCarried?: true
    entryTime?: true
    exitTime?: true
    status?: true
    validUntil?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    createdById?: true
    forUserId?: true
  }

  export type GatePassCountAggregateInputType = {
    id?: true
    passNumber?: true
    type?: true
    purpose?: true
    visitorName?: true
    visitorPhone?: true
    visitorCompany?: true
    vehicleNumber?: true
    itemsCarried?: true
    entryTime?: true
    exitTime?: true
    status?: true
    validUntil?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    createdById?: true
    forUserId?: true
    _all?: true
  }

  export type GatePassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GatePass to aggregate.
     */
    where?: GatePassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GatePasses to fetch.
     */
    orderBy?: GatePassOrderByWithRelationInput | GatePassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GatePassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GatePasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GatePasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GatePasses
    **/
    _count?: true | GatePassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GatePassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GatePassMaxAggregateInputType
  }

  export type GetGatePassAggregateType<T extends GatePassAggregateArgs> = {
        [P in keyof T & keyof AggregateGatePass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGatePass[P]>
      : GetScalarType<T[P], AggregateGatePass[P]>
  }




  export type GatePassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GatePassWhereInput
    orderBy?: GatePassOrderByWithAggregationInput | GatePassOrderByWithAggregationInput[]
    by: GatePassScalarFieldEnum[] | GatePassScalarFieldEnum
    having?: GatePassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GatePassCountAggregateInputType | true
    _min?: GatePassMinAggregateInputType
    _max?: GatePassMaxAggregateInputType
  }

  export type GatePassGroupByOutputType = {
    id: string
    passNumber: string
    type: $Enums.GatePassType
    purpose: string | null
    visitorName: string | null
    visitorPhone: string | null
    visitorCompany: string | null
    vehicleNumber: string | null
    itemsCarried: string | null
    entryTime: Date | null
    exitTime: Date | null
    status: $Enums.GatePassStatus
    validUntil: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    createdById: string
    forUserId: string | null
    _count: GatePassCountAggregateOutputType | null
    _min: GatePassMinAggregateOutputType | null
    _max: GatePassMaxAggregateOutputType | null
  }

  type GetGatePassGroupByPayload<T extends GatePassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GatePassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GatePassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GatePassGroupByOutputType[P]>
            : GetScalarType<T[P], GatePassGroupByOutputType[P]>
        }
      >
    >


  export type GatePassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passNumber?: boolean
    type?: boolean
    purpose?: boolean
    visitorName?: boolean
    visitorPhone?: boolean
    visitorCompany?: boolean
    vehicleNumber?: boolean
    itemsCarried?: boolean
    entryTime?: boolean
    exitTime?: boolean
    status?: boolean
    validUntil?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    createdById?: boolean
    forUserId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | GatePass$forUserArgs<ExtArgs>
  }, ExtArgs["result"]["gatePass"]>

  export type GatePassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passNumber?: boolean
    type?: boolean
    purpose?: boolean
    visitorName?: boolean
    visitorPhone?: boolean
    visitorCompany?: boolean
    vehicleNumber?: boolean
    itemsCarried?: boolean
    entryTime?: boolean
    exitTime?: boolean
    status?: boolean
    validUntil?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    createdById?: boolean
    forUserId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | GatePass$forUserArgs<ExtArgs>
  }, ExtArgs["result"]["gatePass"]>

  export type GatePassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passNumber?: boolean
    type?: boolean
    purpose?: boolean
    visitorName?: boolean
    visitorPhone?: boolean
    visitorCompany?: boolean
    vehicleNumber?: boolean
    itemsCarried?: boolean
    entryTime?: boolean
    exitTime?: boolean
    status?: boolean
    validUntil?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    createdById?: boolean
    forUserId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | GatePass$forUserArgs<ExtArgs>
  }, ExtArgs["result"]["gatePass"]>

  export type GatePassSelectScalar = {
    id?: boolean
    passNumber?: boolean
    type?: boolean
    purpose?: boolean
    visitorName?: boolean
    visitorPhone?: boolean
    visitorCompany?: boolean
    vehicleNumber?: boolean
    itemsCarried?: boolean
    entryTime?: boolean
    exitTime?: boolean
    status?: boolean
    validUntil?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    createdById?: boolean
    forUserId?: boolean
  }

  export type GatePassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passNumber" | "type" | "purpose" | "visitorName" | "visitorPhone" | "visitorCompany" | "vehicleNumber" | "itemsCarried" | "entryTime" | "exitTime" | "status" | "validUntil" | "notes" | "createdAt" | "updatedAt" | "companyId" | "createdById" | "forUserId", ExtArgs["result"]["gatePass"]>
  export type GatePassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | GatePass$forUserArgs<ExtArgs>
  }
  export type GatePassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | GatePass$forUserArgs<ExtArgs>
  }
  export type GatePassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | GatePass$forUserArgs<ExtArgs>
  }

  export type $GatePassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GatePass"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      forUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passNumber: string
      type: $Enums.GatePassType
      purpose: string | null
      visitorName: string | null
      visitorPhone: string | null
      visitorCompany: string | null
      vehicleNumber: string | null
      itemsCarried: string | null
      entryTime: Date | null
      exitTime: Date | null
      status: $Enums.GatePassStatus
      validUntil: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string
      createdById: string
      forUserId: string | null
    }, ExtArgs["result"]["gatePass"]>
    composites: {}
  }

  type GatePassGetPayload<S extends boolean | null | undefined | GatePassDefaultArgs> = $Result.GetResult<Prisma.$GatePassPayload, S>

  type GatePassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GatePassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GatePassCountAggregateInputType | true
    }

  export interface GatePassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GatePass'], meta: { name: 'GatePass' } }
    /**
     * Find zero or one GatePass that matches the filter.
     * @param {GatePassFindUniqueArgs} args - Arguments to find a GatePass
     * @example
     * // Get one GatePass
     * const gatePass = await prisma.gatePass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GatePassFindUniqueArgs>(args: SelectSubset<T, GatePassFindUniqueArgs<ExtArgs>>): Prisma__GatePassClient<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GatePass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GatePassFindUniqueOrThrowArgs} args - Arguments to find a GatePass
     * @example
     * // Get one GatePass
     * const gatePass = await prisma.gatePass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GatePassFindUniqueOrThrowArgs>(args: SelectSubset<T, GatePassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GatePassClient<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GatePass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatePassFindFirstArgs} args - Arguments to find a GatePass
     * @example
     * // Get one GatePass
     * const gatePass = await prisma.gatePass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GatePassFindFirstArgs>(args?: SelectSubset<T, GatePassFindFirstArgs<ExtArgs>>): Prisma__GatePassClient<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GatePass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatePassFindFirstOrThrowArgs} args - Arguments to find a GatePass
     * @example
     * // Get one GatePass
     * const gatePass = await prisma.gatePass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GatePassFindFirstOrThrowArgs>(args?: SelectSubset<T, GatePassFindFirstOrThrowArgs<ExtArgs>>): Prisma__GatePassClient<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GatePasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatePassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GatePasses
     * const gatePasses = await prisma.gatePass.findMany()
     * 
     * // Get first 10 GatePasses
     * const gatePasses = await prisma.gatePass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gatePassWithIdOnly = await prisma.gatePass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GatePassFindManyArgs>(args?: SelectSubset<T, GatePassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GatePass.
     * @param {GatePassCreateArgs} args - Arguments to create a GatePass.
     * @example
     * // Create one GatePass
     * const GatePass = await prisma.gatePass.create({
     *   data: {
     *     // ... data to create a GatePass
     *   }
     * })
     * 
     */
    create<T extends GatePassCreateArgs>(args: SelectSubset<T, GatePassCreateArgs<ExtArgs>>): Prisma__GatePassClient<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GatePasses.
     * @param {GatePassCreateManyArgs} args - Arguments to create many GatePasses.
     * @example
     * // Create many GatePasses
     * const gatePass = await prisma.gatePass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GatePassCreateManyArgs>(args?: SelectSubset<T, GatePassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GatePasses and returns the data saved in the database.
     * @param {GatePassCreateManyAndReturnArgs} args - Arguments to create many GatePasses.
     * @example
     * // Create many GatePasses
     * const gatePass = await prisma.gatePass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GatePasses and only return the `id`
     * const gatePassWithIdOnly = await prisma.gatePass.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GatePassCreateManyAndReturnArgs>(args?: SelectSubset<T, GatePassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GatePass.
     * @param {GatePassDeleteArgs} args - Arguments to delete one GatePass.
     * @example
     * // Delete one GatePass
     * const GatePass = await prisma.gatePass.delete({
     *   where: {
     *     // ... filter to delete one GatePass
     *   }
     * })
     * 
     */
    delete<T extends GatePassDeleteArgs>(args: SelectSubset<T, GatePassDeleteArgs<ExtArgs>>): Prisma__GatePassClient<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GatePass.
     * @param {GatePassUpdateArgs} args - Arguments to update one GatePass.
     * @example
     * // Update one GatePass
     * const gatePass = await prisma.gatePass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GatePassUpdateArgs>(args: SelectSubset<T, GatePassUpdateArgs<ExtArgs>>): Prisma__GatePassClient<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GatePasses.
     * @param {GatePassDeleteManyArgs} args - Arguments to filter GatePasses to delete.
     * @example
     * // Delete a few GatePasses
     * const { count } = await prisma.gatePass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GatePassDeleteManyArgs>(args?: SelectSubset<T, GatePassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GatePasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatePassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GatePasses
     * const gatePass = await prisma.gatePass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GatePassUpdateManyArgs>(args: SelectSubset<T, GatePassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GatePasses and returns the data updated in the database.
     * @param {GatePassUpdateManyAndReturnArgs} args - Arguments to update many GatePasses.
     * @example
     * // Update many GatePasses
     * const gatePass = await prisma.gatePass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GatePasses and only return the `id`
     * const gatePassWithIdOnly = await prisma.gatePass.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GatePassUpdateManyAndReturnArgs>(args: SelectSubset<T, GatePassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GatePass.
     * @param {GatePassUpsertArgs} args - Arguments to update or create a GatePass.
     * @example
     * // Update or create a GatePass
     * const gatePass = await prisma.gatePass.upsert({
     *   create: {
     *     // ... data to create a GatePass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GatePass we want to update
     *   }
     * })
     */
    upsert<T extends GatePassUpsertArgs>(args: SelectSubset<T, GatePassUpsertArgs<ExtArgs>>): Prisma__GatePassClient<$Result.GetResult<Prisma.$GatePassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GatePasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatePassCountArgs} args - Arguments to filter GatePasses to count.
     * @example
     * // Count the number of GatePasses
     * const count = await prisma.gatePass.count({
     *   where: {
     *     // ... the filter for the GatePasses we want to count
     *   }
     * })
    **/
    count<T extends GatePassCountArgs>(
      args?: Subset<T, GatePassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GatePassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GatePass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatePassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GatePassAggregateArgs>(args: Subset<T, GatePassAggregateArgs>): Prisma.PrismaPromise<GetGatePassAggregateType<T>>

    /**
     * Group by GatePass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatePassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GatePassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GatePassGroupByArgs['orderBy'] }
        : { orderBy?: GatePassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GatePassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGatePassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GatePass model
   */
  readonly fields: GatePassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GatePass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GatePassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    forUser<T extends GatePass$forUserArgs<ExtArgs> = {}>(args?: Subset<T, GatePass$forUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GatePass model
   */
  interface GatePassFieldRefs {
    readonly id: FieldRef<"GatePass", 'String'>
    readonly passNumber: FieldRef<"GatePass", 'String'>
    readonly type: FieldRef<"GatePass", 'GatePassType'>
    readonly purpose: FieldRef<"GatePass", 'String'>
    readonly visitorName: FieldRef<"GatePass", 'String'>
    readonly visitorPhone: FieldRef<"GatePass", 'String'>
    readonly visitorCompany: FieldRef<"GatePass", 'String'>
    readonly vehicleNumber: FieldRef<"GatePass", 'String'>
    readonly itemsCarried: FieldRef<"GatePass", 'String'>
    readonly entryTime: FieldRef<"GatePass", 'DateTime'>
    readonly exitTime: FieldRef<"GatePass", 'DateTime'>
    readonly status: FieldRef<"GatePass", 'GatePassStatus'>
    readonly validUntil: FieldRef<"GatePass", 'DateTime'>
    readonly notes: FieldRef<"GatePass", 'String'>
    readonly createdAt: FieldRef<"GatePass", 'DateTime'>
    readonly updatedAt: FieldRef<"GatePass", 'DateTime'>
    readonly companyId: FieldRef<"GatePass", 'String'>
    readonly createdById: FieldRef<"GatePass", 'String'>
    readonly forUserId: FieldRef<"GatePass", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GatePass findUnique
   */
  export type GatePassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    /**
     * Filter, which GatePass to fetch.
     */
    where: GatePassWhereUniqueInput
  }

  /**
   * GatePass findUniqueOrThrow
   */
  export type GatePassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    /**
     * Filter, which GatePass to fetch.
     */
    where: GatePassWhereUniqueInput
  }

  /**
   * GatePass findFirst
   */
  export type GatePassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    /**
     * Filter, which GatePass to fetch.
     */
    where?: GatePassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GatePasses to fetch.
     */
    orderBy?: GatePassOrderByWithRelationInput | GatePassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GatePasses.
     */
    cursor?: GatePassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GatePasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GatePasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GatePasses.
     */
    distinct?: GatePassScalarFieldEnum | GatePassScalarFieldEnum[]
  }

  /**
   * GatePass findFirstOrThrow
   */
  export type GatePassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    /**
     * Filter, which GatePass to fetch.
     */
    where?: GatePassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GatePasses to fetch.
     */
    orderBy?: GatePassOrderByWithRelationInput | GatePassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GatePasses.
     */
    cursor?: GatePassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GatePasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GatePasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GatePasses.
     */
    distinct?: GatePassScalarFieldEnum | GatePassScalarFieldEnum[]
  }

  /**
   * GatePass findMany
   */
  export type GatePassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    /**
     * Filter, which GatePasses to fetch.
     */
    where?: GatePassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GatePasses to fetch.
     */
    orderBy?: GatePassOrderByWithRelationInput | GatePassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GatePasses.
     */
    cursor?: GatePassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GatePasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GatePasses.
     */
    skip?: number
    distinct?: GatePassScalarFieldEnum | GatePassScalarFieldEnum[]
  }

  /**
   * GatePass create
   */
  export type GatePassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    /**
     * The data needed to create a GatePass.
     */
    data: XOR<GatePassCreateInput, GatePassUncheckedCreateInput>
  }

  /**
   * GatePass createMany
   */
  export type GatePassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GatePasses.
     */
    data: GatePassCreateManyInput | GatePassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GatePass createManyAndReturn
   */
  export type GatePassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * The data used to create many GatePasses.
     */
    data: GatePassCreateManyInput | GatePassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GatePass update
   */
  export type GatePassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    /**
     * The data needed to update a GatePass.
     */
    data: XOR<GatePassUpdateInput, GatePassUncheckedUpdateInput>
    /**
     * Choose, which GatePass to update.
     */
    where: GatePassWhereUniqueInput
  }

  /**
   * GatePass updateMany
   */
  export type GatePassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GatePasses.
     */
    data: XOR<GatePassUpdateManyMutationInput, GatePassUncheckedUpdateManyInput>
    /**
     * Filter which GatePasses to update
     */
    where?: GatePassWhereInput
    /**
     * Limit how many GatePasses to update.
     */
    limit?: number
  }

  /**
   * GatePass updateManyAndReturn
   */
  export type GatePassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * The data used to update GatePasses.
     */
    data: XOR<GatePassUpdateManyMutationInput, GatePassUncheckedUpdateManyInput>
    /**
     * Filter which GatePasses to update
     */
    where?: GatePassWhereInput
    /**
     * Limit how many GatePasses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GatePass upsert
   */
  export type GatePassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    /**
     * The filter to search for the GatePass to update in case it exists.
     */
    where: GatePassWhereUniqueInput
    /**
     * In case the GatePass found by the `where` argument doesn't exist, create a new GatePass with this data.
     */
    create: XOR<GatePassCreateInput, GatePassUncheckedCreateInput>
    /**
     * In case the GatePass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GatePassUpdateInput, GatePassUncheckedUpdateInput>
  }

  /**
   * GatePass delete
   */
  export type GatePassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
    /**
     * Filter which GatePass to delete.
     */
    where: GatePassWhereUniqueInput
  }

  /**
   * GatePass deleteMany
   */
  export type GatePassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GatePasses to delete
     */
    where?: GatePassWhereInput
    /**
     * Limit how many GatePasses to delete.
     */
    limit?: number
  }

  /**
   * GatePass.forUser
   */
  export type GatePass$forUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GatePass without action
   */
  export type GatePassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatePass
     */
    select?: GatePassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GatePass
     */
    omit?: GatePassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatePassInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    fileName: string | null
    fileUrl: string | null
    fileSize: number | null
    mimeType: string | null
    documentType: $Enums.DocumentType | null
    isConfidential: boolean | null
    expiryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    uploadedById: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    fileName: string | null
    fileUrl: string | null
    fileSize: number | null
    mimeType: string | null
    documentType: $Enums.DocumentType | null
    isConfidential: boolean | null
    expiryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    uploadedById: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    fileName: number
    fileUrl: number
    fileSize: number
    mimeType: number
    documentType: number
    isConfidential: number
    expiryDate: number
    tags: number
    createdAt: number
    updatedAt: number
    companyId: number
    uploadedById: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    documentType?: true
    isConfidential?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    uploadedById?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    documentType?: true
    isConfidential?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    uploadedById?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    documentType?: true
    isConfidential?: true
    expiryDate?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    uploadedById?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    title: string
    description: string | null
    fileName: string
    fileUrl: string
    fileSize: number | null
    mimeType: string | null
    documentType: $Enums.DocumentType
    isConfidential: boolean
    expiryDate: Date | null
    tags: string[]
    createdAt: Date
    updatedAt: Date
    companyId: string
    uploadedById: string
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    documentType?: boolean
    isConfidential?: boolean
    expiryDate?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    uploadedById?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    documentType?: boolean
    isConfidential?: boolean
    expiryDate?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    uploadedById?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    documentType?: boolean
    isConfidential?: boolean
    expiryDate?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    uploadedById?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    documentType?: boolean
    isConfidential?: boolean
    expiryDate?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    uploadedById?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "fileName" | "fileUrl" | "fileSize" | "mimeType" | "documentType" | "isConfidential" | "expiryDate" | "tags" | "createdAt" | "updatedAt" | "companyId" | "uploadedById", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      fileName: string
      fileUrl: string
      fileSize: number | null
      mimeType: string | null
      documentType: $Enums.DocumentType
      isConfidential: boolean
      expiryDate: Date | null
      tags: string[]
      createdAt: Date
      updatedAt: Date
      companyId: string
      uploadedById: string
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly description: FieldRef<"Document", 'String'>
    readonly fileName: FieldRef<"Document", 'String'>
    readonly fileUrl: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly documentType: FieldRef<"Document", 'DocumentType'>
    readonly isConfidential: FieldRef<"Document", 'Boolean'>
    readonly expiryDate: FieldRef<"Document", 'DateTime'>
    readonly tags: FieldRef<"Document", 'String[]'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
    readonly companyId: FieldRef<"Document", 'String'>
    readonly uploadedById: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceReview
   */

  export type AggregatePerformanceReview = {
    _count: PerformanceReviewCountAggregateOutputType | null
    _avg: PerformanceReviewAvgAggregateOutputType | null
    _sum: PerformanceReviewSumAggregateOutputType | null
    _min: PerformanceReviewMinAggregateOutputType | null
    _max: PerformanceReviewMaxAggregateOutputType | null
  }

  export type PerformanceReviewAvgAggregateOutputType = {
    overallRating: number | null
    goalsAchieved: number | null
    punctualityScore: number | null
    qualityScore: number | null
    communicationScore: number | null
    teamworkScore: number | null
  }

  export type PerformanceReviewSumAggregateOutputType = {
    overallRating: number | null
    goalsAchieved: number | null
    punctualityScore: number | null
    qualityScore: number | null
    communicationScore: number | null
    teamworkScore: number | null
  }

  export type PerformanceReviewMinAggregateOutputType = {
    id: string | null
    reviewPeriodStart: Date | null
    reviewPeriodEnd: Date | null
    overallRating: number | null
    goalsAchieved: number | null
    punctualityScore: number | null
    qualityScore: number | null
    communicationScore: number | null
    teamworkScore: number | null
    comments: string | null
    goals: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewForId: string | null
    reviewById: string | null
    companyId: string | null
  }

  export type PerformanceReviewMaxAggregateOutputType = {
    id: string | null
    reviewPeriodStart: Date | null
    reviewPeriodEnd: Date | null
    overallRating: number | null
    goalsAchieved: number | null
    punctualityScore: number | null
    qualityScore: number | null
    communicationScore: number | null
    teamworkScore: number | null
    comments: string | null
    goals: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewForId: string | null
    reviewById: string | null
    companyId: string | null
  }

  export type PerformanceReviewCountAggregateOutputType = {
    id: number
    reviewPeriodStart: number
    reviewPeriodEnd: number
    overallRating: number
    goalsAchieved: number
    punctualityScore: number
    qualityScore: number
    communicationScore: number
    teamworkScore: number
    comments: number
    goals: number
    createdAt: number
    updatedAt: number
    reviewForId: number
    reviewById: number
    companyId: number
    _all: number
  }


  export type PerformanceReviewAvgAggregateInputType = {
    overallRating?: true
    goalsAchieved?: true
    punctualityScore?: true
    qualityScore?: true
    communicationScore?: true
    teamworkScore?: true
  }

  export type PerformanceReviewSumAggregateInputType = {
    overallRating?: true
    goalsAchieved?: true
    punctualityScore?: true
    qualityScore?: true
    communicationScore?: true
    teamworkScore?: true
  }

  export type PerformanceReviewMinAggregateInputType = {
    id?: true
    reviewPeriodStart?: true
    reviewPeriodEnd?: true
    overallRating?: true
    goalsAchieved?: true
    punctualityScore?: true
    qualityScore?: true
    communicationScore?: true
    teamworkScore?: true
    comments?: true
    goals?: true
    createdAt?: true
    updatedAt?: true
    reviewForId?: true
    reviewById?: true
    companyId?: true
  }

  export type PerformanceReviewMaxAggregateInputType = {
    id?: true
    reviewPeriodStart?: true
    reviewPeriodEnd?: true
    overallRating?: true
    goalsAchieved?: true
    punctualityScore?: true
    qualityScore?: true
    communicationScore?: true
    teamworkScore?: true
    comments?: true
    goals?: true
    createdAt?: true
    updatedAt?: true
    reviewForId?: true
    reviewById?: true
    companyId?: true
  }

  export type PerformanceReviewCountAggregateInputType = {
    id?: true
    reviewPeriodStart?: true
    reviewPeriodEnd?: true
    overallRating?: true
    goalsAchieved?: true
    punctualityScore?: true
    qualityScore?: true
    communicationScore?: true
    teamworkScore?: true
    comments?: true
    goals?: true
    createdAt?: true
    updatedAt?: true
    reviewForId?: true
    reviewById?: true
    companyId?: true
    _all?: true
  }

  export type PerformanceReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceReview to aggregate.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceReviews
    **/
    _count?: true | PerformanceReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceReviewMaxAggregateInputType
  }

  export type GetPerformanceReviewAggregateType<T extends PerformanceReviewAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceReview[P]>
      : GetScalarType<T[P], AggregatePerformanceReview[P]>
  }




  export type PerformanceReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReviewWhereInput
    orderBy?: PerformanceReviewOrderByWithAggregationInput | PerformanceReviewOrderByWithAggregationInput[]
    by: PerformanceReviewScalarFieldEnum[] | PerformanceReviewScalarFieldEnum
    having?: PerformanceReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceReviewCountAggregateInputType | true
    _avg?: PerformanceReviewAvgAggregateInputType
    _sum?: PerformanceReviewSumAggregateInputType
    _min?: PerformanceReviewMinAggregateInputType
    _max?: PerformanceReviewMaxAggregateInputType
  }

  export type PerformanceReviewGroupByOutputType = {
    id: string
    reviewPeriodStart: Date
    reviewPeriodEnd: Date
    overallRating: number | null
    goalsAchieved: number | null
    punctualityScore: number | null
    qualityScore: number | null
    communicationScore: number | null
    teamworkScore: number | null
    comments: string | null
    goals: string | null
    createdAt: Date
    updatedAt: Date
    reviewForId: string
    reviewById: string
    companyId: string
    _count: PerformanceReviewCountAggregateOutputType | null
    _avg: PerformanceReviewAvgAggregateOutputType | null
    _sum: PerformanceReviewSumAggregateOutputType | null
    _min: PerformanceReviewMinAggregateOutputType | null
    _max: PerformanceReviewMaxAggregateOutputType | null
  }

  type GetPerformanceReviewGroupByPayload<T extends PerformanceReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceReviewGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceReviewGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewPeriodStart?: boolean
    reviewPeriodEnd?: boolean
    overallRating?: boolean
    goalsAchieved?: boolean
    punctualityScore?: boolean
    qualityScore?: boolean
    communicationScore?: boolean
    teamworkScore?: boolean
    comments?: boolean
    goals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewForId?: boolean
    reviewById?: boolean
    companyId?: boolean
    reviewBy?: boolean | UserDefaultArgs<ExtArgs>
    reviewFor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceReview"]>

  export type PerformanceReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewPeriodStart?: boolean
    reviewPeriodEnd?: boolean
    overallRating?: boolean
    goalsAchieved?: boolean
    punctualityScore?: boolean
    qualityScore?: boolean
    communicationScore?: boolean
    teamworkScore?: boolean
    comments?: boolean
    goals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewForId?: boolean
    reviewById?: boolean
    companyId?: boolean
    reviewBy?: boolean | UserDefaultArgs<ExtArgs>
    reviewFor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceReview"]>

  export type PerformanceReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewPeriodStart?: boolean
    reviewPeriodEnd?: boolean
    overallRating?: boolean
    goalsAchieved?: boolean
    punctualityScore?: boolean
    qualityScore?: boolean
    communicationScore?: boolean
    teamworkScore?: boolean
    comments?: boolean
    goals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewForId?: boolean
    reviewById?: boolean
    companyId?: boolean
    reviewBy?: boolean | UserDefaultArgs<ExtArgs>
    reviewFor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceReview"]>

  export type PerformanceReviewSelectScalar = {
    id?: boolean
    reviewPeriodStart?: boolean
    reviewPeriodEnd?: boolean
    overallRating?: boolean
    goalsAchieved?: boolean
    punctualityScore?: boolean
    qualityScore?: boolean
    communicationScore?: boolean
    teamworkScore?: boolean
    comments?: boolean
    goals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewForId?: boolean
    reviewById?: boolean
    companyId?: boolean
  }

  export type PerformanceReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewPeriodStart" | "reviewPeriodEnd" | "overallRating" | "goalsAchieved" | "punctualityScore" | "qualityScore" | "communicationScore" | "teamworkScore" | "comments" | "goals" | "createdAt" | "updatedAt" | "reviewForId" | "reviewById" | "companyId", ExtArgs["result"]["performanceReview"]>
  export type PerformanceReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewBy?: boolean | UserDefaultArgs<ExtArgs>
    reviewFor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PerformanceReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewBy?: boolean | UserDefaultArgs<ExtArgs>
    reviewFor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PerformanceReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewBy?: boolean | UserDefaultArgs<ExtArgs>
    reviewFor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PerformanceReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceReview"
    objects: {
      reviewBy: Prisma.$UserPayload<ExtArgs>
      reviewFor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewPeriodStart: Date
      reviewPeriodEnd: Date
      overallRating: number | null
      goalsAchieved: number | null
      punctualityScore: number | null
      qualityScore: number | null
      communicationScore: number | null
      teamworkScore: number | null
      comments: string | null
      goals: string | null
      createdAt: Date
      updatedAt: Date
      reviewForId: string
      reviewById: string
      companyId: string
    }, ExtArgs["result"]["performanceReview"]>
    composites: {}
  }

  type PerformanceReviewGetPayload<S extends boolean | null | undefined | PerformanceReviewDefaultArgs> = $Result.GetResult<Prisma.$PerformanceReviewPayload, S>

  type PerformanceReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceReviewCountAggregateInputType | true
    }

  export interface PerformanceReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceReview'], meta: { name: 'PerformanceReview' } }
    /**
     * Find zero or one PerformanceReview that matches the filter.
     * @param {PerformanceReviewFindUniqueArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceReviewFindUniqueArgs>(args: SelectSubset<T, PerformanceReviewFindUniqueArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceReviewFindUniqueOrThrowArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindFirstArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceReviewFindFirstArgs>(args?: SelectSubset<T, PerformanceReviewFindFirstArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindFirstOrThrowArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceReviews
     * const performanceReviews = await prisma.performanceReview.findMany()
     * 
     * // Get first 10 PerformanceReviews
     * const performanceReviews = await prisma.performanceReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceReviewWithIdOnly = await prisma.performanceReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceReviewFindManyArgs>(args?: SelectSubset<T, PerformanceReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceReview.
     * @param {PerformanceReviewCreateArgs} args - Arguments to create a PerformanceReview.
     * @example
     * // Create one PerformanceReview
     * const PerformanceReview = await prisma.performanceReview.create({
     *   data: {
     *     // ... data to create a PerformanceReview
     *   }
     * })
     * 
     */
    create<T extends PerformanceReviewCreateArgs>(args: SelectSubset<T, PerformanceReviewCreateArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceReviews.
     * @param {PerformanceReviewCreateManyArgs} args - Arguments to create many PerformanceReviews.
     * @example
     * // Create many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceReviewCreateManyArgs>(args?: SelectSubset<T, PerformanceReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceReviews and returns the data saved in the database.
     * @param {PerformanceReviewCreateManyAndReturnArgs} args - Arguments to create many PerformanceReviews.
     * @example
     * // Create many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceReviews and only return the `id`
     * const performanceReviewWithIdOnly = await prisma.performanceReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerformanceReview.
     * @param {PerformanceReviewDeleteArgs} args - Arguments to delete one PerformanceReview.
     * @example
     * // Delete one PerformanceReview
     * const PerformanceReview = await prisma.performanceReview.delete({
     *   where: {
     *     // ... filter to delete one PerformanceReview
     *   }
     * })
     * 
     */
    delete<T extends PerformanceReviewDeleteArgs>(args: SelectSubset<T, PerformanceReviewDeleteArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceReview.
     * @param {PerformanceReviewUpdateArgs} args - Arguments to update one PerformanceReview.
     * @example
     * // Update one PerformanceReview
     * const performanceReview = await prisma.performanceReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceReviewUpdateArgs>(args: SelectSubset<T, PerformanceReviewUpdateArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceReviews.
     * @param {PerformanceReviewDeleteManyArgs} args - Arguments to filter PerformanceReviews to delete.
     * @example
     * // Delete a few PerformanceReviews
     * const { count } = await prisma.performanceReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceReviewDeleteManyArgs>(args?: SelectSubset<T, PerformanceReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceReviewUpdateManyArgs>(args: SelectSubset<T, PerformanceReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceReviews and returns the data updated in the database.
     * @param {PerformanceReviewUpdateManyAndReturnArgs} args - Arguments to update many PerformanceReviews.
     * @example
     * // Update many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceReviews and only return the `id`
     * const performanceReviewWithIdOnly = await prisma.performanceReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerformanceReview.
     * @param {PerformanceReviewUpsertArgs} args - Arguments to update or create a PerformanceReview.
     * @example
     * // Update or create a PerformanceReview
     * const performanceReview = await prisma.performanceReview.upsert({
     *   create: {
     *     // ... data to create a PerformanceReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceReview we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceReviewUpsertArgs>(args: SelectSubset<T, PerformanceReviewUpsertArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewCountArgs} args - Arguments to filter PerformanceReviews to count.
     * @example
     * // Count the number of PerformanceReviews
     * const count = await prisma.performanceReview.count({
     *   where: {
     *     // ... the filter for the PerformanceReviews we want to count
     *   }
     * })
    **/
    count<T extends PerformanceReviewCountArgs>(
      args?: Subset<T, PerformanceReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceReviewAggregateArgs>(args: Subset<T, PerformanceReviewAggregateArgs>): Prisma.PrismaPromise<GetPerformanceReviewAggregateType<T>>

    /**
     * Group by PerformanceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceReviewGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceReview model
   */
  readonly fields: PerformanceReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviewBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewFor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceReview model
   */
  interface PerformanceReviewFieldRefs {
    readonly id: FieldRef<"PerformanceReview", 'String'>
    readonly reviewPeriodStart: FieldRef<"PerformanceReview", 'DateTime'>
    readonly reviewPeriodEnd: FieldRef<"PerformanceReview", 'DateTime'>
    readonly overallRating: FieldRef<"PerformanceReview", 'Float'>
    readonly goalsAchieved: FieldRef<"PerformanceReview", 'Int'>
    readonly punctualityScore: FieldRef<"PerformanceReview", 'Float'>
    readonly qualityScore: FieldRef<"PerformanceReview", 'Float'>
    readonly communicationScore: FieldRef<"PerformanceReview", 'Float'>
    readonly teamworkScore: FieldRef<"PerformanceReview", 'Float'>
    readonly comments: FieldRef<"PerformanceReview", 'String'>
    readonly goals: FieldRef<"PerformanceReview", 'String'>
    readonly createdAt: FieldRef<"PerformanceReview", 'DateTime'>
    readonly updatedAt: FieldRef<"PerformanceReview", 'DateTime'>
    readonly reviewForId: FieldRef<"PerformanceReview", 'String'>
    readonly reviewById: FieldRef<"PerformanceReview", 'String'>
    readonly companyId: FieldRef<"PerformanceReview", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceReview findUnique
   */
  export type PerformanceReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview findUniqueOrThrow
   */
  export type PerformanceReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview findFirst
   */
  export type PerformanceReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceReviews.
     */
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview findFirstOrThrow
   */
  export type PerformanceReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceReviews.
     */
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview findMany
   */
  export type PerformanceReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReviews to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview create
   */
  export type PerformanceReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceReview.
     */
    data: XOR<PerformanceReviewCreateInput, PerformanceReviewUncheckedCreateInput>
  }

  /**
   * PerformanceReview createMany
   */
  export type PerformanceReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceReviews.
     */
    data: PerformanceReviewCreateManyInput | PerformanceReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceReview createManyAndReturn
   */
  export type PerformanceReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceReviews.
     */
    data: PerformanceReviewCreateManyInput | PerformanceReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceReview update
   */
  export type PerformanceReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceReview.
     */
    data: XOR<PerformanceReviewUpdateInput, PerformanceReviewUncheckedUpdateInput>
    /**
     * Choose, which PerformanceReview to update.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview updateMany
   */
  export type PerformanceReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceReviews.
     */
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceReviews to update
     */
    where?: PerformanceReviewWhereInput
    /**
     * Limit how many PerformanceReviews to update.
     */
    limit?: number
  }

  /**
   * PerformanceReview updateManyAndReturn
   */
  export type PerformanceReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceReviews.
     */
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceReviews to update
     */
    where?: PerformanceReviewWhereInput
    /**
     * Limit how many PerformanceReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceReview upsert
   */
  export type PerformanceReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceReview to update in case it exists.
     */
    where: PerformanceReviewWhereUniqueInput
    /**
     * In case the PerformanceReview found by the `where` argument doesn't exist, create a new PerformanceReview with this data.
     */
    create: XOR<PerformanceReviewCreateInput, PerformanceReviewUncheckedCreateInput>
    /**
     * In case the PerformanceReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceReviewUpdateInput, PerformanceReviewUncheckedUpdateInput>
  }

  /**
   * PerformanceReview delete
   */
  export type PerformanceReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter which PerformanceReview to delete.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview deleteMany
   */
  export type PerformanceReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceReviews to delete
     */
    where?: PerformanceReviewWhereInput
    /**
     * Limit how many PerformanceReviews to delete.
     */
    limit?: number
  }

  /**
   * PerformanceReview without action
   */
  export type PerformanceReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: $Enums.AuditLogAction | null
    tableName: string | null
    recordId: string | null
    ipAddress: string | null
    userAgent: string | null
    description: string | null
    createdAt: Date | null
    companyId: string | null
    userId: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: $Enums.AuditLogAction | null
    tableName: string | null
    recordId: string | null
    ipAddress: string | null
    userAgent: string | null
    description: string | null
    createdAt: Date | null
    companyId: string | null
    userId: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    tableName: number
    recordId: number
    oldData: number
    newData: number
    ipAddress: number
    userAgent: number
    description: number
    createdAt: number
    companyId: number
    userId: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    tableName?: true
    recordId?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    createdAt?: true
    companyId?: true
    userId?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    tableName?: true
    recordId?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    createdAt?: true
    companyId?: true
    userId?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    tableName?: true
    recordId?: true
    oldData?: true
    newData?: true
    ipAddress?: true
    userAgent?: true
    description?: true
    createdAt?: true
    companyId?: true
    userId?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: $Enums.AuditLogAction
    tableName: string
    recordId: string | null
    oldData: JsonValue | null
    newData: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    description: string | null
    createdAt: Date
    companyId: string
    userId: string
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    createdAt?: boolean
    companyId?: boolean
    userId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    createdAt?: boolean
    companyId?: boolean
    userId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    createdAt?: boolean
    companyId?: boolean
    userId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    description?: boolean
    createdAt?: boolean
    companyId?: boolean
    userId?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "tableName" | "recordId" | "oldData" | "newData" | "ipAddress" | "userAgent" | "description" | "createdAt" | "companyId" | "userId", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: $Enums.AuditLogAction
      tableName: string
      recordId: string | null
      oldData: Prisma.JsonValue | null
      newData: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      description: string | null
      createdAt: Date
      companyId: string
      userId: string
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'AuditLogAction'>
    readonly tableName: FieldRef<"AuditLog", 'String'>
    readonly recordId: FieldRef<"AuditLog", 'String'>
    readonly oldData: FieldRef<"AuditLog", 'Json'>
    readonly newData: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly description: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
    readonly companyId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model CreditsRecharge
   */

  export type AggregateCreditsRecharge = {
    _count: CreditsRechargeCountAggregateOutputType | null
    _avg: CreditsRechargeAvgAggregateOutputType | null
    _sum: CreditsRechargeSumAggregateOutputType | null
    _min: CreditsRechargeMinAggregateOutputType | null
    _max: CreditsRechargeMaxAggregateOutputType | null
  }

  export type CreditsRechargeAvgAggregateOutputType = {
    credits: number | null
    amountPaid: number | null
  }

  export type CreditsRechargeSumAggregateOutputType = {
    credits: number | null
    amountPaid: number | null
  }

  export type CreditsRechargeMinAggregateOutputType = {
    id: string | null
    credits: number | null
    amountPaid: number | null
    transactionId: string | null
    paymentMethod: string | null
    paymentStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    purchasedById: string | null
  }

  export type CreditsRechargeMaxAggregateOutputType = {
    id: string | null
    credits: number | null
    amountPaid: number | null
    transactionId: string | null
    paymentMethod: string | null
    paymentStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    purchasedById: string | null
  }

  export type CreditsRechargeCountAggregateOutputType = {
    id: number
    credits: number
    amountPaid: number
    transactionId: number
    paymentMethod: number
    paymentStatus: number
    createdAt: number
    updatedAt: number
    companyId: number
    purchasedById: number
    _all: number
  }


  export type CreditsRechargeAvgAggregateInputType = {
    credits?: true
    amountPaid?: true
  }

  export type CreditsRechargeSumAggregateInputType = {
    credits?: true
    amountPaid?: true
  }

  export type CreditsRechargeMinAggregateInputType = {
    id?: true
    credits?: true
    amountPaid?: true
    transactionId?: true
    paymentMethod?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    purchasedById?: true
  }

  export type CreditsRechargeMaxAggregateInputType = {
    id?: true
    credits?: true
    amountPaid?: true
    transactionId?: true
    paymentMethod?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    purchasedById?: true
  }

  export type CreditsRechargeCountAggregateInputType = {
    id?: true
    credits?: true
    amountPaid?: true
    transactionId?: true
    paymentMethod?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    purchasedById?: true
    _all?: true
  }

  export type CreditsRechargeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditsRecharge to aggregate.
     */
    where?: CreditsRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditsRecharges to fetch.
     */
    orderBy?: CreditsRechargeOrderByWithRelationInput | CreditsRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditsRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditsRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditsRecharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditsRecharges
    **/
    _count?: true | CreditsRechargeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditsRechargeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditsRechargeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditsRechargeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditsRechargeMaxAggregateInputType
  }

  export type GetCreditsRechargeAggregateType<T extends CreditsRechargeAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditsRecharge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditsRecharge[P]>
      : GetScalarType<T[P], AggregateCreditsRecharge[P]>
  }




  export type CreditsRechargeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditsRechargeWhereInput
    orderBy?: CreditsRechargeOrderByWithAggregationInput | CreditsRechargeOrderByWithAggregationInput[]
    by: CreditsRechargeScalarFieldEnum[] | CreditsRechargeScalarFieldEnum
    having?: CreditsRechargeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditsRechargeCountAggregateInputType | true
    _avg?: CreditsRechargeAvgAggregateInputType
    _sum?: CreditsRechargeSumAggregateInputType
    _min?: CreditsRechargeMinAggregateInputType
    _max?: CreditsRechargeMaxAggregateInputType
  }

  export type CreditsRechargeGroupByOutputType = {
    id: string
    credits: number
    amountPaid: number
    transactionId: string | null
    paymentMethod: string | null
    paymentStatus: string
    createdAt: Date
    updatedAt: Date
    companyId: string
    purchasedById: string
    _count: CreditsRechargeCountAggregateOutputType | null
    _avg: CreditsRechargeAvgAggregateOutputType | null
    _sum: CreditsRechargeSumAggregateOutputType | null
    _min: CreditsRechargeMinAggregateOutputType | null
    _max: CreditsRechargeMaxAggregateOutputType | null
  }

  type GetCreditsRechargeGroupByPayload<T extends CreditsRechargeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditsRechargeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditsRechargeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditsRechargeGroupByOutputType[P]>
            : GetScalarType<T[P], CreditsRechargeGroupByOutputType[P]>
        }
      >
    >


  export type CreditsRechargeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    credits?: boolean
    amountPaid?: boolean
    transactionId?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    purchasedById?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchasedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditsRecharge"]>

  export type CreditsRechargeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    credits?: boolean
    amountPaid?: boolean
    transactionId?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    purchasedById?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchasedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditsRecharge"]>

  export type CreditsRechargeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    credits?: boolean
    amountPaid?: boolean
    transactionId?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    purchasedById?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchasedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditsRecharge"]>

  export type CreditsRechargeSelectScalar = {
    id?: boolean
    credits?: boolean
    amountPaid?: boolean
    transactionId?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    purchasedById?: boolean
  }

  export type CreditsRechargeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "credits" | "amountPaid" | "transactionId" | "paymentMethod" | "paymentStatus" | "createdAt" | "updatedAt" | "companyId" | "purchasedById", ExtArgs["result"]["creditsRecharge"]>
  export type CreditsRechargeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchasedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CreditsRechargeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchasedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CreditsRechargeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchasedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CreditsRechargePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditsRecharge"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      purchasedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      credits: number
      amountPaid: number
      transactionId: string | null
      paymentMethod: string | null
      paymentStatus: string
      createdAt: Date
      updatedAt: Date
      companyId: string
      purchasedById: string
    }, ExtArgs["result"]["creditsRecharge"]>
    composites: {}
  }

  type CreditsRechargeGetPayload<S extends boolean | null | undefined | CreditsRechargeDefaultArgs> = $Result.GetResult<Prisma.$CreditsRechargePayload, S>

  type CreditsRechargeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditsRechargeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditsRechargeCountAggregateInputType | true
    }

  export interface CreditsRechargeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditsRecharge'], meta: { name: 'CreditsRecharge' } }
    /**
     * Find zero or one CreditsRecharge that matches the filter.
     * @param {CreditsRechargeFindUniqueArgs} args - Arguments to find a CreditsRecharge
     * @example
     * // Get one CreditsRecharge
     * const creditsRecharge = await prisma.creditsRecharge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditsRechargeFindUniqueArgs>(args: SelectSubset<T, CreditsRechargeFindUniqueArgs<ExtArgs>>): Prisma__CreditsRechargeClient<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditsRecharge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditsRechargeFindUniqueOrThrowArgs} args - Arguments to find a CreditsRecharge
     * @example
     * // Get one CreditsRecharge
     * const creditsRecharge = await prisma.creditsRecharge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditsRechargeFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditsRechargeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditsRechargeClient<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditsRecharge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsRechargeFindFirstArgs} args - Arguments to find a CreditsRecharge
     * @example
     * // Get one CreditsRecharge
     * const creditsRecharge = await prisma.creditsRecharge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditsRechargeFindFirstArgs>(args?: SelectSubset<T, CreditsRechargeFindFirstArgs<ExtArgs>>): Prisma__CreditsRechargeClient<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditsRecharge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsRechargeFindFirstOrThrowArgs} args - Arguments to find a CreditsRecharge
     * @example
     * // Get one CreditsRecharge
     * const creditsRecharge = await prisma.creditsRecharge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditsRechargeFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditsRechargeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditsRechargeClient<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditsRecharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsRechargeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditsRecharges
     * const creditsRecharges = await prisma.creditsRecharge.findMany()
     * 
     * // Get first 10 CreditsRecharges
     * const creditsRecharges = await prisma.creditsRecharge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditsRechargeWithIdOnly = await prisma.creditsRecharge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditsRechargeFindManyArgs>(args?: SelectSubset<T, CreditsRechargeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditsRecharge.
     * @param {CreditsRechargeCreateArgs} args - Arguments to create a CreditsRecharge.
     * @example
     * // Create one CreditsRecharge
     * const CreditsRecharge = await prisma.creditsRecharge.create({
     *   data: {
     *     // ... data to create a CreditsRecharge
     *   }
     * })
     * 
     */
    create<T extends CreditsRechargeCreateArgs>(args: SelectSubset<T, CreditsRechargeCreateArgs<ExtArgs>>): Prisma__CreditsRechargeClient<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditsRecharges.
     * @param {CreditsRechargeCreateManyArgs} args - Arguments to create many CreditsRecharges.
     * @example
     * // Create many CreditsRecharges
     * const creditsRecharge = await prisma.creditsRecharge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditsRechargeCreateManyArgs>(args?: SelectSubset<T, CreditsRechargeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditsRecharges and returns the data saved in the database.
     * @param {CreditsRechargeCreateManyAndReturnArgs} args - Arguments to create many CreditsRecharges.
     * @example
     * // Create many CreditsRecharges
     * const creditsRecharge = await prisma.creditsRecharge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditsRecharges and only return the `id`
     * const creditsRechargeWithIdOnly = await prisma.creditsRecharge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditsRechargeCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditsRechargeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditsRecharge.
     * @param {CreditsRechargeDeleteArgs} args - Arguments to delete one CreditsRecharge.
     * @example
     * // Delete one CreditsRecharge
     * const CreditsRecharge = await prisma.creditsRecharge.delete({
     *   where: {
     *     // ... filter to delete one CreditsRecharge
     *   }
     * })
     * 
     */
    delete<T extends CreditsRechargeDeleteArgs>(args: SelectSubset<T, CreditsRechargeDeleteArgs<ExtArgs>>): Prisma__CreditsRechargeClient<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditsRecharge.
     * @param {CreditsRechargeUpdateArgs} args - Arguments to update one CreditsRecharge.
     * @example
     * // Update one CreditsRecharge
     * const creditsRecharge = await prisma.creditsRecharge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditsRechargeUpdateArgs>(args: SelectSubset<T, CreditsRechargeUpdateArgs<ExtArgs>>): Prisma__CreditsRechargeClient<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditsRecharges.
     * @param {CreditsRechargeDeleteManyArgs} args - Arguments to filter CreditsRecharges to delete.
     * @example
     * // Delete a few CreditsRecharges
     * const { count } = await prisma.creditsRecharge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditsRechargeDeleteManyArgs>(args?: SelectSubset<T, CreditsRechargeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditsRecharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsRechargeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditsRecharges
     * const creditsRecharge = await prisma.creditsRecharge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditsRechargeUpdateManyArgs>(args: SelectSubset<T, CreditsRechargeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditsRecharges and returns the data updated in the database.
     * @param {CreditsRechargeUpdateManyAndReturnArgs} args - Arguments to update many CreditsRecharges.
     * @example
     * // Update many CreditsRecharges
     * const creditsRecharge = await prisma.creditsRecharge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditsRecharges and only return the `id`
     * const creditsRechargeWithIdOnly = await prisma.creditsRecharge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditsRechargeUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditsRechargeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditsRecharge.
     * @param {CreditsRechargeUpsertArgs} args - Arguments to update or create a CreditsRecharge.
     * @example
     * // Update or create a CreditsRecharge
     * const creditsRecharge = await prisma.creditsRecharge.upsert({
     *   create: {
     *     // ... data to create a CreditsRecharge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditsRecharge we want to update
     *   }
     * })
     */
    upsert<T extends CreditsRechargeUpsertArgs>(args: SelectSubset<T, CreditsRechargeUpsertArgs<ExtArgs>>): Prisma__CreditsRechargeClient<$Result.GetResult<Prisma.$CreditsRechargePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditsRecharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsRechargeCountArgs} args - Arguments to filter CreditsRecharges to count.
     * @example
     * // Count the number of CreditsRecharges
     * const count = await prisma.creditsRecharge.count({
     *   where: {
     *     // ... the filter for the CreditsRecharges we want to count
     *   }
     * })
    **/
    count<T extends CreditsRechargeCountArgs>(
      args?: Subset<T, CreditsRechargeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditsRechargeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditsRecharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsRechargeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditsRechargeAggregateArgs>(args: Subset<T, CreditsRechargeAggregateArgs>): Prisma.PrismaPromise<GetCreditsRechargeAggregateType<T>>

    /**
     * Group by CreditsRecharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsRechargeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditsRechargeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditsRechargeGroupByArgs['orderBy'] }
        : { orderBy?: CreditsRechargeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditsRechargeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditsRechargeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditsRecharge model
   */
  readonly fields: CreditsRechargeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditsRecharge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditsRechargeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchasedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditsRecharge model
   */
  interface CreditsRechargeFieldRefs {
    readonly id: FieldRef<"CreditsRecharge", 'String'>
    readonly credits: FieldRef<"CreditsRecharge", 'Float'>
    readonly amountPaid: FieldRef<"CreditsRecharge", 'Float'>
    readonly transactionId: FieldRef<"CreditsRecharge", 'String'>
    readonly paymentMethod: FieldRef<"CreditsRecharge", 'String'>
    readonly paymentStatus: FieldRef<"CreditsRecharge", 'String'>
    readonly createdAt: FieldRef<"CreditsRecharge", 'DateTime'>
    readonly updatedAt: FieldRef<"CreditsRecharge", 'DateTime'>
    readonly companyId: FieldRef<"CreditsRecharge", 'String'>
    readonly purchasedById: FieldRef<"CreditsRecharge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreditsRecharge findUnique
   */
  export type CreditsRechargeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
    /**
     * Filter, which CreditsRecharge to fetch.
     */
    where: CreditsRechargeWhereUniqueInput
  }

  /**
   * CreditsRecharge findUniqueOrThrow
   */
  export type CreditsRechargeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
    /**
     * Filter, which CreditsRecharge to fetch.
     */
    where: CreditsRechargeWhereUniqueInput
  }

  /**
   * CreditsRecharge findFirst
   */
  export type CreditsRechargeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
    /**
     * Filter, which CreditsRecharge to fetch.
     */
    where?: CreditsRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditsRecharges to fetch.
     */
    orderBy?: CreditsRechargeOrderByWithRelationInput | CreditsRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditsRecharges.
     */
    cursor?: CreditsRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditsRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditsRecharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditsRecharges.
     */
    distinct?: CreditsRechargeScalarFieldEnum | CreditsRechargeScalarFieldEnum[]
  }

  /**
   * CreditsRecharge findFirstOrThrow
   */
  export type CreditsRechargeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
    /**
     * Filter, which CreditsRecharge to fetch.
     */
    where?: CreditsRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditsRecharges to fetch.
     */
    orderBy?: CreditsRechargeOrderByWithRelationInput | CreditsRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditsRecharges.
     */
    cursor?: CreditsRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditsRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditsRecharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditsRecharges.
     */
    distinct?: CreditsRechargeScalarFieldEnum | CreditsRechargeScalarFieldEnum[]
  }

  /**
   * CreditsRecharge findMany
   */
  export type CreditsRechargeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
    /**
     * Filter, which CreditsRecharges to fetch.
     */
    where?: CreditsRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditsRecharges to fetch.
     */
    orderBy?: CreditsRechargeOrderByWithRelationInput | CreditsRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditsRecharges.
     */
    cursor?: CreditsRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditsRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditsRecharges.
     */
    skip?: number
    distinct?: CreditsRechargeScalarFieldEnum | CreditsRechargeScalarFieldEnum[]
  }

  /**
   * CreditsRecharge create
   */
  export type CreditsRechargeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditsRecharge.
     */
    data: XOR<CreditsRechargeCreateInput, CreditsRechargeUncheckedCreateInput>
  }

  /**
   * CreditsRecharge createMany
   */
  export type CreditsRechargeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditsRecharges.
     */
    data: CreditsRechargeCreateManyInput | CreditsRechargeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditsRecharge createManyAndReturn
   */
  export type CreditsRechargeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * The data used to create many CreditsRecharges.
     */
    data: CreditsRechargeCreateManyInput | CreditsRechargeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditsRecharge update
   */
  export type CreditsRechargeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditsRecharge.
     */
    data: XOR<CreditsRechargeUpdateInput, CreditsRechargeUncheckedUpdateInput>
    /**
     * Choose, which CreditsRecharge to update.
     */
    where: CreditsRechargeWhereUniqueInput
  }

  /**
   * CreditsRecharge updateMany
   */
  export type CreditsRechargeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditsRecharges.
     */
    data: XOR<CreditsRechargeUpdateManyMutationInput, CreditsRechargeUncheckedUpdateManyInput>
    /**
     * Filter which CreditsRecharges to update
     */
    where?: CreditsRechargeWhereInput
    /**
     * Limit how many CreditsRecharges to update.
     */
    limit?: number
  }

  /**
   * CreditsRecharge updateManyAndReturn
   */
  export type CreditsRechargeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * The data used to update CreditsRecharges.
     */
    data: XOR<CreditsRechargeUpdateManyMutationInput, CreditsRechargeUncheckedUpdateManyInput>
    /**
     * Filter which CreditsRecharges to update
     */
    where?: CreditsRechargeWhereInput
    /**
     * Limit how many CreditsRecharges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditsRecharge upsert
   */
  export type CreditsRechargeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditsRecharge to update in case it exists.
     */
    where: CreditsRechargeWhereUniqueInput
    /**
     * In case the CreditsRecharge found by the `where` argument doesn't exist, create a new CreditsRecharge with this data.
     */
    create: XOR<CreditsRechargeCreateInput, CreditsRechargeUncheckedCreateInput>
    /**
     * In case the CreditsRecharge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditsRechargeUpdateInput, CreditsRechargeUncheckedUpdateInput>
  }

  /**
   * CreditsRecharge delete
   */
  export type CreditsRechargeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
    /**
     * Filter which CreditsRecharge to delete.
     */
    where: CreditsRechargeWhereUniqueInput
  }

  /**
   * CreditsRecharge deleteMany
   */
  export type CreditsRechargeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditsRecharges to delete
     */
    where?: CreditsRechargeWhereInput
    /**
     * Limit how many CreditsRecharges to delete.
     */
    limit?: number
  }

  /**
   * CreditsRecharge without action
   */
  export type CreditsRechargeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditsRecharge
     */
    select?: CreditsRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditsRecharge
     */
    omit?: CreditsRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditsRechargeInclude<ExtArgs> | null
  }


  /**
   * Model TransactionHistory
   */

  export type AggregateTransactionHistory = {
    _count: TransactionHistoryCountAggregateOutputType | null
    _avg: TransactionHistoryAvgAggregateOutputType | null
    _sum: TransactionHistorySumAggregateOutputType | null
    _min: TransactionHistoryMinAggregateOutputType | null
    _max: TransactionHistoryMaxAggregateOutputType | null
  }

  export type TransactionHistoryAvgAggregateOutputType = {
    creditsUsed: number | null
    numberOfDaysUsed: number | null
  }

  export type TransactionHistorySumAggregateOutputType = {
    creditsUsed: number | null
    numberOfDaysUsed: number | null
  }

  export type TransactionHistoryMinAggregateOutputType = {
    id: string | null
    creditsUsed: number | null
    description: string | null
    createdAt: Date | null
    companyId: string | null
    serviceId: string | null
    numberOfDaysUsed: number | null
    enabledById: string | null
  }

  export type TransactionHistoryMaxAggregateOutputType = {
    id: string | null
    creditsUsed: number | null
    description: string | null
    createdAt: Date | null
    companyId: string | null
    serviceId: string | null
    numberOfDaysUsed: number | null
    enabledById: string | null
  }

  export type TransactionHistoryCountAggregateOutputType = {
    id: number
    creditsUsed: number
    description: number
    createdAt: number
    companyId: number
    serviceId: number
    numberOfDaysUsed: number
    enabledById: number
    _all: number
  }


  export type TransactionHistoryAvgAggregateInputType = {
    creditsUsed?: true
    numberOfDaysUsed?: true
  }

  export type TransactionHistorySumAggregateInputType = {
    creditsUsed?: true
    numberOfDaysUsed?: true
  }

  export type TransactionHistoryMinAggregateInputType = {
    id?: true
    creditsUsed?: true
    description?: true
    createdAt?: true
    companyId?: true
    serviceId?: true
    numberOfDaysUsed?: true
    enabledById?: true
  }

  export type TransactionHistoryMaxAggregateInputType = {
    id?: true
    creditsUsed?: true
    description?: true
    createdAt?: true
    companyId?: true
    serviceId?: true
    numberOfDaysUsed?: true
    enabledById?: true
  }

  export type TransactionHistoryCountAggregateInputType = {
    id?: true
    creditsUsed?: true
    description?: true
    createdAt?: true
    companyId?: true
    serviceId?: true
    numberOfDaysUsed?: true
    enabledById?: true
    _all?: true
  }

  export type TransactionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionHistory to aggregate.
     */
    where?: TransactionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionHistories to fetch.
     */
    orderBy?: TransactionHistoryOrderByWithRelationInput | TransactionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionHistories
    **/
    _count?: true | TransactionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionHistoryMaxAggregateInputType
  }

  export type GetTransactionHistoryAggregateType<T extends TransactionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionHistory[P]>
      : GetScalarType<T[P], AggregateTransactionHistory[P]>
  }




  export type TransactionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionHistoryWhereInput
    orderBy?: TransactionHistoryOrderByWithAggregationInput | TransactionHistoryOrderByWithAggregationInput[]
    by: TransactionHistoryScalarFieldEnum[] | TransactionHistoryScalarFieldEnum
    having?: TransactionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionHistoryCountAggregateInputType | true
    _avg?: TransactionHistoryAvgAggregateInputType
    _sum?: TransactionHistorySumAggregateInputType
    _min?: TransactionHistoryMinAggregateInputType
    _max?: TransactionHistoryMaxAggregateInputType
  }

  export type TransactionHistoryGroupByOutputType = {
    id: string
    creditsUsed: number
    description: string | null
    createdAt: Date
    companyId: string
    serviceId: string | null
    numberOfDaysUsed: number | null
    enabledById: string | null
    _count: TransactionHistoryCountAggregateOutputType | null
    _avg: TransactionHistoryAvgAggregateOutputType | null
    _sum: TransactionHistorySumAggregateOutputType | null
    _min: TransactionHistoryMinAggregateOutputType | null
    _max: TransactionHistoryMaxAggregateOutputType | null
  }

  type GetTransactionHistoryGroupByPayload<T extends TransactionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type TransactionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditsUsed?: boolean
    description?: boolean
    createdAt?: boolean
    companyId?: boolean
    serviceId?: boolean
    numberOfDaysUsed?: boolean
    enabledById?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | TransactionHistory$serviceArgs<ExtArgs>
    enabledBy?: boolean | TransactionHistory$enabledByArgs<ExtArgs>
  }, ExtArgs["result"]["transactionHistory"]>

  export type TransactionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditsUsed?: boolean
    description?: boolean
    createdAt?: boolean
    companyId?: boolean
    serviceId?: boolean
    numberOfDaysUsed?: boolean
    enabledById?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | TransactionHistory$serviceArgs<ExtArgs>
    enabledBy?: boolean | TransactionHistory$enabledByArgs<ExtArgs>
  }, ExtArgs["result"]["transactionHistory"]>

  export type TransactionHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditsUsed?: boolean
    description?: boolean
    createdAt?: boolean
    companyId?: boolean
    serviceId?: boolean
    numberOfDaysUsed?: boolean
    enabledById?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | TransactionHistory$serviceArgs<ExtArgs>
    enabledBy?: boolean | TransactionHistory$enabledByArgs<ExtArgs>
  }, ExtArgs["result"]["transactionHistory"]>

  export type TransactionHistorySelectScalar = {
    id?: boolean
    creditsUsed?: boolean
    description?: boolean
    createdAt?: boolean
    companyId?: boolean
    serviceId?: boolean
    numberOfDaysUsed?: boolean
    enabledById?: boolean
  }

  export type TransactionHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditsUsed" | "description" | "createdAt" | "companyId" | "serviceId" | "numberOfDaysUsed" | "enabledById", ExtArgs["result"]["transactionHistory"]>
  export type TransactionHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | TransactionHistory$serviceArgs<ExtArgs>
    enabledBy?: boolean | TransactionHistory$enabledByArgs<ExtArgs>
  }
  export type TransactionHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | TransactionHistory$serviceArgs<ExtArgs>
    enabledBy?: boolean | TransactionHistory$enabledByArgs<ExtArgs>
  }
  export type TransactionHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | TransactionHistory$serviceArgs<ExtArgs>
    enabledBy?: boolean | TransactionHistory$enabledByArgs<ExtArgs>
  }

  export type $TransactionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionHistory"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
      enabledBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditsUsed: number
      description: string | null
      createdAt: Date
      companyId: string
      serviceId: string | null
      numberOfDaysUsed: number | null
      enabledById: string | null
    }, ExtArgs["result"]["transactionHistory"]>
    composites: {}
  }

  type TransactionHistoryGetPayload<S extends boolean | null | undefined | TransactionHistoryDefaultArgs> = $Result.GetResult<Prisma.$TransactionHistoryPayload, S>

  type TransactionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionHistoryCountAggregateInputType | true
    }

  export interface TransactionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionHistory'], meta: { name: 'TransactionHistory' } }
    /**
     * Find zero or one TransactionHistory that matches the filter.
     * @param {TransactionHistoryFindUniqueArgs} args - Arguments to find a TransactionHistory
     * @example
     * // Get one TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionHistoryFindUniqueArgs>(args: SelectSubset<T, TransactionHistoryFindUniqueArgs<ExtArgs>>): Prisma__TransactionHistoryClient<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionHistoryFindUniqueOrThrowArgs} args - Arguments to find a TransactionHistory
     * @example
     * // Get one TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionHistoryClient<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryFindFirstArgs} args - Arguments to find a TransactionHistory
     * @example
     * // Get one TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionHistoryFindFirstArgs>(args?: SelectSubset<T, TransactionHistoryFindFirstArgs<ExtArgs>>): Prisma__TransactionHistoryClient<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryFindFirstOrThrowArgs} args - Arguments to find a TransactionHistory
     * @example
     * // Get one TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionHistoryClient<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionHistories
     * const transactionHistories = await prisma.transactionHistory.findMany()
     * 
     * // Get first 10 TransactionHistories
     * const transactionHistories = await prisma.transactionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionHistoryWithIdOnly = await prisma.transactionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionHistoryFindManyArgs>(args?: SelectSubset<T, TransactionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionHistory.
     * @param {TransactionHistoryCreateArgs} args - Arguments to create a TransactionHistory.
     * @example
     * // Create one TransactionHistory
     * const TransactionHistory = await prisma.transactionHistory.create({
     *   data: {
     *     // ... data to create a TransactionHistory
     *   }
     * })
     * 
     */
    create<T extends TransactionHistoryCreateArgs>(args: SelectSubset<T, TransactionHistoryCreateArgs<ExtArgs>>): Prisma__TransactionHistoryClient<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionHistories.
     * @param {TransactionHistoryCreateManyArgs} args - Arguments to create many TransactionHistories.
     * @example
     * // Create many TransactionHistories
     * const transactionHistory = await prisma.transactionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionHistoryCreateManyArgs>(args?: SelectSubset<T, TransactionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionHistories and returns the data saved in the database.
     * @param {TransactionHistoryCreateManyAndReturnArgs} args - Arguments to create many TransactionHistories.
     * @example
     * // Create many TransactionHistories
     * const transactionHistory = await prisma.transactionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionHistories and only return the `id`
     * const transactionHistoryWithIdOnly = await prisma.transactionHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionHistory.
     * @param {TransactionHistoryDeleteArgs} args - Arguments to delete one TransactionHistory.
     * @example
     * // Delete one TransactionHistory
     * const TransactionHistory = await prisma.transactionHistory.delete({
     *   where: {
     *     // ... filter to delete one TransactionHistory
     *   }
     * })
     * 
     */
    delete<T extends TransactionHistoryDeleteArgs>(args: SelectSubset<T, TransactionHistoryDeleteArgs<ExtArgs>>): Prisma__TransactionHistoryClient<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionHistory.
     * @param {TransactionHistoryUpdateArgs} args - Arguments to update one TransactionHistory.
     * @example
     * // Update one TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionHistoryUpdateArgs>(args: SelectSubset<T, TransactionHistoryUpdateArgs<ExtArgs>>): Prisma__TransactionHistoryClient<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionHistories.
     * @param {TransactionHistoryDeleteManyArgs} args - Arguments to filter TransactionHistories to delete.
     * @example
     * // Delete a few TransactionHistories
     * const { count } = await prisma.transactionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionHistoryDeleteManyArgs>(args?: SelectSubset<T, TransactionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionHistories
     * const transactionHistory = await prisma.transactionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionHistoryUpdateManyArgs>(args: SelectSubset<T, TransactionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionHistories and returns the data updated in the database.
     * @param {TransactionHistoryUpdateManyAndReturnArgs} args - Arguments to update many TransactionHistories.
     * @example
     * // Update many TransactionHistories
     * const transactionHistory = await prisma.transactionHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionHistories and only return the `id`
     * const transactionHistoryWithIdOnly = await prisma.transactionHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionHistory.
     * @param {TransactionHistoryUpsertArgs} args - Arguments to update or create a TransactionHistory.
     * @example
     * // Update or create a TransactionHistory
     * const transactionHistory = await prisma.transactionHistory.upsert({
     *   create: {
     *     // ... data to create a TransactionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionHistory we want to update
     *   }
     * })
     */
    upsert<T extends TransactionHistoryUpsertArgs>(args: SelectSubset<T, TransactionHistoryUpsertArgs<ExtArgs>>): Prisma__TransactionHistoryClient<$Result.GetResult<Prisma.$TransactionHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryCountArgs} args - Arguments to filter TransactionHistories to count.
     * @example
     * // Count the number of TransactionHistories
     * const count = await prisma.transactionHistory.count({
     *   where: {
     *     // ... the filter for the TransactionHistories we want to count
     *   }
     * })
    **/
    count<T extends TransactionHistoryCountArgs>(
      args?: Subset<T, TransactionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionHistoryAggregateArgs>(args: Subset<T, TransactionHistoryAggregateArgs>): Prisma.PrismaPromise<GetTransactionHistoryAggregateType<T>>

    /**
     * Group by TransactionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: TransactionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionHistory model
   */
  readonly fields: TransactionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends TransactionHistory$serviceArgs<ExtArgs> = {}>(args?: Subset<T, TransactionHistory$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    enabledBy<T extends TransactionHistory$enabledByArgs<ExtArgs> = {}>(args?: Subset<T, TransactionHistory$enabledByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionHistory model
   */
  interface TransactionHistoryFieldRefs {
    readonly id: FieldRef<"TransactionHistory", 'String'>
    readonly creditsUsed: FieldRef<"TransactionHistory", 'Float'>
    readonly description: FieldRef<"TransactionHistory", 'String'>
    readonly createdAt: FieldRef<"TransactionHistory", 'DateTime'>
    readonly companyId: FieldRef<"TransactionHistory", 'String'>
    readonly serviceId: FieldRef<"TransactionHistory", 'String'>
    readonly numberOfDaysUsed: FieldRef<"TransactionHistory", 'Int'>
    readonly enabledById: FieldRef<"TransactionHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TransactionHistory findUnique
   */
  export type TransactionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TransactionHistory to fetch.
     */
    where: TransactionHistoryWhereUniqueInput
  }

  /**
   * TransactionHistory findUniqueOrThrow
   */
  export type TransactionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TransactionHistory to fetch.
     */
    where: TransactionHistoryWhereUniqueInput
  }

  /**
   * TransactionHistory findFirst
   */
  export type TransactionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TransactionHistory to fetch.
     */
    where?: TransactionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionHistories to fetch.
     */
    orderBy?: TransactionHistoryOrderByWithRelationInput | TransactionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionHistories.
     */
    cursor?: TransactionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionHistories.
     */
    distinct?: TransactionHistoryScalarFieldEnum | TransactionHistoryScalarFieldEnum[]
  }

  /**
   * TransactionHistory findFirstOrThrow
   */
  export type TransactionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TransactionHistory to fetch.
     */
    where?: TransactionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionHistories to fetch.
     */
    orderBy?: TransactionHistoryOrderByWithRelationInput | TransactionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionHistories.
     */
    cursor?: TransactionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionHistories.
     */
    distinct?: TransactionHistoryScalarFieldEnum | TransactionHistoryScalarFieldEnum[]
  }

  /**
   * TransactionHistory findMany
   */
  export type TransactionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TransactionHistories to fetch.
     */
    where?: TransactionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionHistories to fetch.
     */
    orderBy?: TransactionHistoryOrderByWithRelationInput | TransactionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionHistories.
     */
    cursor?: TransactionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionHistories.
     */
    skip?: number
    distinct?: TransactionHistoryScalarFieldEnum | TransactionHistoryScalarFieldEnum[]
  }

  /**
   * TransactionHistory create
   */
  export type TransactionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionHistory.
     */
    data: XOR<TransactionHistoryCreateInput, TransactionHistoryUncheckedCreateInput>
  }

  /**
   * TransactionHistory createMany
   */
  export type TransactionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionHistories.
     */
    data: TransactionHistoryCreateManyInput | TransactionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionHistory createManyAndReturn
   */
  export type TransactionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionHistories.
     */
    data: TransactionHistoryCreateManyInput | TransactionHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionHistory update
   */
  export type TransactionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionHistory.
     */
    data: XOR<TransactionHistoryUpdateInput, TransactionHistoryUncheckedUpdateInput>
    /**
     * Choose, which TransactionHistory to update.
     */
    where: TransactionHistoryWhereUniqueInput
  }

  /**
   * TransactionHistory updateMany
   */
  export type TransactionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionHistories.
     */
    data: XOR<TransactionHistoryUpdateManyMutationInput, TransactionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which TransactionHistories to update
     */
    where?: TransactionHistoryWhereInput
    /**
     * Limit how many TransactionHistories to update.
     */
    limit?: number
  }

  /**
   * TransactionHistory updateManyAndReturn
   */
  export type TransactionHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * The data used to update TransactionHistories.
     */
    data: XOR<TransactionHistoryUpdateManyMutationInput, TransactionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which TransactionHistories to update
     */
    where?: TransactionHistoryWhereInput
    /**
     * Limit how many TransactionHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionHistory upsert
   */
  export type TransactionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionHistory to update in case it exists.
     */
    where: TransactionHistoryWhereUniqueInput
    /**
     * In case the TransactionHistory found by the `where` argument doesn't exist, create a new TransactionHistory with this data.
     */
    create: XOR<TransactionHistoryCreateInput, TransactionHistoryUncheckedCreateInput>
    /**
     * In case the TransactionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionHistoryUpdateInput, TransactionHistoryUncheckedUpdateInput>
  }

  /**
   * TransactionHistory delete
   */
  export type TransactionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
    /**
     * Filter which TransactionHistory to delete.
     */
    where: TransactionHistoryWhereUniqueInput
  }

  /**
   * TransactionHistory deleteMany
   */
  export type TransactionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionHistories to delete
     */
    where?: TransactionHistoryWhereInput
    /**
     * Limit how many TransactionHistories to delete.
     */
    limit?: number
  }

  /**
   * TransactionHistory.service
   */
  export type TransactionHistory$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * TransactionHistory.enabledBy
   */
  export type TransactionHistory$enabledByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TransactionHistory without action
   */
  export type TransactionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionHistory
     */
    select?: TransactionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionHistory
     */
    omit?: TransactionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionHistoryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firebaseId: 'firebaseId',
    email: 'email',
    fullName: 'fullName',
    phone: 'phone',
    profileImage: 'profileImage',
    employeeId: 'employeeId',
    designation: 'designation',
    role: 'role',
    isActive: 'isActive',
    dateOfJoining: 'dateOfJoining',
    dateOfBirth: 'dateOfBirth',
    address: 'address',
    emergencyContact: 'emergencyContact',
    salary: 'salary',
    workingHoursPerDay: 'workingHoursPerDay',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    departmentId: 'departmentId',
    managerId: 'managerId',
    Salary: 'Salary'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserCompanyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    role: 'role',
    isActive: 'isActive',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserCompanyScalarFieldEnum = (typeof UserCompanyScalarFieldEnum)[keyof typeof UserCompanyScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    website: 'website',
    logo: 'logo',
    industry: 'industry',
    gstNumber: 'gstNumber',
    panNumber: 'panNumber',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    Country: 'Country',
    totalCredits: 'totalCredits',
    usedCredits: 'usedCredits'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    headOfDeptId: 'headOfDeptId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    clockInTime: 'clockInTime',
    clockOutTime: 'clockOutTime',
    workingHours: 'workingHours',
    overtimeHours: 'overtimeHours',
    status: 'status',
    location: 'location',
    notes: 'notes',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    companyId: 'companyId'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const LeaveScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    leaveType: 'leaveType',
    reason: 'reason',
    status: 'status',
    appliedDate: 'appliedDate',
    approvedBy: 'approvedBy',
    rejectedBy: 'rejectedBy',
    comments: 'comments',
    totalDays: 'totalDays',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    companyId: 'companyId'
  };

  export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


  export const WorkingDayScalarFieldEnum: {
    id: 'id',
    dayOfWeek: 'dayOfWeek',
    isWorking: 'isWorking',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type WorkingDayScalarFieldEnum = (typeof WorkingDayScalarFieldEnum)[keyof typeof WorkingDayScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    startDate: 'startDate',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    estimatedHours: 'estimatedHours',
    actualHours: 'actualHours',
    progress: 'progress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedToId: 'assignedToId',
    createdById: 'createdById',
    departmentId: 'departmentId',
    companyId: 'companyId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const ChatMemberScalarFieldEnum: {
    id: 'id',
    isAdmin: 'isAdmin',
    joinedAt: 'joinedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    chatId: 'chatId',
    userId: 'userId'
  };

  export type ChatMemberScalarFieldEnum = (typeof ChatMemberScalarFieldEnum)[keyof typeof ChatMemberScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    type: 'type',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    isPinned: 'isPinned',
    replyTo: 'replyTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    chatId: 'chatId',
    senderId: 'senderId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    sku: 'sku',
    category: 'category',
    unit: 'unit',
    currentStock: 'currentStock',
    minimumStock: 'minimumStock',
    maximumStock: 'maximumStock',
    reorderLevel: 'reorderLevel',
    unitPrice: 'unitPrice',
    location: 'location',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const InventoryMovementScalarFieldEnum: {
    id: 'id',
    movementType: 'movementType',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    reference: 'reference',
    notes: 'notes',
    movedBy: 'movedBy',
    createdAt: 'createdAt',
    itemId: 'itemId'
  };

  export type InventoryMovementScalarFieldEnum = (typeof InventoryMovementScalarFieldEnum)[keyof typeof InventoryMovementScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    address: 'address',
    gstNumber: 'gstNumber',
    panNumber: 'panNumber',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const SupplierItemScalarFieldEnum: {
    id: 'id',
    supplierPrice: 'supplierPrice',
    leadTime: 'leadTime',
    isPreferred: 'isPreferred',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    supplierId: 'supplierId',
    itemId: 'itemId'
  };

  export type SupplierItemScalarFieldEnum = (typeof SupplierItemScalarFieldEnum)[keyof typeof SupplierItemScalarFieldEnum]


  export const GatePassScalarFieldEnum: {
    id: 'id',
    passNumber: 'passNumber',
    type: 'type',
    purpose: 'purpose',
    visitorName: 'visitorName',
    visitorPhone: 'visitorPhone',
    visitorCompany: 'visitorCompany',
    vehicleNumber: 'vehicleNumber',
    itemsCarried: 'itemsCarried',
    entryTime: 'entryTime',
    exitTime: 'exitTime',
    status: 'status',
    validUntil: 'validUntil',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    createdById: 'createdById',
    forUserId: 'forUserId'
  };

  export type GatePassScalarFieldEnum = (typeof GatePassScalarFieldEnum)[keyof typeof GatePassScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    documentType: 'documentType',
    isConfidential: 'isConfidential',
    expiryDate: 'expiryDate',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    uploadedById: 'uploadedById'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const PerformanceReviewScalarFieldEnum: {
    id: 'id',
    reviewPeriodStart: 'reviewPeriodStart',
    reviewPeriodEnd: 'reviewPeriodEnd',
    overallRating: 'overallRating',
    goalsAchieved: 'goalsAchieved',
    punctualityScore: 'punctualityScore',
    qualityScore: 'qualityScore',
    communicationScore: 'communicationScore',
    teamworkScore: 'teamworkScore',
    comments: 'comments',
    goals: 'goals',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reviewForId: 'reviewForId',
    reviewById: 'reviewById',
    companyId: 'companyId'
  };

  export type PerformanceReviewScalarFieldEnum = (typeof PerformanceReviewScalarFieldEnum)[keyof typeof PerformanceReviewScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    tableName: 'tableName',
    recordId: 'recordId',
    oldData: 'oldData',
    newData: 'newData',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    description: 'description',
    createdAt: 'createdAt',
    companyId: 'companyId',
    userId: 'userId'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const CreditsRechargeScalarFieldEnum: {
    id: 'id',
    credits: 'credits',
    amountPaid: 'amountPaid',
    transactionId: 'transactionId',
    paymentMethod: 'paymentMethod',
    paymentStatus: 'paymentStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    purchasedById: 'purchasedById'
  };

  export type CreditsRechargeScalarFieldEnum = (typeof CreditsRechargeScalarFieldEnum)[keyof typeof CreditsRechargeScalarFieldEnum]


  export const TransactionHistoryScalarFieldEnum: {
    id: 'id',
    creditsUsed: 'creditsUsed',
    description: 'description',
    createdAt: 'createdAt',
    companyId: 'companyId',
    serviceId: 'serviceId',
    numberOfDaysUsed: 'numberOfDaysUsed',
    enabledById: 'enabledById'
  };

  export type TransactionHistoryScalarFieldEnum = (typeof TransactionHistoryScalarFieldEnum)[keyof typeof TransactionHistoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'LeaveType'
   */
  export type EnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType'>
    


  /**
   * Reference to a field of type 'LeaveType[]'
   */
  export type ListEnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType[]'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'LeaveStatus[]'
   */
  export type ListEnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'TaskPriority'
   */
  export type EnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority'>
    


  /**
   * Reference to a field of type 'TaskPriority[]'
   */
  export type ListEnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority[]'>
    


  /**
   * Reference to a field of type 'ChatType'
   */
  export type EnumChatTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatType'>
    


  /**
   * Reference to a field of type 'ChatType[]'
   */
  export type ListEnumChatTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatType[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'InventoryMovementType'
   */
  export type EnumInventoryMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryMovementType'>
    


  /**
   * Reference to a field of type 'InventoryMovementType[]'
   */
  export type ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryMovementType[]'>
    


  /**
   * Reference to a field of type 'GatePassType'
   */
  export type EnumGatePassTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GatePassType'>
    


  /**
   * Reference to a field of type 'GatePassType[]'
   */
  export type ListEnumGatePassTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GatePassType[]'>
    


  /**
   * Reference to a field of type 'GatePassStatus'
   */
  export type EnumGatePassStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GatePassStatus'>
    


  /**
   * Reference to a field of type 'GatePassStatus[]'
   */
  export type ListEnumGatePassStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GatePassStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'AuditLogAction'
   */
  export type EnumAuditLogActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditLogAction'>
    


  /**
   * Reference to a field of type 'AuditLogAction[]'
   */
  export type ListEnumAuditLogActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditLogAction[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firebaseId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    employeeId?: StringNullableFilter<"User"> | string | null
    designation?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    dateOfJoining?: DateTimeNullableFilter<"User"> | Date | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    address?: StringNullableFilter<"User"> | string | null
    emergencyContact?: StringNullableFilter<"User"> | string | null
    salary?: FloatNullableFilter<"User"> | number | null
    workingHoursPerDay?: FloatNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    departmentId?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    Salary?: IntNullableFilter<"User"> | number | null
    enabledServices?: TransactionHistoryListRelationFilter
    userCompanies?: UserCompanyListRelationFilter
    headedDepartments?: DepartmentListRelationFilter
    attendances?: AttendanceListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    chatMembers?: ChatMemberListRelationFilter
    documentUploads?: DocumentListRelationFilter
    gatePassesCreated?: GatePassListRelationFilter
    gatePassesFor?: GatePassListRelationFilter
    leaves?: LeaveListRelationFilter
    sentMessages?: MessageListRelationFilter
    reviewsGiven?: PerformanceReviewListRelationFilter
    performanceReviews?: PerformanceReviewListRelationFilter
    tasksAssigned?: TaskListRelationFilter
    tasksCreated?: TaskListRelationFilter
    creditsRecharges?: CreditsRechargeListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subordinates?: UserListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firebaseId?: SortOrderInput | SortOrder
    email?: SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    dateOfJoining?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    workingHoursPerDay?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    Salary?: SortOrderInput | SortOrder
    enabledServices?: TransactionHistoryOrderByRelationAggregateInput
    userCompanies?: UserCompanyOrderByRelationAggregateInput
    headedDepartments?: DepartmentOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    chatMembers?: ChatMemberOrderByRelationAggregateInput
    documentUploads?: DocumentOrderByRelationAggregateInput
    gatePassesCreated?: GatePassOrderByRelationAggregateInput
    gatePassesFor?: GatePassOrderByRelationAggregateInput
    leaves?: LeaveOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    reviewsGiven?: PerformanceReviewOrderByRelationAggregateInput
    performanceReviews?: PerformanceReviewOrderByRelationAggregateInput
    tasksAssigned?: TaskOrderByRelationAggregateInput
    tasksCreated?: TaskOrderByRelationAggregateInput
    creditsRecharges?: CreditsRechargeOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    subordinates?: UserOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    firebaseId?: string
    email?: string
    employeeId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    designation?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    dateOfJoining?: DateTimeNullableFilter<"User"> | Date | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    address?: StringNullableFilter<"User"> | string | null
    emergencyContact?: StringNullableFilter<"User"> | string | null
    salary?: FloatNullableFilter<"User"> | number | null
    workingHoursPerDay?: FloatNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    departmentId?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    Salary?: IntNullableFilter<"User"> | number | null
    enabledServices?: TransactionHistoryListRelationFilter
    userCompanies?: UserCompanyListRelationFilter
    headedDepartments?: DepartmentListRelationFilter
    attendances?: AttendanceListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    chatMembers?: ChatMemberListRelationFilter
    documentUploads?: DocumentListRelationFilter
    gatePassesCreated?: GatePassListRelationFilter
    gatePassesFor?: GatePassListRelationFilter
    leaves?: LeaveListRelationFilter
    sentMessages?: MessageListRelationFilter
    reviewsGiven?: PerformanceReviewListRelationFilter
    performanceReviews?: PerformanceReviewListRelationFilter
    tasksAssigned?: TaskListRelationFilter
    tasksCreated?: TaskListRelationFilter
    creditsRecharges?: CreditsRechargeListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subordinates?: UserListRelationFilter
  }, "id" | "firebaseId" | "email" | "employeeId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firebaseId?: SortOrderInput | SortOrder
    email?: SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    dateOfJoining?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    workingHoursPerDay?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    Salary?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firebaseId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    employeeId?: StringNullableWithAggregatesFilter<"User"> | string | null
    designation?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    dateOfJoining?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"User"> | string | null
    salary?: FloatNullableWithAggregatesFilter<"User"> | number | null
    workingHoursPerDay?: FloatNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    departmentId?: StringNullableWithAggregatesFilter<"User"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    Salary?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type UserCompanyWhereInput = {
    AND?: UserCompanyWhereInput | UserCompanyWhereInput[]
    OR?: UserCompanyWhereInput[]
    NOT?: UserCompanyWhereInput | UserCompanyWhereInput[]
    id?: StringFilter<"UserCompany"> | string
    userId?: StringFilter<"UserCompany"> | string
    companyId?: StringFilter<"UserCompany"> | string
    role?: EnumRoleFilter<"UserCompany"> | $Enums.Role
    isActive?: BoolFilter<"UserCompany"> | boolean
    joinedAt?: DateTimeFilter<"UserCompany"> | Date | string
    leftAt?: DateTimeNullableFilter<"UserCompany"> | Date | string | null
    createdAt?: DateTimeFilter<"UserCompany"> | Date | string
    updatedAt?: DateTimeFilter<"UserCompany"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type UserCompanyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type UserCompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_companyId?: UserCompanyUserIdCompanyIdCompoundUniqueInput
    AND?: UserCompanyWhereInput | UserCompanyWhereInput[]
    OR?: UserCompanyWhereInput[]
    NOT?: UserCompanyWhereInput | UserCompanyWhereInput[]
    userId?: StringFilter<"UserCompany"> | string
    companyId?: StringFilter<"UserCompany"> | string
    role?: EnumRoleFilter<"UserCompany"> | $Enums.Role
    isActive?: BoolFilter<"UserCompany"> | boolean
    joinedAt?: DateTimeFilter<"UserCompany"> | Date | string
    leftAt?: DateTimeNullableFilter<"UserCompany"> | Date | string | null
    createdAt?: DateTimeFilter<"UserCompany"> | Date | string
    updatedAt?: DateTimeFilter<"UserCompany"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "userId_companyId">

  export type UserCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCompanyCountOrderByAggregateInput
    _max?: UserCompanyMaxOrderByAggregateInput
    _min?: UserCompanyMinOrderByAggregateInput
  }

  export type UserCompanyScalarWhereWithAggregatesInput = {
    AND?: UserCompanyScalarWhereWithAggregatesInput | UserCompanyScalarWhereWithAggregatesInput[]
    OR?: UserCompanyScalarWhereWithAggregatesInput[]
    NOT?: UserCompanyScalarWhereWithAggregatesInput | UserCompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserCompany"> | string
    userId?: StringWithAggregatesFilter<"UserCompany"> | string
    companyId?: StringWithAggregatesFilter<"UserCompany"> | string
    role?: EnumRoleWithAggregatesFilter<"UserCompany"> | $Enums.Role
    isActive?: BoolWithAggregatesFilter<"UserCompany"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"UserCompany"> | Date | string
    leftAt?: DateTimeNullableWithAggregatesFilter<"UserCompany"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserCompany"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserCompany"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    logo?: StringNullableFilter<"Company"> | string | null
    industry?: StringNullableFilter<"Company"> | string | null
    gstNumber?: StringNullableFilter<"Company"> | string | null
    panNumber?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    Country?: StringNullableFilter<"Company"> | string | null
    totalCredits?: FloatFilter<"Company"> | number
    usedCredits?: FloatFilter<"Company"> | number
    userCompanies?: UserCompanyListRelationFilter
    services?: ServiceListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    chats?: ChatListRelationFilter
    departments?: DepartmentListRelationFilter
    documents?: DocumentListRelationFilter
    gatePasses?: GatePassListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    suppliers?: SupplierListRelationFilter
    workingDays?: WorkingDayListRelationFilter
    creditsRecharges?: CreditsRechargeListRelationFilter
    transactionHistory?: TransactionHistoryListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    gstNumber?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Country?: SortOrderInput | SortOrder
    totalCredits?: SortOrder
    usedCredits?: SortOrder
    userCompanies?: UserCompanyOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
    departments?: DepartmentOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    gatePasses?: GatePassOrderByRelationAggregateInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    suppliers?: SupplierOrderByRelationAggregateInput
    workingDays?: WorkingDayOrderByRelationAggregateInput
    creditsRecharges?: CreditsRechargeOrderByRelationAggregateInput
    transactionHistory?: TransactionHistoryOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    logo?: StringNullableFilter<"Company"> | string | null
    industry?: StringNullableFilter<"Company"> | string | null
    gstNumber?: StringNullableFilter<"Company"> | string | null
    panNumber?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    Country?: StringNullableFilter<"Company"> | string | null
    totalCredits?: FloatFilter<"Company"> | number
    usedCredits?: FloatFilter<"Company"> | number
    userCompanies?: UserCompanyListRelationFilter
    services?: ServiceListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    chats?: ChatListRelationFilter
    departments?: DepartmentListRelationFilter
    documents?: DocumentListRelationFilter
    gatePasses?: GatePassListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    suppliers?: SupplierListRelationFilter
    workingDays?: WorkingDayListRelationFilter
    creditsRecharges?: CreditsRechargeListRelationFilter
    transactionHistory?: TransactionHistoryListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    gstNumber?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Country?: SortOrderInput | SortOrder
    totalCredits?: SortOrder
    usedCredits?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Company"> | string | null
    email?: StringNullableWithAggregatesFilter<"Company"> | string | null
    website?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    industry?: StringNullableWithAggregatesFilter<"Company"> | string | null
    gstNumber?: StringNullableWithAggregatesFilter<"Company"> | string | null
    panNumber?: StringNullableWithAggregatesFilter<"Company"> | string | null
    isActive?: BoolWithAggregatesFilter<"Company"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    Country?: StringNullableWithAggregatesFilter<"Company"> | string | null
    totalCredits?: FloatWithAggregatesFilter<"Company"> | number
    usedCredits?: FloatWithAggregatesFilter<"Company"> | number
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: FloatFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    companyId?: StringFilter<"Service"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    transactions?: TransactionHistoryListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    transactions?: TransactionHistoryOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: FloatFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    companyId?: StringFilter<"Service"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    transactions?: TransactionHistoryListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    price?: FloatWithAggregatesFilter<"Service"> | number
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    companyId?: StringWithAggregatesFilter<"Service"> | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    headOfDeptId?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    companyId?: StringFilter<"Department"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    headOfDept?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tasks?: TaskListRelationFilter
    users?: UserListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    headOfDeptId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    headOfDept?: UserOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    headOfDeptId?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    companyId?: StringFilter<"Department"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    headOfDept?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tasks?: TaskListRelationFilter
    users?: UserListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    headOfDeptId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    headOfDeptId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    isActive?: BoolWithAggregatesFilter<"Department"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    companyId?: StringWithAggregatesFilter<"Department"> | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    clockInTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    clockOutTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    workingHours?: FloatNullableFilter<"Attendance"> | number | null
    overtimeHours?: FloatNullableFilter<"Attendance"> | number | null
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    location?: StringNullableFilter<"Attendance"> | string | null
    notes?: StringNullableFilter<"Attendance"> | string | null
    date?: DateTimeFilter<"Attendance"> | Date | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    userId?: StringFilter<"Attendance"> | string
    companyId?: StringFilter<"Attendance"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    clockInTime?: SortOrderInput | SortOrder
    clockOutTime?: SortOrderInput | SortOrder
    workingHours?: SortOrderInput | SortOrder
    overtimeHours?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date_companyId?: AttendanceUserIdDateCompanyIdCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    clockInTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    clockOutTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    workingHours?: FloatNullableFilter<"Attendance"> | number | null
    overtimeHours?: FloatNullableFilter<"Attendance"> | number | null
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    location?: StringNullableFilter<"Attendance"> | string | null
    notes?: StringNullableFilter<"Attendance"> | string | null
    date?: DateTimeFilter<"Attendance"> | Date | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    userId?: StringFilter<"Attendance"> | string
    companyId?: StringFilter<"Attendance"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date_companyId">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    clockInTime?: SortOrderInput | SortOrder
    clockOutTime?: SortOrderInput | SortOrder
    workingHours?: SortOrderInput | SortOrder
    overtimeHours?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    clockInTime?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    clockOutTime?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    workingHours?: FloatNullableWithAggregatesFilter<"Attendance"> | number | null
    overtimeHours?: FloatNullableWithAggregatesFilter<"Attendance"> | number | null
    status?: EnumAttendanceStatusWithAggregatesFilter<"Attendance"> | $Enums.AttendanceStatus
    location?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    userId?: StringWithAggregatesFilter<"Attendance"> | string
    companyId?: StringWithAggregatesFilter<"Attendance"> | string
  }

  export type LeaveWhereInput = {
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    id?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    leaveType?: EnumLeaveTypeFilter<"Leave"> | $Enums.LeaveType
    reason?: StringFilter<"Leave"> | string
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    appliedDate?: DateTimeFilter<"Leave"> | Date | string
    approvedBy?: StringNullableFilter<"Leave"> | string | null
    rejectedBy?: StringNullableFilter<"Leave"> | string | null
    comments?: StringNullableFilter<"Leave"> | string | null
    totalDays?: IntFilter<"Leave"> | number
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    userId?: StringFilter<"Leave"> | string
    companyId?: StringFilter<"Leave"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LeaveOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    appliedDate?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    rejectedBy?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    totalDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    leaveType?: EnumLeaveTypeFilter<"Leave"> | $Enums.LeaveType
    reason?: StringFilter<"Leave"> | string
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    appliedDate?: DateTimeFilter<"Leave"> | Date | string
    approvedBy?: StringNullableFilter<"Leave"> | string | null
    rejectedBy?: StringNullableFilter<"Leave"> | string | null
    comments?: StringNullableFilter<"Leave"> | string | null
    totalDays?: IntFilter<"Leave"> | number
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    userId?: StringFilter<"Leave"> | string
    companyId?: StringFilter<"Leave"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LeaveOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    appliedDate?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    rejectedBy?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    totalDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    _count?: LeaveCountOrderByAggregateInput
    _avg?: LeaveAvgOrderByAggregateInput
    _max?: LeaveMaxOrderByAggregateInput
    _min?: LeaveMinOrderByAggregateInput
    _sum?: LeaveSumOrderByAggregateInput
  }

  export type LeaveScalarWhereWithAggregatesInput = {
    AND?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    OR?: LeaveScalarWhereWithAggregatesInput[]
    NOT?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Leave"> | string
    startDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    leaveType?: EnumLeaveTypeWithAggregatesFilter<"Leave"> | $Enums.LeaveType
    reason?: StringWithAggregatesFilter<"Leave"> | string
    status?: EnumLeaveStatusWithAggregatesFilter<"Leave"> | $Enums.LeaveStatus
    appliedDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    approvedBy?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    rejectedBy?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    comments?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    totalDays?: IntWithAggregatesFilter<"Leave"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    userId?: StringWithAggregatesFilter<"Leave"> | string
    companyId?: StringWithAggregatesFilter<"Leave"> | string
  }

  export type WorkingDayWhereInput = {
    AND?: WorkingDayWhereInput | WorkingDayWhereInput[]
    OR?: WorkingDayWhereInput[]
    NOT?: WorkingDayWhereInput | WorkingDayWhereInput[]
    id?: StringFilter<"WorkingDay"> | string
    dayOfWeek?: IntFilter<"WorkingDay"> | number
    isWorking?: BoolFilter<"WorkingDay"> | boolean
    startTime?: StringNullableFilter<"WorkingDay"> | string | null
    endTime?: StringNullableFilter<"WorkingDay"> | string | null
    createdAt?: DateTimeFilter<"WorkingDay"> | Date | string
    updatedAt?: DateTimeFilter<"WorkingDay"> | Date | string
    companyId?: StringFilter<"WorkingDay"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type WorkingDayOrderByWithRelationInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    isWorking?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type WorkingDayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_dayOfWeek?: WorkingDayCompanyIdDayOfWeekCompoundUniqueInput
    AND?: WorkingDayWhereInput | WorkingDayWhereInput[]
    OR?: WorkingDayWhereInput[]
    NOT?: WorkingDayWhereInput | WorkingDayWhereInput[]
    dayOfWeek?: IntFilter<"WorkingDay"> | number
    isWorking?: BoolFilter<"WorkingDay"> | boolean
    startTime?: StringNullableFilter<"WorkingDay"> | string | null
    endTime?: StringNullableFilter<"WorkingDay"> | string | null
    createdAt?: DateTimeFilter<"WorkingDay"> | Date | string
    updatedAt?: DateTimeFilter<"WorkingDay"> | Date | string
    companyId?: StringFilter<"WorkingDay"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_dayOfWeek">

  export type WorkingDayOrderByWithAggregationInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    isWorking?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: WorkingDayCountOrderByAggregateInput
    _avg?: WorkingDayAvgOrderByAggregateInput
    _max?: WorkingDayMaxOrderByAggregateInput
    _min?: WorkingDayMinOrderByAggregateInput
    _sum?: WorkingDaySumOrderByAggregateInput
  }

  export type WorkingDayScalarWhereWithAggregatesInput = {
    AND?: WorkingDayScalarWhereWithAggregatesInput | WorkingDayScalarWhereWithAggregatesInput[]
    OR?: WorkingDayScalarWhereWithAggregatesInput[]
    NOT?: WorkingDayScalarWhereWithAggregatesInput | WorkingDayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkingDay"> | string
    dayOfWeek?: IntWithAggregatesFilter<"WorkingDay"> | number
    isWorking?: BoolWithAggregatesFilter<"WorkingDay"> | boolean
    startTime?: StringNullableWithAggregatesFilter<"WorkingDay"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"WorkingDay"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkingDay"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkingDay"> | Date | string
    companyId?: StringWithAggregatesFilter<"WorkingDay"> | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedHours?: FloatNullableFilter<"Task"> | number | null
    actualHours?: FloatNullableFilter<"Task"> | number | null
    progress?: IntFilter<"Task"> | number
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    assignedToId?: StringFilter<"Task"> | string
    createdById?: StringFilter<"Task"> | string
    departmentId?: StringNullableFilter<"Task"> | string | null
    companyId?: StringFilter<"Task"> | string
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    actualHours?: SortOrderInput | SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    assignedTo?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedHours?: FloatNullableFilter<"Task"> | number | null
    actualHours?: FloatNullableFilter<"Task"> | number | null
    progress?: IntFilter<"Task"> | number
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    assignedToId?: StringFilter<"Task"> | string
    createdById?: StringFilter<"Task"> | string
    departmentId?: StringNullableFilter<"Task"> | string | null
    companyId?: StringFilter<"Task"> | string
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    actualHours?: SortOrderInput | SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumTaskPriorityWithAggregatesFilter<"Task"> | $Enums.TaskPriority
    startDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    estimatedHours?: FloatNullableWithAggregatesFilter<"Task"> | number | null
    actualHours?: FloatNullableWithAggregatesFilter<"Task"> | number | null
    progress?: IntWithAggregatesFilter<"Task"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    assignedToId?: StringWithAggregatesFilter<"Task"> | string
    createdById?: StringWithAggregatesFilter<"Task"> | string
    departmentId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    companyId?: StringWithAggregatesFilter<"Task"> | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    name?: StringNullableFilter<"Chat"> | string | null
    type?: EnumChatTypeFilter<"Chat"> | $Enums.ChatType
    description?: StringNullableFilter<"Chat"> | string | null
    isActive?: BoolFilter<"Chat"> | boolean
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    companyId?: StringFilter<"Chat"> | string
    members?: ChatMemberListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    messages?: MessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    members?: ChatMemberOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    name?: StringNullableFilter<"Chat"> | string | null
    type?: EnumChatTypeFilter<"Chat"> | $Enums.ChatType
    description?: StringNullableFilter<"Chat"> | string | null
    isActive?: BoolFilter<"Chat"> | boolean
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    companyId?: StringFilter<"Chat"> | string
    members?: ChatMemberListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    messages?: MessageListRelationFilter
  }, "id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    name?: StringNullableWithAggregatesFilter<"Chat"> | string | null
    type?: EnumChatTypeWithAggregatesFilter<"Chat"> | $Enums.ChatType
    description?: StringNullableWithAggregatesFilter<"Chat"> | string | null
    isActive?: BoolWithAggregatesFilter<"Chat"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    companyId?: StringWithAggregatesFilter<"Chat"> | string
  }

  export type ChatMemberWhereInput = {
    AND?: ChatMemberWhereInput | ChatMemberWhereInput[]
    OR?: ChatMemberWhereInput[]
    NOT?: ChatMemberWhereInput | ChatMemberWhereInput[]
    id?: StringFilter<"ChatMember"> | string
    isAdmin?: BoolFilter<"ChatMember"> | boolean
    joinedAt?: DateTimeFilter<"ChatMember"> | Date | string
    createdAt?: DateTimeFilter<"ChatMember"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMember"> | Date | string
    chatId?: StringFilter<"ChatMember"> | string
    userId?: StringFilter<"ChatMember"> | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChatMemberOrderByWithRelationInput = {
    id?: SortOrder
    isAdmin?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    chat?: ChatOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChatMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chatId_userId?: ChatMemberChatIdUserIdCompoundUniqueInput
    AND?: ChatMemberWhereInput | ChatMemberWhereInput[]
    OR?: ChatMemberWhereInput[]
    NOT?: ChatMemberWhereInput | ChatMemberWhereInput[]
    isAdmin?: BoolFilter<"ChatMember"> | boolean
    joinedAt?: DateTimeFilter<"ChatMember"> | Date | string
    createdAt?: DateTimeFilter<"ChatMember"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMember"> | Date | string
    chatId?: StringFilter<"ChatMember"> | string
    userId?: StringFilter<"ChatMember"> | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "chatId_userId">

  export type ChatMemberOrderByWithAggregationInput = {
    id?: SortOrder
    isAdmin?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    _count?: ChatMemberCountOrderByAggregateInput
    _max?: ChatMemberMaxOrderByAggregateInput
    _min?: ChatMemberMinOrderByAggregateInput
  }

  export type ChatMemberScalarWhereWithAggregatesInput = {
    AND?: ChatMemberScalarWhereWithAggregatesInput | ChatMemberScalarWhereWithAggregatesInput[]
    OR?: ChatMemberScalarWhereWithAggregatesInput[]
    NOT?: ChatMemberScalarWhereWithAggregatesInput | ChatMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMember"> | string
    isAdmin?: BoolWithAggregatesFilter<"ChatMember"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"ChatMember"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatMember"> | Date | string
    chatId?: StringWithAggregatesFilter<"ChatMember"> | string
    userId?: StringWithAggregatesFilter<"ChatMember"> | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    fileUrl?: StringNullableFilter<"Message"> | string | null
    fileName?: StringNullableFilter<"Message"> | string | null
    isPinned?: BoolFilter<"Message"> | boolean
    replyTo?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    chatId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    replyTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    chat?: ChatOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    fileUrl?: StringNullableFilter<"Message"> | string | null
    fileName?: StringNullableFilter<"Message"> | string | null
    isPinned?: BoolFilter<"Message"> | boolean
    replyTo?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    chatId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    replyTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    type?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    fileUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    fileName?: StringNullableWithAggregatesFilter<"Message"> | string | null
    isPinned?: BoolWithAggregatesFilter<"Message"> | boolean
    replyTo?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    chatId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    sku?: StringFilter<"InventoryItem"> | string
    category?: StringNullableFilter<"InventoryItem"> | string | null
    unit?: StringFilter<"InventoryItem"> | string
    currentStock?: FloatFilter<"InventoryItem"> | number
    minimumStock?: FloatFilter<"InventoryItem"> | number
    maximumStock?: FloatNullableFilter<"InventoryItem"> | number | null
    reorderLevel?: FloatNullableFilter<"InventoryItem"> | number | null
    unitPrice?: FloatNullableFilter<"InventoryItem"> | number | null
    location?: StringNullableFilter<"InventoryItem"> | string | null
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    companyId?: StringFilter<"InventoryItem"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    movements?: InventoryMovementListRelationFilter
    supplierItems?: SupplierItemListRelationFilter
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrder
    category?: SortOrderInput | SortOrder
    unit?: SortOrder
    currentStock?: SortOrder
    minimumStock?: SortOrder
    maximumStock?: SortOrderInput | SortOrder
    reorderLevel?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    movements?: InventoryMovementOrderByRelationAggregateInput
    supplierItems?: SupplierItemOrderByRelationAggregateInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    category?: StringNullableFilter<"InventoryItem"> | string | null
    unit?: StringFilter<"InventoryItem"> | string
    currentStock?: FloatFilter<"InventoryItem"> | number
    minimumStock?: FloatFilter<"InventoryItem"> | number
    maximumStock?: FloatNullableFilter<"InventoryItem"> | number | null
    reorderLevel?: FloatNullableFilter<"InventoryItem"> | number | null
    unitPrice?: FloatNullableFilter<"InventoryItem"> | number | null
    location?: StringNullableFilter<"InventoryItem"> | string | null
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    companyId?: StringFilter<"InventoryItem"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    movements?: InventoryMovementListRelationFilter
    supplierItems?: SupplierItemListRelationFilter
  }, "id" | "sku">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrder
    category?: SortOrderInput | SortOrder
    unit?: SortOrder
    currentStock?: SortOrder
    minimumStock?: SortOrder
    maximumStock?: SortOrderInput | SortOrder
    reorderLevel?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    name?: StringWithAggregatesFilter<"InventoryItem"> | string
    description?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    sku?: StringWithAggregatesFilter<"InventoryItem"> | string
    category?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    unit?: StringWithAggregatesFilter<"InventoryItem"> | string
    currentStock?: FloatWithAggregatesFilter<"InventoryItem"> | number
    minimumStock?: FloatWithAggregatesFilter<"InventoryItem"> | number
    maximumStock?: FloatNullableWithAggregatesFilter<"InventoryItem"> | number | null
    reorderLevel?: FloatNullableWithAggregatesFilter<"InventoryItem"> | number | null
    unitPrice?: FloatNullableWithAggregatesFilter<"InventoryItem"> | number | null
    location?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    isActive?: BoolWithAggregatesFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    companyId?: StringWithAggregatesFilter<"InventoryItem"> | string
  }

  export type InventoryMovementWhereInput = {
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    movementType?: EnumInventoryMovementTypeFilter<"InventoryMovement"> | $Enums.InventoryMovementType
    quantity?: FloatFilter<"InventoryMovement"> | number
    unitPrice?: FloatNullableFilter<"InventoryMovement"> | number | null
    reference?: StringNullableFilter<"InventoryMovement"> | string | null
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    movedBy?: StringFilter<"InventoryMovement"> | string
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    itemId?: StringFilter<"InventoryMovement"> | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }

  export type InventoryMovementOrderByWithRelationInput = {
    id?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    movedBy?: SortOrder
    createdAt?: SortOrder
    itemId?: SortOrder
    item?: InventoryItemOrderByWithRelationInput
  }

  export type InventoryMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    movementType?: EnumInventoryMovementTypeFilter<"InventoryMovement"> | $Enums.InventoryMovementType
    quantity?: FloatFilter<"InventoryMovement"> | number
    unitPrice?: FloatNullableFilter<"InventoryMovement"> | number | null
    reference?: StringNullableFilter<"InventoryMovement"> | string | null
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    movedBy?: StringFilter<"InventoryMovement"> | string
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    itemId?: StringFilter<"InventoryMovement"> | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }, "id">

  export type InventoryMovementOrderByWithAggregationInput = {
    id?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    movedBy?: SortOrder
    createdAt?: SortOrder
    itemId?: SortOrder
    _count?: InventoryMovementCountOrderByAggregateInput
    _avg?: InventoryMovementAvgOrderByAggregateInput
    _max?: InventoryMovementMaxOrderByAggregateInput
    _min?: InventoryMovementMinOrderByAggregateInput
    _sum?: InventoryMovementSumOrderByAggregateInput
  }

  export type InventoryMovementScalarWhereWithAggregatesInput = {
    AND?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    OR?: InventoryMovementScalarWhereWithAggregatesInput[]
    NOT?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryMovement"> | string
    movementType?: EnumInventoryMovementTypeWithAggregatesFilter<"InventoryMovement"> | $Enums.InventoryMovementType
    quantity?: FloatWithAggregatesFilter<"InventoryMovement"> | number
    unitPrice?: FloatNullableWithAggregatesFilter<"InventoryMovement"> | number | null
    reference?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    notes?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    movedBy?: StringWithAggregatesFilter<"InventoryMovement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InventoryMovement"> | Date | string
    itemId?: StringWithAggregatesFilter<"InventoryMovement"> | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    gstNumber?: StringNullableFilter<"Supplier"> | string | null
    panNumber?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    companyId?: StringFilter<"Supplier"> | string
    items?: SupplierItemListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    gstNumber?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    items?: SupplierItemOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    gstNumber?: StringNullableFilter<"Supplier"> | string | null
    panNumber?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    companyId?: StringFilter<"Supplier"> | string
    items?: SupplierItemListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    gstNumber?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    gstNumber?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    panNumber?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    companyId?: StringWithAggregatesFilter<"Supplier"> | string
  }

  export type SupplierItemWhereInput = {
    AND?: SupplierItemWhereInput | SupplierItemWhereInput[]
    OR?: SupplierItemWhereInput[]
    NOT?: SupplierItemWhereInput | SupplierItemWhereInput[]
    id?: StringFilter<"SupplierItem"> | string
    supplierPrice?: FloatNullableFilter<"SupplierItem"> | number | null
    leadTime?: IntNullableFilter<"SupplierItem"> | number | null
    isPreferred?: BoolFilter<"SupplierItem"> | boolean
    createdAt?: DateTimeFilter<"SupplierItem"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierItem"> | Date | string
    supplierId?: StringFilter<"SupplierItem"> | string
    itemId?: StringFilter<"SupplierItem"> | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type SupplierItemOrderByWithRelationInput = {
    id?: SortOrder
    supplierPrice?: SortOrderInput | SortOrder
    leadTime?: SortOrderInput | SortOrder
    isPreferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
    item?: InventoryItemOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type SupplierItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    supplierId_itemId?: SupplierItemSupplierIdItemIdCompoundUniqueInput
    AND?: SupplierItemWhereInput | SupplierItemWhereInput[]
    OR?: SupplierItemWhereInput[]
    NOT?: SupplierItemWhereInput | SupplierItemWhereInput[]
    supplierPrice?: FloatNullableFilter<"SupplierItem"> | number | null
    leadTime?: IntNullableFilter<"SupplierItem"> | number | null
    isPreferred?: BoolFilter<"SupplierItem"> | boolean
    createdAt?: DateTimeFilter<"SupplierItem"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierItem"> | Date | string
    supplierId?: StringFilter<"SupplierItem"> | string
    itemId?: StringFilter<"SupplierItem"> | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "id" | "supplierId_itemId">

  export type SupplierItemOrderByWithAggregationInput = {
    id?: SortOrder
    supplierPrice?: SortOrderInput | SortOrder
    leadTime?: SortOrderInput | SortOrder
    isPreferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
    _count?: SupplierItemCountOrderByAggregateInput
    _avg?: SupplierItemAvgOrderByAggregateInput
    _max?: SupplierItemMaxOrderByAggregateInput
    _min?: SupplierItemMinOrderByAggregateInput
    _sum?: SupplierItemSumOrderByAggregateInput
  }

  export type SupplierItemScalarWhereWithAggregatesInput = {
    AND?: SupplierItemScalarWhereWithAggregatesInput | SupplierItemScalarWhereWithAggregatesInput[]
    OR?: SupplierItemScalarWhereWithAggregatesInput[]
    NOT?: SupplierItemScalarWhereWithAggregatesInput | SupplierItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupplierItem"> | string
    supplierPrice?: FloatNullableWithAggregatesFilter<"SupplierItem"> | number | null
    leadTime?: IntNullableWithAggregatesFilter<"SupplierItem"> | number | null
    isPreferred?: BoolWithAggregatesFilter<"SupplierItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SupplierItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplierItem"> | Date | string
    supplierId?: StringWithAggregatesFilter<"SupplierItem"> | string
    itemId?: StringWithAggregatesFilter<"SupplierItem"> | string
  }

  export type GatePassWhereInput = {
    AND?: GatePassWhereInput | GatePassWhereInput[]
    OR?: GatePassWhereInput[]
    NOT?: GatePassWhereInput | GatePassWhereInput[]
    id?: StringFilter<"GatePass"> | string
    passNumber?: StringFilter<"GatePass"> | string
    type?: EnumGatePassTypeFilter<"GatePass"> | $Enums.GatePassType
    purpose?: StringNullableFilter<"GatePass"> | string | null
    visitorName?: StringNullableFilter<"GatePass"> | string | null
    visitorPhone?: StringNullableFilter<"GatePass"> | string | null
    visitorCompany?: StringNullableFilter<"GatePass"> | string | null
    vehicleNumber?: StringNullableFilter<"GatePass"> | string | null
    itemsCarried?: StringNullableFilter<"GatePass"> | string | null
    entryTime?: DateTimeNullableFilter<"GatePass"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"GatePass"> | Date | string | null
    status?: EnumGatePassStatusFilter<"GatePass"> | $Enums.GatePassStatus
    validUntil?: DateTimeNullableFilter<"GatePass"> | Date | string | null
    notes?: StringNullableFilter<"GatePass"> | string | null
    createdAt?: DateTimeFilter<"GatePass"> | Date | string
    updatedAt?: DateTimeFilter<"GatePass"> | Date | string
    companyId?: StringFilter<"GatePass"> | string
    createdById?: StringFilter<"GatePass"> | string
    forUserId?: StringNullableFilter<"GatePass"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    forUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type GatePassOrderByWithRelationInput = {
    id?: SortOrder
    passNumber?: SortOrder
    type?: SortOrder
    purpose?: SortOrderInput | SortOrder
    visitorName?: SortOrderInput | SortOrder
    visitorPhone?: SortOrderInput | SortOrder
    visitorCompany?: SortOrderInput | SortOrder
    vehicleNumber?: SortOrderInput | SortOrder
    itemsCarried?: SortOrderInput | SortOrder
    entryTime?: SortOrderInput | SortOrder
    exitTime?: SortOrderInput | SortOrder
    status?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    createdById?: SortOrder
    forUserId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    forUser?: UserOrderByWithRelationInput
  }

  export type GatePassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    passNumber?: string
    AND?: GatePassWhereInput | GatePassWhereInput[]
    OR?: GatePassWhereInput[]
    NOT?: GatePassWhereInput | GatePassWhereInput[]
    type?: EnumGatePassTypeFilter<"GatePass"> | $Enums.GatePassType
    purpose?: StringNullableFilter<"GatePass"> | string | null
    visitorName?: StringNullableFilter<"GatePass"> | string | null
    visitorPhone?: StringNullableFilter<"GatePass"> | string | null
    visitorCompany?: StringNullableFilter<"GatePass"> | string | null
    vehicleNumber?: StringNullableFilter<"GatePass"> | string | null
    itemsCarried?: StringNullableFilter<"GatePass"> | string | null
    entryTime?: DateTimeNullableFilter<"GatePass"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"GatePass"> | Date | string | null
    status?: EnumGatePassStatusFilter<"GatePass"> | $Enums.GatePassStatus
    validUntil?: DateTimeNullableFilter<"GatePass"> | Date | string | null
    notes?: StringNullableFilter<"GatePass"> | string | null
    createdAt?: DateTimeFilter<"GatePass"> | Date | string
    updatedAt?: DateTimeFilter<"GatePass"> | Date | string
    companyId?: StringFilter<"GatePass"> | string
    createdById?: StringFilter<"GatePass"> | string
    forUserId?: StringNullableFilter<"GatePass"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    forUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "passNumber">

  export type GatePassOrderByWithAggregationInput = {
    id?: SortOrder
    passNumber?: SortOrder
    type?: SortOrder
    purpose?: SortOrderInput | SortOrder
    visitorName?: SortOrderInput | SortOrder
    visitorPhone?: SortOrderInput | SortOrder
    visitorCompany?: SortOrderInput | SortOrder
    vehicleNumber?: SortOrderInput | SortOrder
    itemsCarried?: SortOrderInput | SortOrder
    entryTime?: SortOrderInput | SortOrder
    exitTime?: SortOrderInput | SortOrder
    status?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    createdById?: SortOrder
    forUserId?: SortOrderInput | SortOrder
    _count?: GatePassCountOrderByAggregateInput
    _max?: GatePassMaxOrderByAggregateInput
    _min?: GatePassMinOrderByAggregateInput
  }

  export type GatePassScalarWhereWithAggregatesInput = {
    AND?: GatePassScalarWhereWithAggregatesInput | GatePassScalarWhereWithAggregatesInput[]
    OR?: GatePassScalarWhereWithAggregatesInput[]
    NOT?: GatePassScalarWhereWithAggregatesInput | GatePassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GatePass"> | string
    passNumber?: StringWithAggregatesFilter<"GatePass"> | string
    type?: EnumGatePassTypeWithAggregatesFilter<"GatePass"> | $Enums.GatePassType
    purpose?: StringNullableWithAggregatesFilter<"GatePass"> | string | null
    visitorName?: StringNullableWithAggregatesFilter<"GatePass"> | string | null
    visitorPhone?: StringNullableWithAggregatesFilter<"GatePass"> | string | null
    visitorCompany?: StringNullableWithAggregatesFilter<"GatePass"> | string | null
    vehicleNumber?: StringNullableWithAggregatesFilter<"GatePass"> | string | null
    itemsCarried?: StringNullableWithAggregatesFilter<"GatePass"> | string | null
    entryTime?: DateTimeNullableWithAggregatesFilter<"GatePass"> | Date | string | null
    exitTime?: DateTimeNullableWithAggregatesFilter<"GatePass"> | Date | string | null
    status?: EnumGatePassStatusWithAggregatesFilter<"GatePass"> | $Enums.GatePassStatus
    validUntil?: DateTimeNullableWithAggregatesFilter<"GatePass"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"GatePass"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GatePass"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GatePass"> | Date | string
    companyId?: StringWithAggregatesFilter<"GatePass"> | string
    createdById?: StringWithAggregatesFilter<"GatePass"> | string
    forUserId?: StringNullableWithAggregatesFilter<"GatePass"> | string | null
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    fileName?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    documentType?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    isConfidential?: BoolFilter<"Document"> | boolean
    expiryDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    tags?: StringNullableListFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    companyId?: StringFilter<"Document"> | string
    uploadedById?: StringFilter<"Document"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    documentType?: SortOrder
    isConfidential?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    uploadedById?: SortOrder
    company?: CompanyOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    fileName?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    documentType?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    isConfidential?: BoolFilter<"Document"> | boolean
    expiryDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    tags?: StringNullableListFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    companyId?: StringFilter<"Document"> | string
    uploadedById?: StringFilter<"Document"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    documentType?: SortOrder
    isConfidential?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    uploadedById?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    fileName?: StringWithAggregatesFilter<"Document"> | string
    fileUrl?: StringWithAggregatesFilter<"Document"> | string
    fileSize?: IntNullableWithAggregatesFilter<"Document"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    documentType?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    isConfidential?: BoolWithAggregatesFilter<"Document"> | boolean
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    tags?: StringNullableListFilter<"Document">
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    companyId?: StringWithAggregatesFilter<"Document"> | string
    uploadedById?: StringWithAggregatesFilter<"Document"> | string
  }

  export type PerformanceReviewWhereInput = {
    AND?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    OR?: PerformanceReviewWhereInput[]
    NOT?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    id?: StringFilter<"PerformanceReview"> | string
    reviewPeriodStart?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewPeriodEnd?: DateTimeFilter<"PerformanceReview"> | Date | string
    overallRating?: FloatNullableFilter<"PerformanceReview"> | number | null
    goalsAchieved?: IntNullableFilter<"PerformanceReview"> | number | null
    punctualityScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    qualityScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    communicationScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    teamworkScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    comments?: StringNullableFilter<"PerformanceReview"> | string | null
    goals?: StringNullableFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewForId?: StringFilter<"PerformanceReview"> | string
    reviewById?: StringFilter<"PerformanceReview"> | string
    companyId?: StringFilter<"PerformanceReview"> | string
    reviewBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewFor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PerformanceReviewOrderByWithRelationInput = {
    id?: SortOrder
    reviewPeriodStart?: SortOrder
    reviewPeriodEnd?: SortOrder
    overallRating?: SortOrderInput | SortOrder
    goalsAchieved?: SortOrderInput | SortOrder
    punctualityScore?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    communicationScore?: SortOrderInput | SortOrder
    teamworkScore?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    goals?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewForId?: SortOrder
    reviewById?: SortOrder
    companyId?: SortOrder
    reviewBy?: UserOrderByWithRelationInput
    reviewFor?: UserOrderByWithRelationInput
  }

  export type PerformanceReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    OR?: PerformanceReviewWhereInput[]
    NOT?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    reviewPeriodStart?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewPeriodEnd?: DateTimeFilter<"PerformanceReview"> | Date | string
    overallRating?: FloatNullableFilter<"PerformanceReview"> | number | null
    goalsAchieved?: IntNullableFilter<"PerformanceReview"> | number | null
    punctualityScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    qualityScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    communicationScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    teamworkScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    comments?: StringNullableFilter<"PerformanceReview"> | string | null
    goals?: StringNullableFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewForId?: StringFilter<"PerformanceReview"> | string
    reviewById?: StringFilter<"PerformanceReview"> | string
    companyId?: StringFilter<"PerformanceReview"> | string
    reviewBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewFor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PerformanceReviewOrderByWithAggregationInput = {
    id?: SortOrder
    reviewPeriodStart?: SortOrder
    reviewPeriodEnd?: SortOrder
    overallRating?: SortOrderInput | SortOrder
    goalsAchieved?: SortOrderInput | SortOrder
    punctualityScore?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    communicationScore?: SortOrderInput | SortOrder
    teamworkScore?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    goals?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewForId?: SortOrder
    reviewById?: SortOrder
    companyId?: SortOrder
    _count?: PerformanceReviewCountOrderByAggregateInput
    _avg?: PerformanceReviewAvgOrderByAggregateInput
    _max?: PerformanceReviewMaxOrderByAggregateInput
    _min?: PerformanceReviewMinOrderByAggregateInput
    _sum?: PerformanceReviewSumOrderByAggregateInput
  }

  export type PerformanceReviewScalarWhereWithAggregatesInput = {
    AND?: PerformanceReviewScalarWhereWithAggregatesInput | PerformanceReviewScalarWhereWithAggregatesInput[]
    OR?: PerformanceReviewScalarWhereWithAggregatesInput[]
    NOT?: PerformanceReviewScalarWhereWithAggregatesInput | PerformanceReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceReview"> | string
    reviewPeriodStart?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    reviewPeriodEnd?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    overallRating?: FloatNullableWithAggregatesFilter<"PerformanceReview"> | number | null
    goalsAchieved?: IntNullableWithAggregatesFilter<"PerformanceReview"> | number | null
    punctualityScore?: FloatNullableWithAggregatesFilter<"PerformanceReview"> | number | null
    qualityScore?: FloatNullableWithAggregatesFilter<"PerformanceReview"> | number | null
    communicationScore?: FloatNullableWithAggregatesFilter<"PerformanceReview"> | number | null
    teamworkScore?: FloatNullableWithAggregatesFilter<"PerformanceReview"> | number | null
    comments?: StringNullableWithAggregatesFilter<"PerformanceReview"> | string | null
    goals?: StringNullableWithAggregatesFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    reviewForId?: StringWithAggregatesFilter<"PerformanceReview"> | string
    reviewById?: StringWithAggregatesFilter<"PerformanceReview"> | string
    companyId?: StringWithAggregatesFilter<"PerformanceReview"> | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: EnumAuditLogActionFilter<"AuditLog"> | $Enums.AuditLogAction
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    description?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    companyId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: EnumAuditLogActionFilter<"AuditLog"> | $Enums.AuditLogAction
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    description?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    companyId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: EnumAuditLogActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditLogAction
    tableName?: StringWithAggregatesFilter<"AuditLog"> | string
    recordId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldData?: JsonNullableWithAggregatesFilter<"AuditLog">
    newData?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    description?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    companyId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
  }

  export type CreditsRechargeWhereInput = {
    AND?: CreditsRechargeWhereInput | CreditsRechargeWhereInput[]
    OR?: CreditsRechargeWhereInput[]
    NOT?: CreditsRechargeWhereInput | CreditsRechargeWhereInput[]
    id?: StringFilter<"CreditsRecharge"> | string
    credits?: FloatFilter<"CreditsRecharge"> | number
    amountPaid?: FloatFilter<"CreditsRecharge"> | number
    transactionId?: StringNullableFilter<"CreditsRecharge"> | string | null
    paymentMethod?: StringNullableFilter<"CreditsRecharge"> | string | null
    paymentStatus?: StringFilter<"CreditsRecharge"> | string
    createdAt?: DateTimeFilter<"CreditsRecharge"> | Date | string
    updatedAt?: DateTimeFilter<"CreditsRecharge"> | Date | string
    companyId?: StringFilter<"CreditsRecharge"> | string
    purchasedById?: StringFilter<"CreditsRecharge"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchasedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CreditsRechargeOrderByWithRelationInput = {
    id?: SortOrder
    credits?: SortOrder
    amountPaid?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    purchasedById?: SortOrder
    company?: CompanyOrderByWithRelationInput
    purchasedBy?: UserOrderByWithRelationInput
  }

  export type CreditsRechargeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: CreditsRechargeWhereInput | CreditsRechargeWhereInput[]
    OR?: CreditsRechargeWhereInput[]
    NOT?: CreditsRechargeWhereInput | CreditsRechargeWhereInput[]
    credits?: FloatFilter<"CreditsRecharge"> | number
    amountPaid?: FloatFilter<"CreditsRecharge"> | number
    paymentMethod?: StringNullableFilter<"CreditsRecharge"> | string | null
    paymentStatus?: StringFilter<"CreditsRecharge"> | string
    createdAt?: DateTimeFilter<"CreditsRecharge"> | Date | string
    updatedAt?: DateTimeFilter<"CreditsRecharge"> | Date | string
    companyId?: StringFilter<"CreditsRecharge"> | string
    purchasedById?: StringFilter<"CreditsRecharge"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchasedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "transactionId">

  export type CreditsRechargeOrderByWithAggregationInput = {
    id?: SortOrder
    credits?: SortOrder
    amountPaid?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    purchasedById?: SortOrder
    _count?: CreditsRechargeCountOrderByAggregateInput
    _avg?: CreditsRechargeAvgOrderByAggregateInput
    _max?: CreditsRechargeMaxOrderByAggregateInput
    _min?: CreditsRechargeMinOrderByAggregateInput
    _sum?: CreditsRechargeSumOrderByAggregateInput
  }

  export type CreditsRechargeScalarWhereWithAggregatesInput = {
    AND?: CreditsRechargeScalarWhereWithAggregatesInput | CreditsRechargeScalarWhereWithAggregatesInput[]
    OR?: CreditsRechargeScalarWhereWithAggregatesInput[]
    NOT?: CreditsRechargeScalarWhereWithAggregatesInput | CreditsRechargeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditsRecharge"> | string
    credits?: FloatWithAggregatesFilter<"CreditsRecharge"> | number
    amountPaid?: FloatWithAggregatesFilter<"CreditsRecharge"> | number
    transactionId?: StringNullableWithAggregatesFilter<"CreditsRecharge"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"CreditsRecharge"> | string | null
    paymentStatus?: StringWithAggregatesFilter<"CreditsRecharge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CreditsRecharge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CreditsRecharge"> | Date | string
    companyId?: StringWithAggregatesFilter<"CreditsRecharge"> | string
    purchasedById?: StringWithAggregatesFilter<"CreditsRecharge"> | string
  }

  export type TransactionHistoryWhereInput = {
    AND?: TransactionHistoryWhereInput | TransactionHistoryWhereInput[]
    OR?: TransactionHistoryWhereInput[]
    NOT?: TransactionHistoryWhereInput | TransactionHistoryWhereInput[]
    id?: StringFilter<"TransactionHistory"> | string
    creditsUsed?: FloatFilter<"TransactionHistory"> | number
    description?: StringNullableFilter<"TransactionHistory"> | string | null
    createdAt?: DateTimeFilter<"TransactionHistory"> | Date | string
    companyId?: StringFilter<"TransactionHistory"> | string
    serviceId?: StringNullableFilter<"TransactionHistory"> | string | null
    numberOfDaysUsed?: IntNullableFilter<"TransactionHistory"> | number | null
    enabledById?: StringNullableFilter<"TransactionHistory"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    enabledBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TransactionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    creditsUsed?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    numberOfDaysUsed?: SortOrderInput | SortOrder
    enabledById?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    enabledBy?: UserOrderByWithRelationInput
  }

  export type TransactionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionHistoryWhereInput | TransactionHistoryWhereInput[]
    OR?: TransactionHistoryWhereInput[]
    NOT?: TransactionHistoryWhereInput | TransactionHistoryWhereInput[]
    creditsUsed?: FloatFilter<"TransactionHistory"> | number
    description?: StringNullableFilter<"TransactionHistory"> | string | null
    createdAt?: DateTimeFilter<"TransactionHistory"> | Date | string
    companyId?: StringFilter<"TransactionHistory"> | string
    serviceId?: StringNullableFilter<"TransactionHistory"> | string | null
    numberOfDaysUsed?: IntNullableFilter<"TransactionHistory"> | number | null
    enabledById?: StringNullableFilter<"TransactionHistory"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    enabledBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TransactionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    creditsUsed?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    numberOfDaysUsed?: SortOrderInput | SortOrder
    enabledById?: SortOrderInput | SortOrder
    _count?: TransactionHistoryCountOrderByAggregateInput
    _avg?: TransactionHistoryAvgOrderByAggregateInput
    _max?: TransactionHistoryMaxOrderByAggregateInput
    _min?: TransactionHistoryMinOrderByAggregateInput
    _sum?: TransactionHistorySumOrderByAggregateInput
  }

  export type TransactionHistoryScalarWhereWithAggregatesInput = {
    AND?: TransactionHistoryScalarWhereWithAggregatesInput | TransactionHistoryScalarWhereWithAggregatesInput[]
    OR?: TransactionHistoryScalarWhereWithAggregatesInput[]
    NOT?: TransactionHistoryScalarWhereWithAggregatesInput | TransactionHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionHistory"> | string
    creditsUsed?: FloatWithAggregatesFilter<"TransactionHistory"> | number
    description?: StringNullableWithAggregatesFilter<"TransactionHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransactionHistory"> | Date | string
    companyId?: StringWithAggregatesFilter<"TransactionHistory"> | string
    serviceId?: StringNullableWithAggregatesFilter<"TransactionHistory"> | string | null
    numberOfDaysUsed?: IntNullableWithAggregatesFilter<"TransactionHistory"> | number | null
    enabledById?: StringNullableWithAggregatesFilter<"TransactionHistory"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCompanyCreateInput = {
    id?: string
    role?: $Enums.Role
    isActive?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserCompaniesInput
    company: CompanyCreateNestedOneWithoutUserCompaniesInput
  }

  export type UserCompanyUncheckedCreateInput = {
    id?: string
    userId: string
    companyId: string
    role?: $Enums.Role
    isActive?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserCompaniesNestedInput
    company?: CompanyUpdateOneRequiredWithoutUserCompaniesNestedInput
  }

  export type UserCompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCompanyCreateManyInput = {
    id?: string
    userId: string
    companyId: string
    role?: $Enums.Role
    isActive?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    services?: ServiceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutServicesInput
    transactions?: TransactionHistoryCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    transactions?: TransactionHistoryUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutServicesNestedInput
    transactions?: TransactionHistoryUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    transactions?: TransactionHistoryUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDepartmentsInput
    headOfDept?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    headOfDeptId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDepartmentsNestedInput
    headOfDept?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDeptId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    headOfDeptId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDeptId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceCreateInput = {
    id?: string
    clockInTime?: Date | string | null
    clockOutTime?: Date | string | null
    workingHours?: number | null
    overtimeHours?: number | null
    status?: $Enums.AttendanceStatus
    location?: string | null
    notes?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    user: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    clockInTime?: Date | string | null
    clockOutTime?: Date | string | null
    workingHours?: number | null
    overtimeHours?: number | null
    status?: $Enums.AttendanceStatus
    location?: string | null
    notes?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    companyId: string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    clockInTime?: Date | string | null
    clockOutTime?: Date | string | null
    workingHours?: number | null
    overtimeHours?: number | null
    status?: $Enums.AttendanceStatus
    location?: string | null
    notes?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    companyId: string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    leaveType: $Enums.LeaveType
    reason: string
    status?: $Enums.LeaveStatus
    appliedDate?: Date | string
    approvedBy?: string | null
    rejectedBy?: string | null
    comments?: string | null
    totalDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    user: UserCreateNestedOneWithoutLeavesInput
  }

  export type LeaveUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    leaveType: $Enums.LeaveType
    reason: string
    status?: $Enums.LeaveStatus
    appliedDate?: Date | string
    approvedBy?: string | null
    rejectedBy?: string | null
    comments?: string | null
    totalDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    companyId: string
  }

  export type LeaveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    appliedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type LeaveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    appliedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    leaveType: $Enums.LeaveType
    reason: string
    status?: $Enums.LeaveStatus
    appliedDate?: Date | string
    approvedBy?: string | null
    rejectedBy?: string | null
    comments?: string | null
    totalDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    companyId: string
  }

  export type LeaveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    appliedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    appliedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkingDayCreateInput = {
    id?: string
    dayOfWeek: number
    isWorking?: boolean
    startTime?: string | null
    endTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutWorkingDaysInput
  }

  export type WorkingDayUncheckedCreateInput = {
    id?: string
    dayOfWeek: number
    isWorking?: boolean
    startTime?: string | null
    endTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type WorkingDayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    isWorking?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutWorkingDaysNestedInput
  }

  export type WorkingDayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    isWorking?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkingDayCreateManyInput = {
    id?: string
    dayOfWeek: number
    isWorking?: boolean
    startTime?: string | null
    endTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type WorkingDayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    isWorking?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingDayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    isWorking?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedTo: UserCreateNestedOneWithoutTasksAssignedInput
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    department?: DepartmentCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId: string
    createdById: string
    departmentId?: string | null
    companyId: string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedTo?: UserUpdateOneRequiredWithoutTasksAssignedNestedInput
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    department?: DepartmentUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId: string
    createdById: string
    departmentId?: string | null
    companyId: string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatCreateInput = {
    id?: string
    name?: string | null
    type: $Enums.ChatType
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ChatMemberCreateNestedManyWithoutChatInput
    company: CompanyCreateNestedOneWithoutChatsInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    name?: string | null
    type: $Enums.ChatType
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    members?: ChatMemberUncheckedCreateNestedManyWithoutChatInput
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatTypeFieldUpdateOperationsInput | $Enums.ChatType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatMemberUpdateManyWithoutChatNestedInput
    company?: CompanyUpdateOneRequiredWithoutChatsNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatTypeFieldUpdateOperationsInput | $Enums.ChatType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    members?: ChatMemberUncheckedUpdateManyWithoutChatNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    name?: string | null
    type: $Enums.ChatType
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatTypeFieldUpdateOperationsInput | $Enums.ChatType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatTypeFieldUpdateOperationsInput | $Enums.ChatType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMemberCreateInput = {
    id?: string
    isAdmin?: boolean
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chat: ChatCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutChatMembersInput
  }

  export type ChatMemberUncheckedCreateInput = {
    id?: string
    isAdmin?: boolean
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatId: string
    userId: string
  }

  export type ChatMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutChatMembersNestedInput
  }

  export type ChatMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMemberCreateManyInput = {
    id?: string
    isAdmin?: boolean
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatId: string
    userId: string
  }

  export type ChatMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    fileUrl?: string | null
    fileName?: string | null
    isPinned?: boolean
    replyTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    fileUrl?: string | null
    fileName?: string | null
    isPinned?: boolean
    replyTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chatId: string
    senderId: string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    fileUrl?: string | null
    fileName?: string | null
    isPinned?: boolean
    replyTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chatId: string
    senderId: string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category?: string | null
    unit: string
    currentStock?: number
    minimumStock?: number
    maximumStock?: number | null
    reorderLevel?: number | null
    unitPrice?: number | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInventoryItemsInput
    movements?: InventoryMovementCreateNestedManyWithoutItemInput
    supplierItems?: SupplierItemCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category?: string | null
    unit: string
    currentStock?: number
    minimumStock?: number
    maximumStock?: number | null
    reorderLevel?: number | null
    unitPrice?: number | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutItemInput
    supplierItems?: SupplierItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: FloatFieldUpdateOperationsInput | number
    minimumStock?: FloatFieldUpdateOperationsInput | number
    maximumStock?: NullableFloatFieldUpdateOperationsInput | number | null
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInventoryItemsNestedInput
    movements?: InventoryMovementUpdateManyWithoutItemNestedInput
    supplierItems?: SupplierItemUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: FloatFieldUpdateOperationsInput | number
    minimumStock?: FloatFieldUpdateOperationsInput | number
    maximumStock?: NullableFloatFieldUpdateOperationsInput | number | null
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    movements?: InventoryMovementUncheckedUpdateManyWithoutItemNestedInput
    supplierItems?: SupplierItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category?: string | null
    unit: string
    currentStock?: number
    minimumStock?: number
    maximumStock?: number | null
    reorderLevel?: number | null
    unitPrice?: number | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: FloatFieldUpdateOperationsInput | number
    minimumStock?: FloatFieldUpdateOperationsInput | number
    maximumStock?: NullableFloatFieldUpdateOperationsInput | number | null
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: FloatFieldUpdateOperationsInput | number
    minimumStock?: FloatFieldUpdateOperationsInput | number
    maximumStock?: NullableFloatFieldUpdateOperationsInput | number | null
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryMovementCreateInput = {
    id?: string
    movementType: $Enums.InventoryMovementType
    quantity: number
    unitPrice?: number | null
    reference?: string | null
    notes?: string | null
    movedBy: string
    createdAt?: Date | string
    item: InventoryItemCreateNestedOneWithoutMovementsInput
  }

  export type InventoryMovementUncheckedCreateInput = {
    id?: string
    movementType: $Enums.InventoryMovementType
    quantity: number
    unitPrice?: number | null
    reference?: string | null
    notes?: string | null
    movedBy: string
    createdAt?: Date | string
    itemId: string
  }

  export type InventoryMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryMovementCreateManyInput = {
    id?: string
    movementType: $Enums.InventoryMovementType
    quantity: number
    unitPrice?: number | null
    reference?: string | null
    notes?: string | null
    movedBy: string
    createdAt?: Date | string
    itemId: string
  }

  export type InventoryMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SupplierItemCreateNestedManyWithoutSupplierInput
    company: CompanyCreateNestedOneWithoutSuppliersInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    items?: SupplierItemUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SupplierItemUpdateManyWithoutSupplierNestedInput
    company?: CompanyUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    items?: SupplierItemUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierItemCreateInput = {
    id?: string
    supplierPrice?: number | null
    leadTime?: number | null
    isPreferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    item: InventoryItemCreateNestedOneWithoutSupplierItemsInput
    supplier: SupplierCreateNestedOneWithoutItemsInput
  }

  export type SupplierItemUncheckedCreateInput = {
    id?: string
    supplierPrice?: number | null
    leadTime?: number | null
    isPreferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId: string
    itemId: string
  }

  export type SupplierItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutSupplierItemsNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SupplierItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierItemCreateManyInput = {
    id?: string
    supplierPrice?: number | null
    leadTime?: number | null
    isPreferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId: string
    itemId: string
  }

  export type SupplierItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type GatePassCreateInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutGatePassesInput
    createdBy: UserCreateNestedOneWithoutGatePassesCreatedInput
    forUser?: UserCreateNestedOneWithoutGatePassesForInput
  }

  export type GatePassUncheckedCreateInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    createdById: string
    forUserId?: string | null
  }

  export type GatePassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutGatePassesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutGatePassesCreatedNestedInput
    forUser?: UserUpdateOneWithoutGatePassesForNestedInput
  }

  export type GatePassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    forUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GatePassCreateManyInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    createdById: string
    forUserId?: string | null
  }

  export type GatePassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GatePassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    forUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    documentType?: $Enums.DocumentType
    isConfidential?: boolean
    expiryDate?: Date | string | null
    tags?: DocumentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDocumentsInput
    uploadedBy: UserCreateNestedOneWithoutDocumentUploadsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    documentType?: $Enums.DocumentType
    isConfidential?: boolean
    expiryDate?: Date | string | null
    tags?: DocumentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    uploadedById: string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutDocumentUploadsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    documentType?: $Enums.DocumentType
    isConfidential?: boolean
    expiryDate?: Date | string | null
    tags?: DocumentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    uploadedById: string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceReviewCreateInput = {
    id?: string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    overallRating?: number | null
    goalsAchieved?: number | null
    punctualityScore?: number | null
    qualityScore?: number | null
    communicationScore?: number | null
    teamworkScore?: number | null
    comments?: string | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    reviewBy: UserCreateNestedOneWithoutReviewsGivenInput
    reviewFor: UserCreateNestedOneWithoutPerformanceReviewsInput
  }

  export type PerformanceReviewUncheckedCreateInput = {
    id?: string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    overallRating?: number | null
    goalsAchieved?: number | null
    punctualityScore?: number | null
    qualityScore?: number | null
    communicationScore?: number | null
    teamworkScore?: number | null
    comments?: string | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewForId: string
    reviewById: string
    companyId: string
  }

  export type PerformanceReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    goalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    punctualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    teamworkScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    reviewBy?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    reviewFor?: UserUpdateOneRequiredWithoutPerformanceReviewsNestedInput
  }

  export type PerformanceReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    goalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    punctualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    teamworkScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewForId?: StringFieldUpdateOperationsInput | string
    reviewById?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceReviewCreateManyInput = {
    id?: string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    overallRating?: number | null
    goalsAchieved?: number | null
    punctualityScore?: number | null
    qualityScore?: number | null
    communicationScore?: number | null
    teamworkScore?: number | null
    comments?: string | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewForId: string
    reviewById: string
    companyId: string
  }

  export type PerformanceReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    goalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    punctualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    teamworkScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    goalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    punctualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    teamworkScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewForId?: StringFieldUpdateOperationsInput | string
    reviewById?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: $Enums.AuditLogAction
    tableName: string
    recordId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    description?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAuditLogsInput
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: $Enums.AuditLogAction
    tableName: string
    recordId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    description?: string | null
    createdAt?: Date | string
    companyId: string
    userId: string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditLogActionFieldUpdateOperationsInput | $Enums.AuditLogAction
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditLogActionFieldUpdateOperationsInput | $Enums.AuditLogAction
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: $Enums.AuditLogAction
    tableName: string
    recordId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    description?: string | null
    createdAt?: Date | string
    companyId: string
    userId: string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditLogActionFieldUpdateOperationsInput | $Enums.AuditLogAction
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditLogActionFieldUpdateOperationsInput | $Enums.AuditLogAction
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CreditsRechargeCreateInput = {
    id?: string
    credits: number
    amountPaid: number
    transactionId?: string | null
    paymentMethod?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCreditsRechargesInput
    purchasedBy: UserCreateNestedOneWithoutCreditsRechargesInput
  }

  export type CreditsRechargeUncheckedCreateInput = {
    id?: string
    credits: number
    amountPaid: number
    transactionId?: string | null
    paymentMethod?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    purchasedById: string
  }

  export type CreditsRechargeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCreditsRechargesNestedInput
    purchasedBy?: UserUpdateOneRequiredWithoutCreditsRechargesNestedInput
  }

  export type CreditsRechargeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    purchasedById?: StringFieldUpdateOperationsInput | string
  }

  export type CreditsRechargeCreateManyInput = {
    id?: string
    credits: number
    amountPaid: number
    transactionId?: string | null
    paymentMethod?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    purchasedById: string
  }

  export type CreditsRechargeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditsRechargeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    purchasedById?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionHistoryCreateInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    numberOfDaysUsed?: number | null
    company: CompanyCreateNestedOneWithoutTransactionHistoryInput
    service?: ServiceCreateNestedOneWithoutTransactionsInput
    enabledBy?: UserCreateNestedOneWithoutEnabledServicesInput
  }

  export type TransactionHistoryUncheckedCreateInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    companyId: string
    serviceId?: string | null
    numberOfDaysUsed?: number | null
    enabledById?: string | null
  }

  export type TransactionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutTransactionHistoryNestedInput
    service?: ServiceUpdateOneWithoutTransactionsNestedInput
    enabledBy?: UserUpdateOneWithoutEnabledServicesNestedInput
  }

  export type TransactionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
    enabledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionHistoryCreateManyInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    companyId: string
    serviceId?: string | null
    numberOfDaysUsed?: number | null
    enabledById?: string | null
  }

  export type TransactionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
    enabledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TransactionHistoryListRelationFilter = {
    every?: TransactionHistoryWhereInput
    some?: TransactionHistoryWhereInput
    none?: TransactionHistoryWhereInput
  }

  export type UserCompanyListRelationFilter = {
    every?: UserCompanyWhereInput
    some?: UserCompanyWhereInput
    none?: UserCompanyWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type ChatMemberListRelationFilter = {
    every?: ChatMemberWhereInput
    some?: ChatMemberWhereInput
    none?: ChatMemberWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type GatePassListRelationFilter = {
    every?: GatePassWhereInput
    some?: GatePassWhereInput
    none?: GatePassWhereInput
  }

  export type LeaveListRelationFilter = {
    every?: LeaveWhereInput
    some?: LeaveWhereInput
    none?: LeaveWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type PerformanceReviewListRelationFilter = {
    every?: PerformanceReviewWhereInput
    some?: PerformanceReviewWhereInput
    none?: PerformanceReviewWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type CreditsRechargeListRelationFilter = {
    every?: CreditsRechargeWhereInput
    some?: CreditsRechargeWhereInput
    none?: CreditsRechargeWhereInput
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TransactionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GatePassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditsRechargeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    profileImage?: SortOrder
    employeeId?: SortOrder
    designation?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    dateOfJoining?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    emergencyContact?: SortOrder
    salary?: SortOrder
    workingHoursPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentId?: SortOrder
    managerId?: SortOrder
    Salary?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    salary?: SortOrder
    workingHoursPerDay?: SortOrder
    Salary?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    profileImage?: SortOrder
    employeeId?: SortOrder
    designation?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    dateOfJoining?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    emergencyContact?: SortOrder
    salary?: SortOrder
    workingHoursPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentId?: SortOrder
    managerId?: SortOrder
    Salary?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firebaseId?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    profileImage?: SortOrder
    employeeId?: SortOrder
    designation?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    dateOfJoining?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    emergencyContact?: SortOrder
    salary?: SortOrder
    workingHoursPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentId?: SortOrder
    managerId?: SortOrder
    Salary?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    salary?: SortOrder
    workingHoursPerDay?: SortOrder
    Salary?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type UserCompanyUserIdCompanyIdCompoundUniqueInput = {
    userId: string
    companyId: string
  }

  export type UserCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type WorkingDayListRelationFilter = {
    every?: WorkingDayWhereInput
    some?: WorkingDayWhereInput
    none?: WorkingDayWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkingDayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    industry?: SortOrder
    gstNumber?: SortOrder
    panNumber?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Country?: SortOrder
    totalCredits?: SortOrder
    usedCredits?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    totalCredits?: SortOrder
    usedCredits?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    industry?: SortOrder
    gstNumber?: SortOrder
    panNumber?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Country?: SortOrder
    totalCredits?: SortOrder
    usedCredits?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    industry?: SortOrder
    gstNumber?: SortOrder
    panNumber?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Country?: SortOrder
    totalCredits?: SortOrder
    usedCredits?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    totalCredits?: SortOrder
    usedCredits?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    headOfDeptId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    headOfDeptId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    headOfDeptId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceUserIdDateCompanyIdCompoundUniqueInput = {
    userId: string
    date: Date | string
    companyId: string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    clockInTime?: SortOrder
    clockOutTime?: SortOrder
    workingHours?: SortOrder
    overtimeHours?: SortOrder
    status?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    workingHours?: SortOrder
    overtimeHours?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    clockInTime?: SortOrder
    clockOutTime?: SortOrder
    workingHours?: SortOrder
    overtimeHours?: SortOrder
    status?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    clockInTime?: SortOrder
    clockOutTime?: SortOrder
    workingHours?: SortOrder
    overtimeHours?: SortOrder
    status?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    workingHours?: SortOrder
    overtimeHours?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type EnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type EnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type LeaveCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    appliedDate?: SortOrder
    approvedBy?: SortOrder
    rejectedBy?: SortOrder
    comments?: SortOrder
    totalDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type LeaveAvgOrderByAggregateInput = {
    totalDays?: SortOrder
  }

  export type LeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    appliedDate?: SortOrder
    approvedBy?: SortOrder
    rejectedBy?: SortOrder
    comments?: SortOrder
    totalDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type LeaveMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    leaveType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    appliedDate?: SortOrder
    approvedBy?: SortOrder
    rejectedBy?: SortOrder
    comments?: SortOrder
    totalDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type LeaveSumOrderByAggregateInput = {
    totalDays?: SortOrder
  }

  export type EnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type EnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type WorkingDayCompanyIdDayOfWeekCompoundUniqueInput = {
    companyId: string
    dayOfWeek: number
  }

  export type WorkingDayCountOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    isWorking?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type WorkingDayAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type WorkingDayMaxOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    isWorking?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type WorkingDayMinOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    isWorking?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type WorkingDaySumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type EnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    departmentId?: SortOrder
    companyId?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    progress?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    departmentId?: SortOrder
    companyId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    departmentId?: SortOrder
    companyId?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    progress?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type EnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type EnumChatTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatType | EnumChatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatType[] | ListEnumChatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatType[] | ListEnumChatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatTypeFilter<$PrismaModel> | $Enums.ChatType
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type EnumChatTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatType | EnumChatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatType[] | ListEnumChatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatType[] | ListEnumChatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChatType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatTypeFilter<$PrismaModel>
    _max?: NestedEnumChatTypeFilter<$PrismaModel>
  }

  export type ChatScalarRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type ChatMemberChatIdUserIdCompoundUniqueInput = {
    chatId: string
    userId: string
  }

  export type ChatMemberCountOrderByAggregateInput = {
    id?: SortOrder
    isAdmin?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
  }

  export type ChatMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    isAdmin?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
  }

  export type ChatMemberMinOrderByAggregateInput = {
    id?: SortOrder
    isAdmin?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    isPinned?: SortOrder
    replyTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    isPinned?: SortOrder
    replyTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    isPinned?: SortOrder
    replyTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type InventoryMovementListRelationFilter = {
    every?: InventoryMovementWhereInput
    some?: InventoryMovementWhereInput
    none?: InventoryMovementWhereInput
  }

  export type SupplierItemListRelationFilter = {
    every?: SupplierItemWhereInput
    some?: SupplierItemWhereInput
    none?: SupplierItemWhereInput
  }

  export type InventoryMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    currentStock?: SortOrder
    minimumStock?: SortOrder
    maximumStock?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    currentStock?: SortOrder
    minimumStock?: SortOrder
    maximumStock?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    currentStock?: SortOrder
    minimumStock?: SortOrder
    maximumStock?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    currentStock?: SortOrder
    minimumStock?: SortOrder
    maximumStock?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    currentStock?: SortOrder
    minimumStock?: SortOrder
    maximumStock?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
  }

  export type EnumInventoryMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMovementType | EnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryMovementTypeFilter<$PrismaModel> | $Enums.InventoryMovementType
  }

  export type InventoryItemScalarRelationFilter = {
    is?: InventoryItemWhereInput
    isNot?: InventoryItemWhereInput
  }

  export type InventoryMovementCountOrderByAggregateInput = {
    id?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    movedBy?: SortOrder
    createdAt?: SortOrder
    itemId?: SortOrder
  }

  export type InventoryMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type InventoryMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    movedBy?: SortOrder
    createdAt?: SortOrder
    itemId?: SortOrder
  }

  export type InventoryMovementMinOrderByAggregateInput = {
    id?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    movedBy?: SortOrder
    createdAt?: SortOrder
    itemId?: SortOrder
  }

  export type InventoryMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type EnumInventoryMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMovementType | EnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.InventoryMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumInventoryMovementTypeFilter<$PrismaModel>
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    gstNumber?: SortOrder
    panNumber?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    gstNumber?: SortOrder
    panNumber?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    gstNumber?: SortOrder
    panNumber?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type SupplierItemSupplierIdItemIdCompoundUniqueInput = {
    supplierId: string
    itemId: string
  }

  export type SupplierItemCountOrderByAggregateInput = {
    id?: SortOrder
    supplierPrice?: SortOrder
    leadTime?: SortOrder
    isPreferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
  }

  export type SupplierItemAvgOrderByAggregateInput = {
    supplierPrice?: SortOrder
    leadTime?: SortOrder
  }

  export type SupplierItemMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierPrice?: SortOrder
    leadTime?: SortOrder
    isPreferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
  }

  export type SupplierItemMinOrderByAggregateInput = {
    id?: SortOrder
    supplierPrice?: SortOrder
    leadTime?: SortOrder
    isPreferred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
  }

  export type SupplierItemSumOrderByAggregateInput = {
    supplierPrice?: SortOrder
    leadTime?: SortOrder
  }

  export type EnumGatePassTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GatePassType | EnumGatePassTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GatePassType[] | ListEnumGatePassTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatePassType[] | ListEnumGatePassTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGatePassTypeFilter<$PrismaModel> | $Enums.GatePassType
  }

  export type EnumGatePassStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GatePassStatus | EnumGatePassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GatePassStatus[] | ListEnumGatePassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatePassStatus[] | ListEnumGatePassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGatePassStatusFilter<$PrismaModel> | $Enums.GatePassStatus
  }

  export type GatePassCountOrderByAggregateInput = {
    id?: SortOrder
    passNumber?: SortOrder
    type?: SortOrder
    purpose?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    visitorCompany?: SortOrder
    vehicleNumber?: SortOrder
    itemsCarried?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    createdById?: SortOrder
    forUserId?: SortOrder
  }

  export type GatePassMaxOrderByAggregateInput = {
    id?: SortOrder
    passNumber?: SortOrder
    type?: SortOrder
    purpose?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    visitorCompany?: SortOrder
    vehicleNumber?: SortOrder
    itemsCarried?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    createdById?: SortOrder
    forUserId?: SortOrder
  }

  export type GatePassMinOrderByAggregateInput = {
    id?: SortOrder
    passNumber?: SortOrder
    type?: SortOrder
    purpose?: SortOrder
    visitorName?: SortOrder
    visitorPhone?: SortOrder
    visitorCompany?: SortOrder
    vehicleNumber?: SortOrder
    itemsCarried?: SortOrder
    entryTime?: SortOrder
    exitTime?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    createdById?: SortOrder
    forUserId?: SortOrder
  }

  export type EnumGatePassTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GatePassType | EnumGatePassTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GatePassType[] | ListEnumGatePassTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatePassType[] | ListEnumGatePassTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGatePassTypeWithAggregatesFilter<$PrismaModel> | $Enums.GatePassType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGatePassTypeFilter<$PrismaModel>
    _max?: NestedEnumGatePassTypeFilter<$PrismaModel>
  }

  export type EnumGatePassStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GatePassStatus | EnumGatePassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GatePassStatus[] | ListEnumGatePassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatePassStatus[] | ListEnumGatePassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGatePassStatusWithAggregatesFilter<$PrismaModel> | $Enums.GatePassStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGatePassStatusFilter<$PrismaModel>
    _max?: NestedEnumGatePassStatusFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    documentType?: SortOrder
    isConfidential?: SortOrder
    expiryDate?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    uploadedById?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    documentType?: SortOrder
    isConfidential?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    uploadedById?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    documentType?: SortOrder
    isConfidential?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    uploadedById?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type PerformanceReviewCountOrderByAggregateInput = {
    id?: SortOrder
    reviewPeriodStart?: SortOrder
    reviewPeriodEnd?: SortOrder
    overallRating?: SortOrder
    goalsAchieved?: SortOrder
    punctualityScore?: SortOrder
    qualityScore?: SortOrder
    communicationScore?: SortOrder
    teamworkScore?: SortOrder
    comments?: SortOrder
    goals?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewForId?: SortOrder
    reviewById?: SortOrder
    companyId?: SortOrder
  }

  export type PerformanceReviewAvgOrderByAggregateInput = {
    overallRating?: SortOrder
    goalsAchieved?: SortOrder
    punctualityScore?: SortOrder
    qualityScore?: SortOrder
    communicationScore?: SortOrder
    teamworkScore?: SortOrder
  }

  export type PerformanceReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewPeriodStart?: SortOrder
    reviewPeriodEnd?: SortOrder
    overallRating?: SortOrder
    goalsAchieved?: SortOrder
    punctualityScore?: SortOrder
    qualityScore?: SortOrder
    communicationScore?: SortOrder
    teamworkScore?: SortOrder
    comments?: SortOrder
    goals?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewForId?: SortOrder
    reviewById?: SortOrder
    companyId?: SortOrder
  }

  export type PerformanceReviewMinOrderByAggregateInput = {
    id?: SortOrder
    reviewPeriodStart?: SortOrder
    reviewPeriodEnd?: SortOrder
    overallRating?: SortOrder
    goalsAchieved?: SortOrder
    punctualityScore?: SortOrder
    qualityScore?: SortOrder
    communicationScore?: SortOrder
    teamworkScore?: SortOrder
    comments?: SortOrder
    goals?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewForId?: SortOrder
    reviewById?: SortOrder
    companyId?: SortOrder
  }

  export type PerformanceReviewSumOrderByAggregateInput = {
    overallRating?: SortOrder
    goalsAchieved?: SortOrder
    punctualityScore?: SortOrder
    qualityScore?: SortOrder
    communicationScore?: SortOrder
    teamworkScore?: SortOrder
  }

  export type EnumAuditLogActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditLogAction | EnumAuditLogActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditLogAction[] | ListEnumAuditLogActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditLogAction[] | ListEnumAuditLogActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditLogActionFilter<$PrismaModel> | $Enums.AuditLogAction
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
  }

  export type EnumAuditLogActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditLogAction | EnumAuditLogActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditLogAction[] | ListEnumAuditLogActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditLogAction[] | ListEnumAuditLogActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditLogActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditLogAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditLogActionFilter<$PrismaModel>
    _max?: NestedEnumAuditLogActionFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CreditsRechargeCountOrderByAggregateInput = {
    id?: SortOrder
    credits?: SortOrder
    amountPaid?: SortOrder
    transactionId?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    purchasedById?: SortOrder
  }

  export type CreditsRechargeAvgOrderByAggregateInput = {
    credits?: SortOrder
    amountPaid?: SortOrder
  }

  export type CreditsRechargeMaxOrderByAggregateInput = {
    id?: SortOrder
    credits?: SortOrder
    amountPaid?: SortOrder
    transactionId?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    purchasedById?: SortOrder
  }

  export type CreditsRechargeMinOrderByAggregateInput = {
    id?: SortOrder
    credits?: SortOrder
    amountPaid?: SortOrder
    transactionId?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    purchasedById?: SortOrder
  }

  export type CreditsRechargeSumOrderByAggregateInput = {
    credits?: SortOrder
    amountPaid?: SortOrder
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type TransactionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    creditsUsed?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrder
    numberOfDaysUsed?: SortOrder
    enabledById?: SortOrder
  }

  export type TransactionHistoryAvgOrderByAggregateInput = {
    creditsUsed?: SortOrder
    numberOfDaysUsed?: SortOrder
  }

  export type TransactionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    creditsUsed?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrder
    numberOfDaysUsed?: SortOrder
    enabledById?: SortOrder
  }

  export type TransactionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    creditsUsed?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrder
    numberOfDaysUsed?: SortOrder
    enabledById?: SortOrder
  }

  export type TransactionHistorySumOrderByAggregateInput = {
    creditsUsed?: SortOrder
    numberOfDaysUsed?: SortOrder
  }

  export type TransactionHistoryCreateNestedManyWithoutEnabledByInput = {
    create?: XOR<TransactionHistoryCreateWithoutEnabledByInput, TransactionHistoryUncheckedCreateWithoutEnabledByInput> | TransactionHistoryCreateWithoutEnabledByInput[] | TransactionHistoryUncheckedCreateWithoutEnabledByInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutEnabledByInput | TransactionHistoryCreateOrConnectWithoutEnabledByInput[]
    createMany?: TransactionHistoryCreateManyEnabledByInputEnvelope
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
  }

  export type UserCompanyCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput> | UserCompanyCreateWithoutUserInput[] | UserCompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutUserInput | UserCompanyCreateOrConnectWithoutUserInput[]
    createMany?: UserCompanyCreateManyUserInputEnvelope
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutHeadOfDeptInput = {
    create?: XOR<DepartmentCreateWithoutHeadOfDeptInput, DepartmentUncheckedCreateWithoutHeadOfDeptInput> | DepartmentCreateWithoutHeadOfDeptInput[] | DepartmentUncheckedCreateWithoutHeadOfDeptInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadOfDeptInput | DepartmentCreateOrConnectWithoutHeadOfDeptInput[]
    createMany?: DepartmentCreateManyHeadOfDeptInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ChatMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput> | ChatMemberCreateWithoutUserInput[] | ChatMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutUserInput | ChatMemberCreateOrConnectWithoutUserInput[]
    createMany?: ChatMemberCreateManyUserInputEnvelope
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type GatePassCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<GatePassCreateWithoutCreatedByInput, GatePassUncheckedCreateWithoutCreatedByInput> | GatePassCreateWithoutCreatedByInput[] | GatePassUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutCreatedByInput | GatePassCreateOrConnectWithoutCreatedByInput[]
    createMany?: GatePassCreateManyCreatedByInputEnvelope
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
  }

  export type GatePassCreateNestedManyWithoutForUserInput = {
    create?: XOR<GatePassCreateWithoutForUserInput, GatePassUncheckedCreateWithoutForUserInput> | GatePassCreateWithoutForUserInput[] | GatePassUncheckedCreateWithoutForUserInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutForUserInput | GatePassCreateOrConnectWithoutForUserInput[]
    createMany?: GatePassCreateManyForUserInputEnvelope
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PerformanceReviewCreateNestedManyWithoutReviewByInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewByInput, PerformanceReviewUncheckedCreateWithoutReviewByInput> | PerformanceReviewCreateWithoutReviewByInput[] | PerformanceReviewUncheckedCreateWithoutReviewByInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewByInput | PerformanceReviewCreateOrConnectWithoutReviewByInput[]
    createMany?: PerformanceReviewCreateManyReviewByInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type PerformanceReviewCreateNestedManyWithoutReviewForInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewForInput, PerformanceReviewUncheckedCreateWithoutReviewForInput> | PerformanceReviewCreateWithoutReviewForInput[] | PerformanceReviewUncheckedCreateWithoutReviewForInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewForInput | PerformanceReviewCreateOrConnectWithoutReviewForInput[]
    createMany?: PerformanceReviewCreateManyReviewForInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TaskCreateWithoutAssignedToInput, TaskUncheckedCreateWithoutAssignedToInput> | TaskCreateWithoutAssignedToInput[] | TaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedToInput | TaskCreateOrConnectWithoutAssignedToInput[]
    createMany?: TaskCreateManyAssignedToInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CreditsRechargeCreateNestedManyWithoutPurchasedByInput = {
    create?: XOR<CreditsRechargeCreateWithoutPurchasedByInput, CreditsRechargeUncheckedCreateWithoutPurchasedByInput> | CreditsRechargeCreateWithoutPurchasedByInput[] | CreditsRechargeUncheckedCreateWithoutPurchasedByInput[]
    connectOrCreate?: CreditsRechargeCreateOrConnectWithoutPurchasedByInput | CreditsRechargeCreateOrConnectWithoutPurchasedByInput[]
    createMany?: CreditsRechargeCreateManyPurchasedByInputEnvelope
    connect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutUsersInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSubordinatesInput = {
    create?: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubordinatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput = {
    create?: XOR<TransactionHistoryCreateWithoutEnabledByInput, TransactionHistoryUncheckedCreateWithoutEnabledByInput> | TransactionHistoryCreateWithoutEnabledByInput[] | TransactionHistoryUncheckedCreateWithoutEnabledByInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutEnabledByInput | TransactionHistoryCreateOrConnectWithoutEnabledByInput[]
    createMany?: TransactionHistoryCreateManyEnabledByInputEnvelope
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
  }

  export type UserCompanyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput> | UserCompanyCreateWithoutUserInput[] | UserCompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutUserInput | UserCompanyCreateOrConnectWithoutUserInput[]
    createMany?: UserCompanyCreateManyUserInputEnvelope
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput = {
    create?: XOR<DepartmentCreateWithoutHeadOfDeptInput, DepartmentUncheckedCreateWithoutHeadOfDeptInput> | DepartmentCreateWithoutHeadOfDeptInput[] | DepartmentUncheckedCreateWithoutHeadOfDeptInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadOfDeptInput | DepartmentCreateOrConnectWithoutHeadOfDeptInput[]
    createMany?: DepartmentCreateManyHeadOfDeptInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ChatMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput> | ChatMemberCreateWithoutUserInput[] | ChatMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutUserInput | ChatMemberCreateOrConnectWithoutUserInput[]
    createMany?: ChatMemberCreateManyUserInputEnvelope
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type GatePassUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<GatePassCreateWithoutCreatedByInput, GatePassUncheckedCreateWithoutCreatedByInput> | GatePassCreateWithoutCreatedByInput[] | GatePassUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutCreatedByInput | GatePassCreateOrConnectWithoutCreatedByInput[]
    createMany?: GatePassCreateManyCreatedByInputEnvelope
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
  }

  export type GatePassUncheckedCreateNestedManyWithoutForUserInput = {
    create?: XOR<GatePassCreateWithoutForUserInput, GatePassUncheckedCreateWithoutForUserInput> | GatePassCreateWithoutForUserInput[] | GatePassUncheckedCreateWithoutForUserInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutForUserInput | GatePassCreateOrConnectWithoutForUserInput[]
    createMany?: GatePassCreateManyForUserInputEnvelope
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewByInput, PerformanceReviewUncheckedCreateWithoutReviewByInput> | PerformanceReviewCreateWithoutReviewByInput[] | PerformanceReviewUncheckedCreateWithoutReviewByInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewByInput | PerformanceReviewCreateOrConnectWithoutReviewByInput[]
    createMany?: PerformanceReviewCreateManyReviewByInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewForInput, PerformanceReviewUncheckedCreateWithoutReviewForInput> | PerformanceReviewCreateWithoutReviewForInput[] | PerformanceReviewUncheckedCreateWithoutReviewForInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewForInput | PerformanceReviewCreateOrConnectWithoutReviewForInput[]
    createMany?: PerformanceReviewCreateManyReviewForInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TaskCreateWithoutAssignedToInput, TaskUncheckedCreateWithoutAssignedToInput> | TaskCreateWithoutAssignedToInput[] | TaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedToInput | TaskCreateOrConnectWithoutAssignedToInput[]
    createMany?: TaskCreateManyAssignedToInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput = {
    create?: XOR<CreditsRechargeCreateWithoutPurchasedByInput, CreditsRechargeUncheckedCreateWithoutPurchasedByInput> | CreditsRechargeCreateWithoutPurchasedByInput[] | CreditsRechargeUncheckedCreateWithoutPurchasedByInput[]
    connectOrCreate?: CreditsRechargeCreateOrConnectWithoutPurchasedByInput | CreditsRechargeCreateOrConnectWithoutPurchasedByInput[]
    createMany?: CreditsRechargeCreateManyPurchasedByInputEnvelope
    connect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TransactionHistoryUpdateManyWithoutEnabledByNestedInput = {
    create?: XOR<TransactionHistoryCreateWithoutEnabledByInput, TransactionHistoryUncheckedCreateWithoutEnabledByInput> | TransactionHistoryCreateWithoutEnabledByInput[] | TransactionHistoryUncheckedCreateWithoutEnabledByInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutEnabledByInput | TransactionHistoryCreateOrConnectWithoutEnabledByInput[]
    upsert?: TransactionHistoryUpsertWithWhereUniqueWithoutEnabledByInput | TransactionHistoryUpsertWithWhereUniqueWithoutEnabledByInput[]
    createMany?: TransactionHistoryCreateManyEnabledByInputEnvelope
    set?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    disconnect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    delete?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    update?: TransactionHistoryUpdateWithWhereUniqueWithoutEnabledByInput | TransactionHistoryUpdateWithWhereUniqueWithoutEnabledByInput[]
    updateMany?: TransactionHistoryUpdateManyWithWhereWithoutEnabledByInput | TransactionHistoryUpdateManyWithWhereWithoutEnabledByInput[]
    deleteMany?: TransactionHistoryScalarWhereInput | TransactionHistoryScalarWhereInput[]
  }

  export type UserCompanyUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput> | UserCompanyCreateWithoutUserInput[] | UserCompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutUserInput | UserCompanyCreateOrConnectWithoutUserInput[]
    upsert?: UserCompanyUpsertWithWhereUniqueWithoutUserInput | UserCompanyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCompanyCreateManyUserInputEnvelope
    set?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    disconnect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    delete?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    update?: UserCompanyUpdateWithWhereUniqueWithoutUserInput | UserCompanyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCompanyUpdateManyWithWhereWithoutUserInput | UserCompanyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutHeadOfDeptNestedInput = {
    create?: XOR<DepartmentCreateWithoutHeadOfDeptInput, DepartmentUncheckedCreateWithoutHeadOfDeptInput> | DepartmentCreateWithoutHeadOfDeptInput[] | DepartmentUncheckedCreateWithoutHeadOfDeptInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadOfDeptInput | DepartmentCreateOrConnectWithoutHeadOfDeptInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutHeadOfDeptInput | DepartmentUpsertWithWhereUniqueWithoutHeadOfDeptInput[]
    createMany?: DepartmentCreateManyHeadOfDeptInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutHeadOfDeptInput | DepartmentUpdateWithWhereUniqueWithoutHeadOfDeptInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutHeadOfDeptInput | DepartmentUpdateManyWithWhereWithoutHeadOfDeptInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ChatMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput> | ChatMemberCreateWithoutUserInput[] | ChatMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutUserInput | ChatMemberCreateOrConnectWithoutUserInput[]
    upsert?: ChatMemberUpsertWithWhereUniqueWithoutUserInput | ChatMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatMemberCreateManyUserInputEnvelope
    set?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    disconnect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    delete?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    update?: ChatMemberUpdateWithWhereUniqueWithoutUserInput | ChatMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatMemberUpdateManyWithWhereWithoutUserInput | ChatMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploadedByInput | DocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploadedByInput | DocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploadedByInput | DocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type GatePassUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<GatePassCreateWithoutCreatedByInput, GatePassUncheckedCreateWithoutCreatedByInput> | GatePassCreateWithoutCreatedByInput[] | GatePassUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutCreatedByInput | GatePassCreateOrConnectWithoutCreatedByInput[]
    upsert?: GatePassUpsertWithWhereUniqueWithoutCreatedByInput | GatePassUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: GatePassCreateManyCreatedByInputEnvelope
    set?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    disconnect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    delete?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    update?: GatePassUpdateWithWhereUniqueWithoutCreatedByInput | GatePassUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: GatePassUpdateManyWithWhereWithoutCreatedByInput | GatePassUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: GatePassScalarWhereInput | GatePassScalarWhereInput[]
  }

  export type GatePassUpdateManyWithoutForUserNestedInput = {
    create?: XOR<GatePassCreateWithoutForUserInput, GatePassUncheckedCreateWithoutForUserInput> | GatePassCreateWithoutForUserInput[] | GatePassUncheckedCreateWithoutForUserInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutForUserInput | GatePassCreateOrConnectWithoutForUserInput[]
    upsert?: GatePassUpsertWithWhereUniqueWithoutForUserInput | GatePassUpsertWithWhereUniqueWithoutForUserInput[]
    createMany?: GatePassCreateManyForUserInputEnvelope
    set?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    disconnect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    delete?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    update?: GatePassUpdateWithWhereUniqueWithoutForUserInput | GatePassUpdateWithWhereUniqueWithoutForUserInput[]
    updateMany?: GatePassUpdateManyWithWhereWithoutForUserInput | GatePassUpdateManyWithWhereWithoutForUserInput[]
    deleteMany?: GatePassScalarWhereInput | GatePassScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutUserInput | LeaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutUserInput | LeaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutUserInput | LeaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PerformanceReviewUpdateManyWithoutReviewByNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewByInput, PerformanceReviewUncheckedCreateWithoutReviewByInput> | PerformanceReviewCreateWithoutReviewByInput[] | PerformanceReviewUncheckedCreateWithoutReviewByInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewByInput | PerformanceReviewCreateOrConnectWithoutReviewByInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutReviewByInput | PerformanceReviewUpsertWithWhereUniqueWithoutReviewByInput[]
    createMany?: PerformanceReviewCreateManyReviewByInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutReviewByInput | PerformanceReviewUpdateWithWhereUniqueWithoutReviewByInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutReviewByInput | PerformanceReviewUpdateManyWithWhereWithoutReviewByInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type PerformanceReviewUpdateManyWithoutReviewForNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewForInput, PerformanceReviewUncheckedCreateWithoutReviewForInput> | PerformanceReviewCreateWithoutReviewForInput[] | PerformanceReviewUncheckedCreateWithoutReviewForInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewForInput | PerformanceReviewCreateOrConnectWithoutReviewForInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutReviewForInput | PerformanceReviewUpsertWithWhereUniqueWithoutReviewForInput[]
    createMany?: PerformanceReviewCreateManyReviewForInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutReviewForInput | PerformanceReviewUpdateWithWhereUniqueWithoutReviewForInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutReviewForInput | PerformanceReviewUpdateManyWithWhereWithoutReviewForInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TaskCreateWithoutAssignedToInput, TaskUncheckedCreateWithoutAssignedToInput> | TaskCreateWithoutAssignedToInput[] | TaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedToInput | TaskCreateOrConnectWithoutAssignedToInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssignedToInput | TaskUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TaskCreateManyAssignedToInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssignedToInput | TaskUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssignedToInput | TaskUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatedByInput | TaskUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatedByInput | TaskUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatedByInput | TaskUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CreditsRechargeUpdateManyWithoutPurchasedByNestedInput = {
    create?: XOR<CreditsRechargeCreateWithoutPurchasedByInput, CreditsRechargeUncheckedCreateWithoutPurchasedByInput> | CreditsRechargeCreateWithoutPurchasedByInput[] | CreditsRechargeUncheckedCreateWithoutPurchasedByInput[]
    connectOrCreate?: CreditsRechargeCreateOrConnectWithoutPurchasedByInput | CreditsRechargeCreateOrConnectWithoutPurchasedByInput[]
    upsert?: CreditsRechargeUpsertWithWhereUniqueWithoutPurchasedByInput | CreditsRechargeUpsertWithWhereUniqueWithoutPurchasedByInput[]
    createMany?: CreditsRechargeCreateManyPurchasedByInputEnvelope
    set?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    disconnect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    delete?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    connect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    update?: CreditsRechargeUpdateWithWhereUniqueWithoutPurchasedByInput | CreditsRechargeUpdateWithWhereUniqueWithoutPurchasedByInput[]
    updateMany?: CreditsRechargeUpdateManyWithWhereWithoutPurchasedByInput | CreditsRechargeUpdateManyWithWhereWithoutPurchasedByInput[]
    deleteMany?: CreditsRechargeScalarWhereInput | CreditsRechargeScalarWhereInput[]
  }

  export type DepartmentUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    upsert?: DepartmentUpsertWithoutUsersInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutUsersInput, DepartmentUpdateWithoutUsersInput>, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneWithoutSubordinatesNestedInput = {
    create?: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubordinatesInput
    upsert?: UserUpsertWithoutSubordinatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubordinatesInput, UserUpdateWithoutSubordinatesInput>, UserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type UserUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput = {
    create?: XOR<TransactionHistoryCreateWithoutEnabledByInput, TransactionHistoryUncheckedCreateWithoutEnabledByInput> | TransactionHistoryCreateWithoutEnabledByInput[] | TransactionHistoryUncheckedCreateWithoutEnabledByInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutEnabledByInput | TransactionHistoryCreateOrConnectWithoutEnabledByInput[]
    upsert?: TransactionHistoryUpsertWithWhereUniqueWithoutEnabledByInput | TransactionHistoryUpsertWithWhereUniqueWithoutEnabledByInput[]
    createMany?: TransactionHistoryCreateManyEnabledByInputEnvelope
    set?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    disconnect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    delete?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    update?: TransactionHistoryUpdateWithWhereUniqueWithoutEnabledByInput | TransactionHistoryUpdateWithWhereUniqueWithoutEnabledByInput[]
    updateMany?: TransactionHistoryUpdateManyWithWhereWithoutEnabledByInput | TransactionHistoryUpdateManyWithWhereWithoutEnabledByInput[]
    deleteMany?: TransactionHistoryScalarWhereInput | TransactionHistoryScalarWhereInput[]
  }

  export type UserCompanyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput> | UserCompanyCreateWithoutUserInput[] | UserCompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutUserInput | UserCompanyCreateOrConnectWithoutUserInput[]
    upsert?: UserCompanyUpsertWithWhereUniqueWithoutUserInput | UserCompanyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCompanyCreateManyUserInputEnvelope
    set?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    disconnect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    delete?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    update?: UserCompanyUpdateWithWhereUniqueWithoutUserInput | UserCompanyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCompanyUpdateManyWithWhereWithoutUserInput | UserCompanyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput = {
    create?: XOR<DepartmentCreateWithoutHeadOfDeptInput, DepartmentUncheckedCreateWithoutHeadOfDeptInput> | DepartmentCreateWithoutHeadOfDeptInput[] | DepartmentUncheckedCreateWithoutHeadOfDeptInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadOfDeptInput | DepartmentCreateOrConnectWithoutHeadOfDeptInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutHeadOfDeptInput | DepartmentUpsertWithWhereUniqueWithoutHeadOfDeptInput[]
    createMany?: DepartmentCreateManyHeadOfDeptInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutHeadOfDeptInput | DepartmentUpdateWithWhereUniqueWithoutHeadOfDeptInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutHeadOfDeptInput | DepartmentUpdateManyWithWhereWithoutHeadOfDeptInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ChatMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput> | ChatMemberCreateWithoutUserInput[] | ChatMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutUserInput | ChatMemberCreateOrConnectWithoutUserInput[]
    upsert?: ChatMemberUpsertWithWhereUniqueWithoutUserInput | ChatMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatMemberCreateManyUserInputEnvelope
    set?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    disconnect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    delete?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    update?: ChatMemberUpdateWithWhereUniqueWithoutUserInput | ChatMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatMemberUpdateManyWithWhereWithoutUserInput | ChatMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploadedByInput | DocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploadedByInput | DocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploadedByInput | DocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type GatePassUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<GatePassCreateWithoutCreatedByInput, GatePassUncheckedCreateWithoutCreatedByInput> | GatePassCreateWithoutCreatedByInput[] | GatePassUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutCreatedByInput | GatePassCreateOrConnectWithoutCreatedByInput[]
    upsert?: GatePassUpsertWithWhereUniqueWithoutCreatedByInput | GatePassUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: GatePassCreateManyCreatedByInputEnvelope
    set?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    disconnect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    delete?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    update?: GatePassUpdateWithWhereUniqueWithoutCreatedByInput | GatePassUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: GatePassUpdateManyWithWhereWithoutCreatedByInput | GatePassUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: GatePassScalarWhereInput | GatePassScalarWhereInput[]
  }

  export type GatePassUncheckedUpdateManyWithoutForUserNestedInput = {
    create?: XOR<GatePassCreateWithoutForUserInput, GatePassUncheckedCreateWithoutForUserInput> | GatePassCreateWithoutForUserInput[] | GatePassUncheckedCreateWithoutForUserInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutForUserInput | GatePassCreateOrConnectWithoutForUserInput[]
    upsert?: GatePassUpsertWithWhereUniqueWithoutForUserInput | GatePassUpsertWithWhereUniqueWithoutForUserInput[]
    createMany?: GatePassCreateManyForUserInputEnvelope
    set?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    disconnect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    delete?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    update?: GatePassUpdateWithWhereUniqueWithoutForUserInput | GatePassUpdateWithWhereUniqueWithoutForUserInput[]
    updateMany?: GatePassUpdateManyWithWhereWithoutForUserInput | GatePassUpdateManyWithWhereWithoutForUserInput[]
    deleteMany?: GatePassScalarWhereInput | GatePassScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutUserInput | LeaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutUserInput | LeaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutUserInput | LeaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewByInput, PerformanceReviewUncheckedCreateWithoutReviewByInput> | PerformanceReviewCreateWithoutReviewByInput[] | PerformanceReviewUncheckedCreateWithoutReviewByInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewByInput | PerformanceReviewCreateOrConnectWithoutReviewByInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutReviewByInput | PerformanceReviewUpsertWithWhereUniqueWithoutReviewByInput[]
    createMany?: PerformanceReviewCreateManyReviewByInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutReviewByInput | PerformanceReviewUpdateWithWhereUniqueWithoutReviewByInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutReviewByInput | PerformanceReviewUpdateManyWithWhereWithoutReviewByInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutReviewForInput, PerformanceReviewUncheckedCreateWithoutReviewForInput> | PerformanceReviewCreateWithoutReviewForInput[] | PerformanceReviewUncheckedCreateWithoutReviewForInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutReviewForInput | PerformanceReviewCreateOrConnectWithoutReviewForInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutReviewForInput | PerformanceReviewUpsertWithWhereUniqueWithoutReviewForInput[]
    createMany?: PerformanceReviewCreateManyReviewForInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutReviewForInput | PerformanceReviewUpdateWithWhereUniqueWithoutReviewForInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutReviewForInput | PerformanceReviewUpdateManyWithWhereWithoutReviewForInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TaskCreateWithoutAssignedToInput, TaskUncheckedCreateWithoutAssignedToInput> | TaskCreateWithoutAssignedToInput[] | TaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedToInput | TaskCreateOrConnectWithoutAssignedToInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssignedToInput | TaskUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TaskCreateManyAssignedToInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssignedToInput | TaskUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssignedToInput | TaskUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput> | TaskCreateWithoutCreatedByInput[] | TaskUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatedByInput | TaskCreateOrConnectWithoutCreatedByInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatedByInput | TaskUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TaskCreateManyCreatedByInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatedByInput | TaskUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatedByInput | TaskUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput = {
    create?: XOR<CreditsRechargeCreateWithoutPurchasedByInput, CreditsRechargeUncheckedCreateWithoutPurchasedByInput> | CreditsRechargeCreateWithoutPurchasedByInput[] | CreditsRechargeUncheckedCreateWithoutPurchasedByInput[]
    connectOrCreate?: CreditsRechargeCreateOrConnectWithoutPurchasedByInput | CreditsRechargeCreateOrConnectWithoutPurchasedByInput[]
    upsert?: CreditsRechargeUpsertWithWhereUniqueWithoutPurchasedByInput | CreditsRechargeUpsertWithWhereUniqueWithoutPurchasedByInput[]
    createMany?: CreditsRechargeCreateManyPurchasedByInputEnvelope
    set?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    disconnect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    delete?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    connect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    update?: CreditsRechargeUpdateWithWhereUniqueWithoutPurchasedByInput | CreditsRechargeUpdateWithWhereUniqueWithoutPurchasedByInput[]
    updateMany?: CreditsRechargeUpdateManyWithWhereWithoutPurchasedByInput | CreditsRechargeUpdateManyWithWhereWithoutPurchasedByInput[]
    deleteMany?: CreditsRechargeScalarWhereInput | CreditsRechargeScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserCompaniesInput = {
    create?: XOR<UserCreateWithoutUserCompaniesInput, UserUncheckedCreateWithoutUserCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCompaniesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutUserCompaniesInput = {
    create?: XOR<CompanyCreateWithoutUserCompaniesInput, CompanyUncheckedCreateWithoutUserCompaniesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserCompaniesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserCompaniesNestedInput = {
    create?: XOR<UserCreateWithoutUserCompaniesInput, UserUncheckedCreateWithoutUserCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCompaniesInput
    upsert?: UserUpsertWithoutUserCompaniesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserCompaniesInput, UserUpdateWithoutUserCompaniesInput>, UserUncheckedUpdateWithoutUserCompaniesInput>
  }

  export type CompanyUpdateOneRequiredWithoutUserCompaniesNestedInput = {
    create?: XOR<CompanyCreateWithoutUserCompaniesInput, CompanyUncheckedCreateWithoutUserCompaniesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserCompaniesInput
    upsert?: CompanyUpsertWithoutUserCompaniesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUserCompaniesInput, CompanyUpdateWithoutUserCompaniesInput>, CompanyUncheckedUpdateWithoutUserCompaniesInput>
  }

  export type UserCompanyCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput> | UserCompanyCreateWithoutCompanyInput[] | UserCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutCompanyInput | UserCompanyCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCompanyCreateManyCompanyInputEnvelope
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ServiceCreateWithoutCompanyInput, ServiceUncheckedCreateWithoutCompanyInput> | ServiceCreateWithoutCompanyInput[] | ServiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCompanyInput | ServiceCreateOrConnectWithoutCompanyInput[]
    createMany?: ServiceCreateManyCompanyInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput> | ChatCreateWithoutCompanyInput[] | ChatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutCompanyInput | ChatCreateOrConnectWithoutCompanyInput[]
    createMany?: ChatCreateManyCompanyInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type GatePassCreateNestedManyWithoutCompanyInput = {
    create?: XOR<GatePassCreateWithoutCompanyInput, GatePassUncheckedCreateWithoutCompanyInput> | GatePassCreateWithoutCompanyInput[] | GatePassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutCompanyInput | GatePassCreateOrConnectWithoutCompanyInput[]
    createMany?: GatePassCreateManyCompanyInputEnvelope
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InventoryItemCreateWithoutCompanyInput, InventoryItemUncheckedCreateWithoutCompanyInput> | InventoryItemCreateWithoutCompanyInput[] | InventoryItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutCompanyInput | InventoryItemCreateOrConnectWithoutCompanyInput[]
    createMany?: InventoryItemCreateManyCompanyInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput> | SupplierCreateWithoutCompanyInput[] | SupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCompanyInput | SupplierCreateOrConnectWithoutCompanyInput[]
    createMany?: SupplierCreateManyCompanyInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type WorkingDayCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WorkingDayCreateWithoutCompanyInput, WorkingDayUncheckedCreateWithoutCompanyInput> | WorkingDayCreateWithoutCompanyInput[] | WorkingDayUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkingDayCreateOrConnectWithoutCompanyInput | WorkingDayCreateOrConnectWithoutCompanyInput[]
    createMany?: WorkingDayCreateManyCompanyInputEnvelope
    connect?: WorkingDayWhereUniqueInput | WorkingDayWhereUniqueInput[]
  }

  export type CreditsRechargeCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CreditsRechargeCreateWithoutCompanyInput, CreditsRechargeUncheckedCreateWithoutCompanyInput> | CreditsRechargeCreateWithoutCompanyInput[] | CreditsRechargeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CreditsRechargeCreateOrConnectWithoutCompanyInput | CreditsRechargeCreateOrConnectWithoutCompanyInput[]
    createMany?: CreditsRechargeCreateManyCompanyInputEnvelope
    connect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
  }

  export type TransactionHistoryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TransactionHistoryCreateWithoutCompanyInput, TransactionHistoryUncheckedCreateWithoutCompanyInput> | TransactionHistoryCreateWithoutCompanyInput[] | TransactionHistoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutCompanyInput | TransactionHistoryCreateOrConnectWithoutCompanyInput[]
    createMany?: TransactionHistoryCreateManyCompanyInputEnvelope
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
  }

  export type UserCompanyUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput> | UserCompanyCreateWithoutCompanyInput[] | UserCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutCompanyInput | UserCompanyCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCompanyCreateManyCompanyInputEnvelope
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ServiceCreateWithoutCompanyInput, ServiceUncheckedCreateWithoutCompanyInput> | ServiceCreateWithoutCompanyInput[] | ServiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCompanyInput | ServiceCreateOrConnectWithoutCompanyInput[]
    createMany?: ServiceCreateManyCompanyInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput> | ChatCreateWithoutCompanyInput[] | ChatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutCompanyInput | ChatCreateOrConnectWithoutCompanyInput[]
    createMany?: ChatCreateManyCompanyInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type GatePassUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<GatePassCreateWithoutCompanyInput, GatePassUncheckedCreateWithoutCompanyInput> | GatePassCreateWithoutCompanyInput[] | GatePassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutCompanyInput | GatePassCreateOrConnectWithoutCompanyInput[]
    createMany?: GatePassCreateManyCompanyInputEnvelope
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InventoryItemCreateWithoutCompanyInput, InventoryItemUncheckedCreateWithoutCompanyInput> | InventoryItemCreateWithoutCompanyInput[] | InventoryItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutCompanyInput | InventoryItemCreateOrConnectWithoutCompanyInput[]
    createMany?: InventoryItemCreateManyCompanyInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput> | SupplierCreateWithoutCompanyInput[] | SupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCompanyInput | SupplierCreateOrConnectWithoutCompanyInput[]
    createMany?: SupplierCreateManyCompanyInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type WorkingDayUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WorkingDayCreateWithoutCompanyInput, WorkingDayUncheckedCreateWithoutCompanyInput> | WorkingDayCreateWithoutCompanyInput[] | WorkingDayUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkingDayCreateOrConnectWithoutCompanyInput | WorkingDayCreateOrConnectWithoutCompanyInput[]
    createMany?: WorkingDayCreateManyCompanyInputEnvelope
    connect?: WorkingDayWhereUniqueInput | WorkingDayWhereUniqueInput[]
  }

  export type CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CreditsRechargeCreateWithoutCompanyInput, CreditsRechargeUncheckedCreateWithoutCompanyInput> | CreditsRechargeCreateWithoutCompanyInput[] | CreditsRechargeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CreditsRechargeCreateOrConnectWithoutCompanyInput | CreditsRechargeCreateOrConnectWithoutCompanyInput[]
    createMany?: CreditsRechargeCreateManyCompanyInputEnvelope
    connect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
  }

  export type TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TransactionHistoryCreateWithoutCompanyInput, TransactionHistoryUncheckedCreateWithoutCompanyInput> | TransactionHistoryCreateWithoutCompanyInput[] | TransactionHistoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutCompanyInput | TransactionHistoryCreateOrConnectWithoutCompanyInput[]
    createMany?: TransactionHistoryCreateManyCompanyInputEnvelope
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCompanyUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput> | UserCompanyCreateWithoutCompanyInput[] | UserCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutCompanyInput | UserCompanyCreateOrConnectWithoutCompanyInput[]
    upsert?: UserCompanyUpsertWithWhereUniqueWithoutCompanyInput | UserCompanyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCompanyCreateManyCompanyInputEnvelope
    set?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    disconnect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    delete?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    update?: UserCompanyUpdateWithWhereUniqueWithoutCompanyInput | UserCompanyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserCompanyUpdateManyWithWhereWithoutCompanyInput | UserCompanyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ServiceCreateWithoutCompanyInput, ServiceUncheckedCreateWithoutCompanyInput> | ServiceCreateWithoutCompanyInput[] | ServiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCompanyInput | ServiceCreateOrConnectWithoutCompanyInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCompanyInput | ServiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ServiceCreateManyCompanyInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCompanyInput | ServiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCompanyInput | ServiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput> | ChatCreateWithoutCompanyInput[] | ChatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutCompanyInput | ChatCreateOrConnectWithoutCompanyInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutCompanyInput | ChatUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ChatCreateManyCompanyInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutCompanyInput | ChatUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutCompanyInput | ChatUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutCompanyInput | DepartmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutCompanyInput | DepartmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutCompanyInput | DepartmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCompanyInput | DocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCompanyInput | DocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCompanyInput | DocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type GatePassUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<GatePassCreateWithoutCompanyInput, GatePassUncheckedCreateWithoutCompanyInput> | GatePassCreateWithoutCompanyInput[] | GatePassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutCompanyInput | GatePassCreateOrConnectWithoutCompanyInput[]
    upsert?: GatePassUpsertWithWhereUniqueWithoutCompanyInput | GatePassUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: GatePassCreateManyCompanyInputEnvelope
    set?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    disconnect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    delete?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    update?: GatePassUpdateWithWhereUniqueWithoutCompanyInput | GatePassUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: GatePassUpdateManyWithWhereWithoutCompanyInput | GatePassUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: GatePassScalarWhereInput | GatePassScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InventoryItemCreateWithoutCompanyInput, InventoryItemUncheckedCreateWithoutCompanyInput> | InventoryItemCreateWithoutCompanyInput[] | InventoryItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutCompanyInput | InventoryItemCreateOrConnectWithoutCompanyInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutCompanyInput | InventoryItemUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InventoryItemCreateManyCompanyInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutCompanyInput | InventoryItemUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutCompanyInput | InventoryItemUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput> | SupplierCreateWithoutCompanyInput[] | SupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCompanyInput | SupplierCreateOrConnectWithoutCompanyInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutCompanyInput | SupplierUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SupplierCreateManyCompanyInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutCompanyInput | SupplierUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutCompanyInput | SupplierUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type WorkingDayUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WorkingDayCreateWithoutCompanyInput, WorkingDayUncheckedCreateWithoutCompanyInput> | WorkingDayCreateWithoutCompanyInput[] | WorkingDayUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkingDayCreateOrConnectWithoutCompanyInput | WorkingDayCreateOrConnectWithoutCompanyInput[]
    upsert?: WorkingDayUpsertWithWhereUniqueWithoutCompanyInput | WorkingDayUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WorkingDayCreateManyCompanyInputEnvelope
    set?: WorkingDayWhereUniqueInput | WorkingDayWhereUniqueInput[]
    disconnect?: WorkingDayWhereUniqueInput | WorkingDayWhereUniqueInput[]
    delete?: WorkingDayWhereUniqueInput | WorkingDayWhereUniqueInput[]
    connect?: WorkingDayWhereUniqueInput | WorkingDayWhereUniqueInput[]
    update?: WorkingDayUpdateWithWhereUniqueWithoutCompanyInput | WorkingDayUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WorkingDayUpdateManyWithWhereWithoutCompanyInput | WorkingDayUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WorkingDayScalarWhereInput | WorkingDayScalarWhereInput[]
  }

  export type CreditsRechargeUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CreditsRechargeCreateWithoutCompanyInput, CreditsRechargeUncheckedCreateWithoutCompanyInput> | CreditsRechargeCreateWithoutCompanyInput[] | CreditsRechargeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CreditsRechargeCreateOrConnectWithoutCompanyInput | CreditsRechargeCreateOrConnectWithoutCompanyInput[]
    upsert?: CreditsRechargeUpsertWithWhereUniqueWithoutCompanyInput | CreditsRechargeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CreditsRechargeCreateManyCompanyInputEnvelope
    set?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    disconnect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    delete?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    connect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    update?: CreditsRechargeUpdateWithWhereUniqueWithoutCompanyInput | CreditsRechargeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CreditsRechargeUpdateManyWithWhereWithoutCompanyInput | CreditsRechargeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CreditsRechargeScalarWhereInput | CreditsRechargeScalarWhereInput[]
  }

  export type TransactionHistoryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TransactionHistoryCreateWithoutCompanyInput, TransactionHistoryUncheckedCreateWithoutCompanyInput> | TransactionHistoryCreateWithoutCompanyInput[] | TransactionHistoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutCompanyInput | TransactionHistoryCreateOrConnectWithoutCompanyInput[]
    upsert?: TransactionHistoryUpsertWithWhereUniqueWithoutCompanyInput | TransactionHistoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TransactionHistoryCreateManyCompanyInputEnvelope
    set?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    disconnect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    delete?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    update?: TransactionHistoryUpdateWithWhereUniqueWithoutCompanyInput | TransactionHistoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TransactionHistoryUpdateManyWithWhereWithoutCompanyInput | TransactionHistoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TransactionHistoryScalarWhereInput | TransactionHistoryScalarWhereInput[]
  }

  export type UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput> | UserCompanyCreateWithoutCompanyInput[] | UserCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutCompanyInput | UserCompanyCreateOrConnectWithoutCompanyInput[]
    upsert?: UserCompanyUpsertWithWhereUniqueWithoutCompanyInput | UserCompanyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCompanyCreateManyCompanyInputEnvelope
    set?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    disconnect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    delete?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    update?: UserCompanyUpdateWithWhereUniqueWithoutCompanyInput | UserCompanyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserCompanyUpdateManyWithWhereWithoutCompanyInput | UserCompanyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ServiceCreateWithoutCompanyInput, ServiceUncheckedCreateWithoutCompanyInput> | ServiceCreateWithoutCompanyInput[] | ServiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCompanyInput | ServiceCreateOrConnectWithoutCompanyInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCompanyInput | ServiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ServiceCreateManyCompanyInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCompanyInput | ServiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCompanyInput | ServiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput> | ChatCreateWithoutCompanyInput[] | ChatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutCompanyInput | ChatCreateOrConnectWithoutCompanyInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutCompanyInput | ChatUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ChatCreateManyCompanyInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutCompanyInput | ChatUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutCompanyInput | ChatUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutCompanyInput | DepartmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutCompanyInput | DepartmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutCompanyInput | DepartmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCompanyInput | DocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCompanyInput | DocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCompanyInput | DocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type GatePassUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<GatePassCreateWithoutCompanyInput, GatePassUncheckedCreateWithoutCompanyInput> | GatePassCreateWithoutCompanyInput[] | GatePassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GatePassCreateOrConnectWithoutCompanyInput | GatePassCreateOrConnectWithoutCompanyInput[]
    upsert?: GatePassUpsertWithWhereUniqueWithoutCompanyInput | GatePassUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: GatePassCreateManyCompanyInputEnvelope
    set?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    disconnect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    delete?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    connect?: GatePassWhereUniqueInput | GatePassWhereUniqueInput[]
    update?: GatePassUpdateWithWhereUniqueWithoutCompanyInput | GatePassUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: GatePassUpdateManyWithWhereWithoutCompanyInput | GatePassUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: GatePassScalarWhereInput | GatePassScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InventoryItemCreateWithoutCompanyInput, InventoryItemUncheckedCreateWithoutCompanyInput> | InventoryItemCreateWithoutCompanyInput[] | InventoryItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutCompanyInput | InventoryItemCreateOrConnectWithoutCompanyInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutCompanyInput | InventoryItemUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InventoryItemCreateManyCompanyInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutCompanyInput | InventoryItemUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutCompanyInput | InventoryItemUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput> | SupplierCreateWithoutCompanyInput[] | SupplierUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCompanyInput | SupplierCreateOrConnectWithoutCompanyInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutCompanyInput | SupplierUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SupplierCreateManyCompanyInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutCompanyInput | SupplierUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutCompanyInput | SupplierUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WorkingDayCreateWithoutCompanyInput, WorkingDayUncheckedCreateWithoutCompanyInput> | WorkingDayCreateWithoutCompanyInput[] | WorkingDayUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkingDayCreateOrConnectWithoutCompanyInput | WorkingDayCreateOrConnectWithoutCompanyInput[]
    upsert?: WorkingDayUpsertWithWhereUniqueWithoutCompanyInput | WorkingDayUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WorkingDayCreateManyCompanyInputEnvelope
    set?: WorkingDayWhereUniqueInput | WorkingDayWhereUniqueInput[]
    disconnect?: WorkingDayWhereUniqueInput | WorkingDayWhereUniqueInput[]
    delete?: WorkingDayWhereUniqueInput | WorkingDayWhereUniqueInput[]
    connect?: WorkingDayWhereUniqueInput | WorkingDayWhereUniqueInput[]
    update?: WorkingDayUpdateWithWhereUniqueWithoutCompanyInput | WorkingDayUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WorkingDayUpdateManyWithWhereWithoutCompanyInput | WorkingDayUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WorkingDayScalarWhereInput | WorkingDayScalarWhereInput[]
  }

  export type CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CreditsRechargeCreateWithoutCompanyInput, CreditsRechargeUncheckedCreateWithoutCompanyInput> | CreditsRechargeCreateWithoutCompanyInput[] | CreditsRechargeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CreditsRechargeCreateOrConnectWithoutCompanyInput | CreditsRechargeCreateOrConnectWithoutCompanyInput[]
    upsert?: CreditsRechargeUpsertWithWhereUniqueWithoutCompanyInput | CreditsRechargeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CreditsRechargeCreateManyCompanyInputEnvelope
    set?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    disconnect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    delete?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    connect?: CreditsRechargeWhereUniqueInput | CreditsRechargeWhereUniqueInput[]
    update?: CreditsRechargeUpdateWithWhereUniqueWithoutCompanyInput | CreditsRechargeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CreditsRechargeUpdateManyWithWhereWithoutCompanyInput | CreditsRechargeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CreditsRechargeScalarWhereInput | CreditsRechargeScalarWhereInput[]
  }

  export type TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TransactionHistoryCreateWithoutCompanyInput, TransactionHistoryUncheckedCreateWithoutCompanyInput> | TransactionHistoryCreateWithoutCompanyInput[] | TransactionHistoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutCompanyInput | TransactionHistoryCreateOrConnectWithoutCompanyInput[]
    upsert?: TransactionHistoryUpsertWithWhereUniqueWithoutCompanyInput | TransactionHistoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TransactionHistoryCreateManyCompanyInputEnvelope
    set?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    disconnect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    delete?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    update?: TransactionHistoryUpdateWithWhereUniqueWithoutCompanyInput | TransactionHistoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TransactionHistoryUpdateManyWithWhereWithoutCompanyInput | TransactionHistoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TransactionHistoryScalarWhereInput | TransactionHistoryScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutServicesInput = {
    create?: XOR<CompanyCreateWithoutServicesInput, CompanyUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutServicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type TransactionHistoryCreateNestedManyWithoutServiceInput = {
    create?: XOR<TransactionHistoryCreateWithoutServiceInput, TransactionHistoryUncheckedCreateWithoutServiceInput> | TransactionHistoryCreateWithoutServiceInput[] | TransactionHistoryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutServiceInput | TransactionHistoryCreateOrConnectWithoutServiceInput[]
    createMany?: TransactionHistoryCreateManyServiceInputEnvelope
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
  }

  export type TransactionHistoryUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<TransactionHistoryCreateWithoutServiceInput, TransactionHistoryUncheckedCreateWithoutServiceInput> | TransactionHistoryCreateWithoutServiceInput[] | TransactionHistoryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutServiceInput | TransactionHistoryCreateOrConnectWithoutServiceInput[]
    createMany?: TransactionHistoryCreateManyServiceInputEnvelope
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<CompanyCreateWithoutServicesInput, CompanyUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutServicesInput
    upsert?: CompanyUpsertWithoutServicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutServicesInput, CompanyUpdateWithoutServicesInput>, CompanyUncheckedUpdateWithoutServicesInput>
  }

  export type TransactionHistoryUpdateManyWithoutServiceNestedInput = {
    create?: XOR<TransactionHistoryCreateWithoutServiceInput, TransactionHistoryUncheckedCreateWithoutServiceInput> | TransactionHistoryCreateWithoutServiceInput[] | TransactionHistoryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutServiceInput | TransactionHistoryCreateOrConnectWithoutServiceInput[]
    upsert?: TransactionHistoryUpsertWithWhereUniqueWithoutServiceInput | TransactionHistoryUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: TransactionHistoryCreateManyServiceInputEnvelope
    set?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    disconnect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    delete?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    update?: TransactionHistoryUpdateWithWhereUniqueWithoutServiceInput | TransactionHistoryUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: TransactionHistoryUpdateManyWithWhereWithoutServiceInput | TransactionHistoryUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: TransactionHistoryScalarWhereInput | TransactionHistoryScalarWhereInput[]
  }

  export type TransactionHistoryUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<TransactionHistoryCreateWithoutServiceInput, TransactionHistoryUncheckedCreateWithoutServiceInput> | TransactionHistoryCreateWithoutServiceInput[] | TransactionHistoryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TransactionHistoryCreateOrConnectWithoutServiceInput | TransactionHistoryCreateOrConnectWithoutServiceInput[]
    upsert?: TransactionHistoryUpsertWithWhereUniqueWithoutServiceInput | TransactionHistoryUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: TransactionHistoryCreateManyServiceInputEnvelope
    set?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    disconnect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    delete?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    connect?: TransactionHistoryWhereUniqueInput | TransactionHistoryWhereUniqueInput[]
    update?: TransactionHistoryUpdateWithWhereUniqueWithoutServiceInput | TransactionHistoryUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: TransactionHistoryUpdateManyWithWhereWithoutServiceInput | TransactionHistoryUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: TransactionHistoryScalarWhereInput | TransactionHistoryScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDepartmentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHeadedDepartmentsInput = {
    create?: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHeadedDepartmentsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput> | TaskCreateWithoutDepartmentInput[] | TaskUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDepartmentInput | TaskCreateOrConnectWithoutDepartmentInput[]
    createMany?: TaskCreateManyDepartmentInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput> | TaskCreateWithoutDepartmentInput[] | TaskUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDepartmentInput | TaskCreateOrConnectWithoutDepartmentInput[]
    createMany?: TaskCreateManyDepartmentInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDepartmentsInput
    upsert?: CompanyUpsertWithoutDepartmentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDepartmentsInput, CompanyUpdateWithoutDepartmentsInput>, CompanyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type UserUpdateOneWithoutHeadedDepartmentsNestedInput = {
    create?: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHeadedDepartmentsInput
    upsert?: UserUpsertWithoutHeadedDepartmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHeadedDepartmentsInput, UserUpdateWithoutHeadedDepartmentsInput>, UserUncheckedUpdateWithoutHeadedDepartmentsInput>
  }

  export type TaskUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput> | TaskCreateWithoutDepartmentInput[] | TaskUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDepartmentInput | TaskCreateOrConnectWithoutDepartmentInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutDepartmentInput | TaskUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TaskCreateManyDepartmentInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutDepartmentInput | TaskUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutDepartmentInput | TaskUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput> | TaskCreateWithoutDepartmentInput[] | TaskUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDepartmentInput | TaskCreateOrConnectWithoutDepartmentInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutDepartmentInput | TaskUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TaskCreateManyDepartmentInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutDepartmentInput | TaskUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutDepartmentInput | TaskUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type UserUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    upsert?: UserUpsertWithoutAttendancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendancesInput, UserUpdateWithoutAttendancesInput>, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserCreateNestedOneWithoutLeavesInput = {
    create?: XOR<UserCreateWithoutLeavesInput, UserUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeavesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLeaveTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeaveType
  }

  export type EnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<UserCreateWithoutLeavesInput, UserUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeavesInput
    upsert?: UserUpsertWithoutLeavesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeavesInput, UserUpdateWithoutLeavesInput>, UserUncheckedUpdateWithoutLeavesInput>
  }

  export type CompanyCreateNestedOneWithoutWorkingDaysInput = {
    create?: XOR<CompanyCreateWithoutWorkingDaysInput, CompanyUncheckedCreateWithoutWorkingDaysInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWorkingDaysInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutWorkingDaysNestedInput = {
    create?: XOR<CompanyCreateWithoutWorkingDaysInput, CompanyUncheckedCreateWithoutWorkingDaysInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWorkingDaysInput
    upsert?: CompanyUpsertWithoutWorkingDaysInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWorkingDaysInput, CompanyUpdateWithoutWorkingDaysInput>, CompanyUncheckedUpdateWithoutWorkingDaysInput>
  }

  export type UserCreateNestedOneWithoutTasksAssignedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksCreatedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutTasksInput = {
    create?: XOR<DepartmentCreateWithoutTasksInput, DepartmentUncheckedCreateWithoutTasksInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTasksInput
    connect?: DepartmentWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type EnumTaskPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TaskPriority
  }

  export type UserUpdateOneRequiredWithoutTasksAssignedNestedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    upsert?: UserUpsertWithoutTasksAssignedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksAssignedInput, UserUpdateWithoutTasksAssignedInput>, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type UserUpdateOneRequiredWithoutTasksCreatedNestedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    upsert?: UserUpsertWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksCreatedInput, UserUpdateWithoutTasksCreatedInput>, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type DepartmentUpdateOneWithoutTasksNestedInput = {
    create?: XOR<DepartmentCreateWithoutTasksInput, DepartmentUncheckedCreateWithoutTasksInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTasksInput
    upsert?: DepartmentUpsertWithoutTasksInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutTasksInput, DepartmentUpdateWithoutTasksInput>, DepartmentUncheckedUpdateWithoutTasksInput>
  }

  export type ChatMemberCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput> | ChatMemberCreateWithoutChatInput[] | ChatMemberUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutChatInput | ChatMemberCreateOrConnectWithoutChatInput[]
    createMany?: ChatMemberCreateManyChatInputEnvelope
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutChatsInput = {
    create?: XOR<CompanyCreateWithoutChatsInput, CompanyUncheckedCreateWithoutChatsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutChatsInput
    connect?: CompanyWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChatMemberUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput> | ChatMemberCreateWithoutChatInput[] | ChatMemberUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutChatInput | ChatMemberCreateOrConnectWithoutChatInput[]
    createMany?: ChatMemberCreateManyChatInputEnvelope
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EnumChatTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChatType
  }

  export type ChatMemberUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput> | ChatMemberCreateWithoutChatInput[] | ChatMemberUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutChatInput | ChatMemberCreateOrConnectWithoutChatInput[]
    upsert?: ChatMemberUpsertWithWhereUniqueWithoutChatInput | ChatMemberUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMemberCreateManyChatInputEnvelope
    set?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    disconnect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    delete?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    update?: ChatMemberUpdateWithWhereUniqueWithoutChatInput | ChatMemberUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMemberUpdateManyWithWhereWithoutChatInput | ChatMemberUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<CompanyCreateWithoutChatsInput, CompanyUncheckedCreateWithoutChatsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutChatsInput
    upsert?: CompanyUpsertWithoutChatsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutChatsInput, CompanyUpdateWithoutChatsInput>, CompanyUncheckedUpdateWithoutChatsInput>
  }

  export type MessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatMemberUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput> | ChatMemberCreateWithoutChatInput[] | ChatMemberUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutChatInput | ChatMemberCreateOrConnectWithoutChatInput[]
    upsert?: ChatMemberUpsertWithWhereUniqueWithoutChatInput | ChatMemberUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMemberCreateManyChatInputEnvelope
    set?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    disconnect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    delete?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    update?: ChatMemberUpdateWithWhereUniqueWithoutChatInput | ChatMemberUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMemberUpdateManyWithWhereWithoutChatInput | ChatMemberUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatCreateNestedOneWithoutMembersInput = {
    create?: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMembersInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatMembersInput = {
    create?: XOR<UserCreateWithoutChatMembersInput, UserUncheckedCreateWithoutChatMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatMembersInput
    connect?: UserWhereUniqueInput
  }

  export type ChatUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMembersInput
    upsert?: ChatUpsertWithoutMembersInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMembersInput, ChatUpdateWithoutMembersInput>, ChatUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutChatMembersNestedInput = {
    create?: XOR<UserCreateWithoutChatMembersInput, UserUncheckedCreateWithoutChatMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatMembersInput
    upsert?: UserUpsertWithoutChatMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatMembersInput, UserUpdateWithoutChatMembersInput>, UserUncheckedUpdateWithoutChatMembersInput>
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type CompanyCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<CompanyCreateWithoutInventoryItemsInput, CompanyUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInventoryItemsInput
    connect?: CompanyWhereUniqueInput
  }

  export type InventoryMovementCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type SupplierItemCreateNestedManyWithoutItemInput = {
    create?: XOR<SupplierItemCreateWithoutItemInput, SupplierItemUncheckedCreateWithoutItemInput> | SupplierItemCreateWithoutItemInput[] | SupplierItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierItemCreateOrConnectWithoutItemInput | SupplierItemCreateOrConnectWithoutItemInput[]
    createMany?: SupplierItemCreateManyItemInputEnvelope
    connect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type SupplierItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SupplierItemCreateWithoutItemInput, SupplierItemUncheckedCreateWithoutItemInput> | SupplierItemCreateWithoutItemInput[] | SupplierItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierItemCreateOrConnectWithoutItemInput | SupplierItemCreateOrConnectWithoutItemInput[]
    createMany?: SupplierItemCreateManyItemInputEnvelope
    connect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<CompanyCreateWithoutInventoryItemsInput, CompanyUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInventoryItemsInput
    upsert?: CompanyUpsertWithoutInventoryItemsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutInventoryItemsInput, CompanyUpdateWithoutInventoryItemsInput>, CompanyUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type InventoryMovementUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutItemInput | InventoryMovementUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutItemInput | InventoryMovementUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutItemInput | InventoryMovementUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type SupplierItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<SupplierItemCreateWithoutItemInput, SupplierItemUncheckedCreateWithoutItemInput> | SupplierItemCreateWithoutItemInput[] | SupplierItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierItemCreateOrConnectWithoutItemInput | SupplierItemCreateOrConnectWithoutItemInput[]
    upsert?: SupplierItemUpsertWithWhereUniqueWithoutItemInput | SupplierItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SupplierItemCreateManyItemInputEnvelope
    set?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    disconnect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    delete?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    connect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    update?: SupplierItemUpdateWithWhereUniqueWithoutItemInput | SupplierItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SupplierItemUpdateManyWithWhereWithoutItemInput | SupplierItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SupplierItemScalarWhereInput | SupplierItemScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutItemInput | InventoryMovementUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutItemInput | InventoryMovementUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutItemInput | InventoryMovementUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type SupplierItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SupplierItemCreateWithoutItemInput, SupplierItemUncheckedCreateWithoutItemInput> | SupplierItemCreateWithoutItemInput[] | SupplierItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierItemCreateOrConnectWithoutItemInput | SupplierItemCreateOrConnectWithoutItemInput[]
    upsert?: SupplierItemUpsertWithWhereUniqueWithoutItemInput | SupplierItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SupplierItemCreateManyItemInputEnvelope
    set?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    disconnect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    delete?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    connect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    update?: SupplierItemUpdateWithWhereUniqueWithoutItemInput | SupplierItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SupplierItemUpdateManyWithWhereWithoutItemInput | SupplierItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SupplierItemScalarWhereInput | SupplierItemScalarWhereInput[]
  }

  export type InventoryItemCreateNestedOneWithoutMovementsInput = {
    create?: XOR<InventoryItemCreateWithoutMovementsInput, InventoryItemUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutMovementsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type EnumInventoryMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.InventoryMovementType
  }

  export type InventoryItemUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutMovementsInput, InventoryItemUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutMovementsInput
    upsert?: InventoryItemUpsertWithoutMovementsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutMovementsInput, InventoryItemUpdateWithoutMovementsInput>, InventoryItemUncheckedUpdateWithoutMovementsInput>
  }

  export type SupplierItemCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierItemCreateWithoutSupplierInput, SupplierItemUncheckedCreateWithoutSupplierInput> | SupplierItemCreateWithoutSupplierInput[] | SupplierItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierItemCreateOrConnectWithoutSupplierInput | SupplierItemCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierItemCreateManySupplierInputEnvelope
    connect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<CompanyCreateWithoutSuppliersInput, CompanyUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSuppliersInput
    connect?: CompanyWhereUniqueInput
  }

  export type SupplierItemUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierItemCreateWithoutSupplierInput, SupplierItemUncheckedCreateWithoutSupplierInput> | SupplierItemCreateWithoutSupplierInput[] | SupplierItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierItemCreateOrConnectWithoutSupplierInput | SupplierItemCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierItemCreateManySupplierInputEnvelope
    connect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
  }

  export type SupplierItemUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierItemCreateWithoutSupplierInput, SupplierItemUncheckedCreateWithoutSupplierInput> | SupplierItemCreateWithoutSupplierInput[] | SupplierItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierItemCreateOrConnectWithoutSupplierInput | SupplierItemCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierItemUpsertWithWhereUniqueWithoutSupplierInput | SupplierItemUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierItemCreateManySupplierInputEnvelope
    set?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    disconnect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    delete?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    connect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    update?: SupplierItemUpdateWithWhereUniqueWithoutSupplierInput | SupplierItemUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierItemUpdateManyWithWhereWithoutSupplierInput | SupplierItemUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierItemScalarWhereInput | SupplierItemScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<CompanyCreateWithoutSuppliersInput, CompanyUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSuppliersInput
    upsert?: CompanyUpsertWithoutSuppliersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSuppliersInput, CompanyUpdateWithoutSuppliersInput>, CompanyUncheckedUpdateWithoutSuppliersInput>
  }

  export type SupplierItemUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierItemCreateWithoutSupplierInput, SupplierItemUncheckedCreateWithoutSupplierInput> | SupplierItemCreateWithoutSupplierInput[] | SupplierItemUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierItemCreateOrConnectWithoutSupplierInput | SupplierItemCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierItemUpsertWithWhereUniqueWithoutSupplierInput | SupplierItemUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierItemCreateManySupplierInputEnvelope
    set?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    disconnect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    delete?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    connect?: SupplierItemWhereUniqueInput | SupplierItemWhereUniqueInput[]
    update?: SupplierItemUpdateWithWhereUniqueWithoutSupplierInput | SupplierItemUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierItemUpdateManyWithWhereWithoutSupplierInput | SupplierItemUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierItemScalarWhereInput | SupplierItemScalarWhereInput[]
  }

  export type InventoryItemCreateNestedOneWithoutSupplierItemsInput = {
    create?: XOR<InventoryItemCreateWithoutSupplierItemsInput, InventoryItemUncheckedCreateWithoutSupplierItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutSupplierItemsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutItemsInput = {
    create?: XOR<SupplierCreateWithoutItemsInput, SupplierUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutItemsInput
    connect?: SupplierWhereUniqueInput
  }

  export type InventoryItemUpdateOneRequiredWithoutSupplierItemsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutSupplierItemsInput, InventoryItemUncheckedCreateWithoutSupplierItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutSupplierItemsInput
    upsert?: InventoryItemUpsertWithoutSupplierItemsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutSupplierItemsInput, InventoryItemUpdateWithoutSupplierItemsInput>, InventoryItemUncheckedUpdateWithoutSupplierItemsInput>
  }

  export type SupplierUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SupplierCreateWithoutItemsInput, SupplierUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutItemsInput
    upsert?: SupplierUpsertWithoutItemsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutItemsInput, SupplierUpdateWithoutItemsInput>, SupplierUncheckedUpdateWithoutItemsInput>
  }

  export type CompanyCreateNestedOneWithoutGatePassesInput = {
    create?: XOR<CompanyCreateWithoutGatePassesInput, CompanyUncheckedCreateWithoutGatePassesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutGatePassesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGatePassesCreatedInput = {
    create?: XOR<UserCreateWithoutGatePassesCreatedInput, UserUncheckedCreateWithoutGatePassesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGatePassesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGatePassesForInput = {
    create?: XOR<UserCreateWithoutGatePassesForInput, UserUncheckedCreateWithoutGatePassesForInput>
    connectOrCreate?: UserCreateOrConnectWithoutGatePassesForInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGatePassTypeFieldUpdateOperationsInput = {
    set?: $Enums.GatePassType
  }

  export type EnumGatePassStatusFieldUpdateOperationsInput = {
    set?: $Enums.GatePassStatus
  }

  export type CompanyUpdateOneRequiredWithoutGatePassesNestedInput = {
    create?: XOR<CompanyCreateWithoutGatePassesInput, CompanyUncheckedCreateWithoutGatePassesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutGatePassesInput
    upsert?: CompanyUpsertWithoutGatePassesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutGatePassesInput, CompanyUpdateWithoutGatePassesInput>, CompanyUncheckedUpdateWithoutGatePassesInput>
  }

  export type UserUpdateOneRequiredWithoutGatePassesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutGatePassesCreatedInput, UserUncheckedCreateWithoutGatePassesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGatePassesCreatedInput
    upsert?: UserUpsertWithoutGatePassesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGatePassesCreatedInput, UserUpdateWithoutGatePassesCreatedInput>, UserUncheckedUpdateWithoutGatePassesCreatedInput>
  }

  export type UserUpdateOneWithoutGatePassesForNestedInput = {
    create?: XOR<UserCreateWithoutGatePassesForInput, UserUncheckedCreateWithoutGatePassesForInput>
    connectOrCreate?: UserCreateOrConnectWithoutGatePassesForInput
    upsert?: UserUpsertWithoutGatePassesForInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGatePassesForInput, UserUpdateWithoutGatePassesForInput>, UserUncheckedUpdateWithoutGatePassesForInput>
  }

  export type DocumentCreatetagsInput = {
    set: string[]
  }

  export type CompanyCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentUploadsInput = {
    create?: XOR<UserCreateWithoutDocumentUploadsInput, UserUncheckedCreateWithoutDocumentUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentUploadsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type DocumentUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CompanyUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    upsert?: CompanyUpsertWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDocumentsInput, CompanyUpdateWithoutDocumentsInput>, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutDocumentUploadsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentUploadsInput, UserUncheckedCreateWithoutDocumentUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentUploadsInput
    upsert?: UserUpsertWithoutDocumentUploadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentUploadsInput, UserUpdateWithoutDocumentUploadsInput>, UserUncheckedUpdateWithoutDocumentUploadsInput>
  }

  export type UserCreateNestedOneWithoutReviewsGivenInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPerformanceReviewsInput = {
    create?: XOR<UserCreateWithoutPerformanceReviewsInput, UserUncheckedCreateWithoutPerformanceReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformanceReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsGivenNestedInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    upsert?: UserUpsertWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsGivenInput, UserUpdateWithoutReviewsGivenInput>, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateOneRequiredWithoutPerformanceReviewsNestedInput = {
    create?: XOR<UserCreateWithoutPerformanceReviewsInput, UserUncheckedCreateWithoutPerformanceReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformanceReviewsInput
    upsert?: UserUpsertWithoutPerformanceReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPerformanceReviewsInput, UserUpdateWithoutPerformanceReviewsInput>, UserUncheckedUpdateWithoutPerformanceReviewsInput>
  }

  export type CompanyCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditLogActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditLogAction
  }

  export type CompanyUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    upsert?: CompanyUpsertWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAuditLogsInput, CompanyUpdateWithoutAuditLogsInput>, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyCreateNestedOneWithoutCreditsRechargesInput = {
    create?: XOR<CompanyCreateWithoutCreditsRechargesInput, CompanyUncheckedCreateWithoutCreditsRechargesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCreditsRechargesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreditsRechargesInput = {
    create?: XOR<UserCreateWithoutCreditsRechargesInput, UserUncheckedCreateWithoutCreditsRechargesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditsRechargesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCreditsRechargesNestedInput = {
    create?: XOR<CompanyCreateWithoutCreditsRechargesInput, CompanyUncheckedCreateWithoutCreditsRechargesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCreditsRechargesInput
    upsert?: CompanyUpsertWithoutCreditsRechargesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCreditsRechargesInput, CompanyUpdateWithoutCreditsRechargesInput>, CompanyUncheckedUpdateWithoutCreditsRechargesInput>
  }

  export type UserUpdateOneRequiredWithoutCreditsRechargesNestedInput = {
    create?: XOR<UserCreateWithoutCreditsRechargesInput, UserUncheckedCreateWithoutCreditsRechargesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditsRechargesInput
    upsert?: UserUpsertWithoutCreditsRechargesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreditsRechargesInput, UserUpdateWithoutCreditsRechargesInput>, UserUncheckedUpdateWithoutCreditsRechargesInput>
  }

  export type CompanyCreateNestedOneWithoutTransactionHistoryInput = {
    create?: XOR<CompanyCreateWithoutTransactionHistoryInput, CompanyUncheckedCreateWithoutTransactionHistoryInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTransactionHistoryInput
    connect?: CompanyWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ServiceCreateWithoutTransactionsInput, ServiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTransactionsInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEnabledServicesInput = {
    create?: XOR<UserCreateWithoutEnabledServicesInput, UserUncheckedCreateWithoutEnabledServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnabledServicesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutTransactionHistoryNestedInput = {
    create?: XOR<CompanyCreateWithoutTransactionHistoryInput, CompanyUncheckedCreateWithoutTransactionHistoryInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTransactionHistoryInput
    upsert?: CompanyUpsertWithoutTransactionHistoryInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTransactionHistoryInput, CompanyUpdateWithoutTransactionHistoryInput>, CompanyUncheckedUpdateWithoutTransactionHistoryInput>
  }

  export type ServiceUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<ServiceCreateWithoutTransactionsInput, ServiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTransactionsInput
    upsert?: ServiceUpsertWithoutTransactionsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutTransactionsInput, ServiceUpdateWithoutTransactionsInput>, ServiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneWithoutEnabledServicesNestedInput = {
    create?: XOR<UserCreateWithoutEnabledServicesInput, UserUncheckedCreateWithoutEnabledServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnabledServicesInput
    upsert?: UserUpsertWithoutEnabledServicesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnabledServicesInput, UserUpdateWithoutEnabledServicesInput>, UserUncheckedUpdateWithoutEnabledServicesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type NestedEnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type NestedEnumChatTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatType | EnumChatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatType[] | ListEnumChatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatType[] | ListEnumChatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatTypeFilter<$PrismaModel> | $Enums.ChatType
  }

  export type NestedEnumChatTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatType | EnumChatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatType[] | ListEnumChatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatType[] | ListEnumChatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChatType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatTypeFilter<$PrismaModel>
    _max?: NestedEnumChatTypeFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumInventoryMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMovementType | EnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryMovementTypeFilter<$PrismaModel> | $Enums.InventoryMovementType
  }

  export type NestedEnumInventoryMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMovementType | EnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryMovementType[] | ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.InventoryMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumInventoryMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumGatePassTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GatePassType | EnumGatePassTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GatePassType[] | ListEnumGatePassTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatePassType[] | ListEnumGatePassTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGatePassTypeFilter<$PrismaModel> | $Enums.GatePassType
  }

  export type NestedEnumGatePassStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GatePassStatus | EnumGatePassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GatePassStatus[] | ListEnumGatePassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatePassStatus[] | ListEnumGatePassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGatePassStatusFilter<$PrismaModel> | $Enums.GatePassStatus
  }

  export type NestedEnumGatePassTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GatePassType | EnumGatePassTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GatePassType[] | ListEnumGatePassTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatePassType[] | ListEnumGatePassTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGatePassTypeWithAggregatesFilter<$PrismaModel> | $Enums.GatePassType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGatePassTypeFilter<$PrismaModel>
    _max?: NestedEnumGatePassTypeFilter<$PrismaModel>
  }

  export type NestedEnumGatePassStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GatePassStatus | EnumGatePassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GatePassStatus[] | ListEnumGatePassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatePassStatus[] | ListEnumGatePassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGatePassStatusWithAggregatesFilter<$PrismaModel> | $Enums.GatePassStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGatePassStatusFilter<$PrismaModel>
    _max?: NestedEnumGatePassStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuditLogActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditLogAction | EnumAuditLogActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditLogAction[] | ListEnumAuditLogActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditLogAction[] | ListEnumAuditLogActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditLogActionFilter<$PrismaModel> | $Enums.AuditLogAction
  }

  export type NestedEnumAuditLogActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditLogAction | EnumAuditLogActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditLogAction[] | ListEnumAuditLogActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditLogAction[] | ListEnumAuditLogActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditLogActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditLogAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditLogActionFilter<$PrismaModel>
    _max?: NestedEnumAuditLogActionFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TransactionHistoryCreateWithoutEnabledByInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    numberOfDaysUsed?: number | null
    company: CompanyCreateNestedOneWithoutTransactionHistoryInput
    service?: ServiceCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionHistoryUncheckedCreateWithoutEnabledByInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    companyId: string
    serviceId?: string | null
    numberOfDaysUsed?: number | null
  }

  export type TransactionHistoryCreateOrConnectWithoutEnabledByInput = {
    where: TransactionHistoryWhereUniqueInput
    create: XOR<TransactionHistoryCreateWithoutEnabledByInput, TransactionHistoryUncheckedCreateWithoutEnabledByInput>
  }

  export type TransactionHistoryCreateManyEnabledByInputEnvelope = {
    data: TransactionHistoryCreateManyEnabledByInput | TransactionHistoryCreateManyEnabledByInput[]
    skipDuplicates?: boolean
  }

  export type UserCompanyCreateWithoutUserInput = {
    id?: string
    role?: $Enums.Role
    isActive?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUserCompaniesInput
  }

  export type UserCompanyUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    role?: $Enums.Role
    isActive?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCompanyCreateOrConnectWithoutUserInput = {
    where: UserCompanyWhereUniqueInput
    create: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput>
  }

  export type UserCompanyCreateManyUserInputEnvelope = {
    data: UserCompanyCreateManyUserInput | UserCompanyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutHeadOfDeptInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDepartmentsInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutHeadOfDeptInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutHeadOfDeptInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutHeadOfDeptInput, DepartmentUncheckedCreateWithoutHeadOfDeptInput>
  }

  export type DepartmentCreateManyHeadOfDeptInputEnvelope = {
    data: DepartmentCreateManyHeadOfDeptInput | DepartmentCreateManyHeadOfDeptInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutUserInput = {
    id?: string
    clockInTime?: Date | string | null
    clockOutTime?: Date | string | null
    workingHours?: number | null
    overtimeHours?: number | null
    status?: $Enums.AttendanceStatus
    location?: string | null
    notes?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type AttendanceUncheckedCreateWithoutUserInput = {
    id?: string
    clockInTime?: Date | string | null
    clockOutTime?: Date | string | null
    workingHours?: number | null
    overtimeHours?: number | null
    status?: $Enums.AttendanceStatus
    location?: string | null
    notes?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type AttendanceCreateOrConnectWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCreateManyUserInputEnvelope = {
    data: AttendanceCreateManyUserInput | AttendanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: $Enums.AuditLogAction
    tableName: string
    recordId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    description?: string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: $Enums.AuditLogAction
    tableName: string
    recordId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    description?: string | null
    createdAt?: Date | string
    companyId: string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatMemberCreateWithoutUserInput = {
    id?: string
    isAdmin?: boolean
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chat: ChatCreateNestedOneWithoutMembersInput
  }

  export type ChatMemberUncheckedCreateWithoutUserInput = {
    id?: string
    isAdmin?: boolean
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatId: string
  }

  export type ChatMemberCreateOrConnectWithoutUserInput = {
    where: ChatMemberWhereUniqueInput
    create: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput>
  }

  export type ChatMemberCreateManyUserInputEnvelope = {
    data: ChatMemberCreateManyUserInput | ChatMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    documentType?: $Enums.DocumentType
    isConfidential?: boolean
    expiryDate?: Date | string | null
    tags?: DocumentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    documentType?: $Enums.DocumentType
    isConfidential?: boolean
    expiryDate?: Date | string | null
    tags?: DocumentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DocumentCreateOrConnectWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentCreateManyUploadedByInputEnvelope = {
    data: DocumentCreateManyUploadedByInput | DocumentCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type GatePassCreateWithoutCreatedByInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutGatePassesInput
    forUser?: UserCreateNestedOneWithoutGatePassesForInput
  }

  export type GatePassUncheckedCreateWithoutCreatedByInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    forUserId?: string | null
  }

  export type GatePassCreateOrConnectWithoutCreatedByInput = {
    where: GatePassWhereUniqueInput
    create: XOR<GatePassCreateWithoutCreatedByInput, GatePassUncheckedCreateWithoutCreatedByInput>
  }

  export type GatePassCreateManyCreatedByInputEnvelope = {
    data: GatePassCreateManyCreatedByInput | GatePassCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type GatePassCreateWithoutForUserInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutGatePassesInput
    createdBy: UserCreateNestedOneWithoutGatePassesCreatedInput
  }

  export type GatePassUncheckedCreateWithoutForUserInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    createdById: string
  }

  export type GatePassCreateOrConnectWithoutForUserInput = {
    where: GatePassWhereUniqueInput
    create: XOR<GatePassCreateWithoutForUserInput, GatePassUncheckedCreateWithoutForUserInput>
  }

  export type GatePassCreateManyForUserInputEnvelope = {
    data: GatePassCreateManyForUserInput | GatePassCreateManyForUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    leaveType: $Enums.LeaveType
    reason: string
    status?: $Enums.LeaveStatus
    appliedDate?: Date | string
    approvedBy?: string | null
    rejectedBy?: string | null
    comments?: string | null
    totalDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type LeaveUncheckedCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    leaveType: $Enums.LeaveType
    reason: string
    status?: $Enums.LeaveStatus
    appliedDate?: Date | string
    approvedBy?: string | null
    rejectedBy?: string | null
    comments?: string | null
    totalDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type LeaveCreateOrConnectWithoutUserInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput>
  }

  export type LeaveCreateManyUserInputEnvelope = {
    data: LeaveCreateManyUserInput | LeaveCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    fileUrl?: string | null
    fileName?: string | null
    isPinned?: boolean
    replyTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    fileUrl?: string | null
    fileName?: string | null
    isPinned?: boolean
    replyTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chatId: string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceReviewCreateWithoutReviewByInput = {
    id?: string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    overallRating?: number | null
    goalsAchieved?: number | null
    punctualityScore?: number | null
    qualityScore?: number | null
    communicationScore?: number | null
    teamworkScore?: number | null
    comments?: string | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    reviewFor: UserCreateNestedOneWithoutPerformanceReviewsInput
  }

  export type PerformanceReviewUncheckedCreateWithoutReviewByInput = {
    id?: string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    overallRating?: number | null
    goalsAchieved?: number | null
    punctualityScore?: number | null
    qualityScore?: number | null
    communicationScore?: number | null
    teamworkScore?: number | null
    comments?: string | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewForId: string
    companyId: string
  }

  export type PerformanceReviewCreateOrConnectWithoutReviewByInput = {
    where: PerformanceReviewWhereUniqueInput
    create: XOR<PerformanceReviewCreateWithoutReviewByInput, PerformanceReviewUncheckedCreateWithoutReviewByInput>
  }

  export type PerformanceReviewCreateManyReviewByInputEnvelope = {
    data: PerformanceReviewCreateManyReviewByInput | PerformanceReviewCreateManyReviewByInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceReviewCreateWithoutReviewForInput = {
    id?: string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    overallRating?: number | null
    goalsAchieved?: number | null
    punctualityScore?: number | null
    qualityScore?: number | null
    communicationScore?: number | null
    teamworkScore?: number | null
    comments?: string | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    reviewBy: UserCreateNestedOneWithoutReviewsGivenInput
  }

  export type PerformanceReviewUncheckedCreateWithoutReviewForInput = {
    id?: string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    overallRating?: number | null
    goalsAchieved?: number | null
    punctualityScore?: number | null
    qualityScore?: number | null
    communicationScore?: number | null
    teamworkScore?: number | null
    comments?: string | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewById: string
    companyId: string
  }

  export type PerformanceReviewCreateOrConnectWithoutReviewForInput = {
    where: PerformanceReviewWhereUniqueInput
    create: XOR<PerformanceReviewCreateWithoutReviewForInput, PerformanceReviewUncheckedCreateWithoutReviewForInput>
  }

  export type PerformanceReviewCreateManyReviewForInputEnvelope = {
    data: PerformanceReviewCreateManyReviewForInput | PerformanceReviewCreateManyReviewForInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
    department?: DepartmentCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    departmentId?: string | null
    companyId: string
  }

  export type TaskCreateOrConnectWithoutAssignedToInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssignedToInput, TaskUncheckedCreateWithoutAssignedToInput>
  }

  export type TaskCreateManyAssignedToInputEnvelope = {
    data: TaskCreateManyAssignedToInput | TaskCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedTo: UserCreateNestedOneWithoutTasksAssignedInput
    department?: DepartmentCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId: string
    departmentId?: string | null
    companyId: string
  }

  export type TaskCreateOrConnectWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput>
  }

  export type TaskCreateManyCreatedByInputEnvelope = {
    data: TaskCreateManyCreatedByInput | TaskCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CreditsRechargeCreateWithoutPurchasedByInput = {
    id?: string
    credits: number
    amountPaid: number
    transactionId?: string | null
    paymentMethod?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCreditsRechargesInput
  }

  export type CreditsRechargeUncheckedCreateWithoutPurchasedByInput = {
    id?: string
    credits: number
    amountPaid: number
    transactionId?: string | null
    paymentMethod?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type CreditsRechargeCreateOrConnectWithoutPurchasedByInput = {
    where: CreditsRechargeWhereUniqueInput
    create: XOR<CreditsRechargeCreateWithoutPurchasedByInput, CreditsRechargeUncheckedCreateWithoutPurchasedByInput>
  }

  export type CreditsRechargeCreateManyPurchasedByInputEnvelope = {
    data: CreditsRechargeCreateManyPurchasedByInput | CreditsRechargeCreateManyPurchasedByInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDepartmentsInput
    headOfDept?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    headOfDeptId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutUsersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutSubordinatesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
  }

  export type UserUncheckedCreateWithoutSubordinatesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
  }

  export type UserCreateOrConnectWithoutSubordinatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
  }

  export type UserCreateWithoutManagerInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutManagerInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserCreateManyManagerInputEnvelope = {
    data: UserCreateManyManagerInput | UserCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type TransactionHistoryUpsertWithWhereUniqueWithoutEnabledByInput = {
    where: TransactionHistoryWhereUniqueInput
    update: XOR<TransactionHistoryUpdateWithoutEnabledByInput, TransactionHistoryUncheckedUpdateWithoutEnabledByInput>
    create: XOR<TransactionHistoryCreateWithoutEnabledByInput, TransactionHistoryUncheckedCreateWithoutEnabledByInput>
  }

  export type TransactionHistoryUpdateWithWhereUniqueWithoutEnabledByInput = {
    where: TransactionHistoryWhereUniqueInput
    data: XOR<TransactionHistoryUpdateWithoutEnabledByInput, TransactionHistoryUncheckedUpdateWithoutEnabledByInput>
  }

  export type TransactionHistoryUpdateManyWithWhereWithoutEnabledByInput = {
    where: TransactionHistoryScalarWhereInput
    data: XOR<TransactionHistoryUpdateManyMutationInput, TransactionHistoryUncheckedUpdateManyWithoutEnabledByInput>
  }

  export type TransactionHistoryScalarWhereInput = {
    AND?: TransactionHistoryScalarWhereInput | TransactionHistoryScalarWhereInput[]
    OR?: TransactionHistoryScalarWhereInput[]
    NOT?: TransactionHistoryScalarWhereInput | TransactionHistoryScalarWhereInput[]
    id?: StringFilter<"TransactionHistory"> | string
    creditsUsed?: FloatFilter<"TransactionHistory"> | number
    description?: StringNullableFilter<"TransactionHistory"> | string | null
    createdAt?: DateTimeFilter<"TransactionHistory"> | Date | string
    companyId?: StringFilter<"TransactionHistory"> | string
    serviceId?: StringNullableFilter<"TransactionHistory"> | string | null
    numberOfDaysUsed?: IntNullableFilter<"TransactionHistory"> | number | null
    enabledById?: StringNullableFilter<"TransactionHistory"> | string | null
  }

  export type UserCompanyUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCompanyWhereUniqueInput
    update: XOR<UserCompanyUpdateWithoutUserInput, UserCompanyUncheckedUpdateWithoutUserInput>
    create: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput>
  }

  export type UserCompanyUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCompanyWhereUniqueInput
    data: XOR<UserCompanyUpdateWithoutUserInput, UserCompanyUncheckedUpdateWithoutUserInput>
  }

  export type UserCompanyUpdateManyWithWhereWithoutUserInput = {
    where: UserCompanyScalarWhereInput
    data: XOR<UserCompanyUpdateManyMutationInput, UserCompanyUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCompanyScalarWhereInput = {
    AND?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
    OR?: UserCompanyScalarWhereInput[]
    NOT?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
    id?: StringFilter<"UserCompany"> | string
    userId?: StringFilter<"UserCompany"> | string
    companyId?: StringFilter<"UserCompany"> | string
    role?: EnumRoleFilter<"UserCompany"> | $Enums.Role
    isActive?: BoolFilter<"UserCompany"> | boolean
    joinedAt?: DateTimeFilter<"UserCompany"> | Date | string
    leftAt?: DateTimeNullableFilter<"UserCompany"> | Date | string | null
    createdAt?: DateTimeFilter<"UserCompany"> | Date | string
    updatedAt?: DateTimeFilter<"UserCompany"> | Date | string
  }

  export type DepartmentUpsertWithWhereUniqueWithoutHeadOfDeptInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutHeadOfDeptInput, DepartmentUncheckedUpdateWithoutHeadOfDeptInput>
    create: XOR<DepartmentCreateWithoutHeadOfDeptInput, DepartmentUncheckedCreateWithoutHeadOfDeptInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutHeadOfDeptInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutHeadOfDeptInput, DepartmentUncheckedUpdateWithoutHeadOfDeptInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutHeadOfDeptInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutHeadOfDeptInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    headOfDeptId?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    companyId?: StringFilter<"Department"> | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    clockInTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    clockOutTime?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    workingHours?: FloatNullableFilter<"Attendance"> | number | null
    overtimeHours?: FloatNullableFilter<"Attendance"> | number | null
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    location?: StringNullableFilter<"Attendance"> | string | null
    notes?: StringNullableFilter<"Attendance"> | string | null
    date?: DateTimeFilter<"Attendance"> | Date | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    userId?: StringFilter<"Attendance"> | string
    companyId?: StringFilter<"Attendance"> | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: EnumAuditLogActionFilter<"AuditLog"> | $Enums.AuditLogAction
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    description?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    companyId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
  }

  export type ChatMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatMemberWhereUniqueInput
    update: XOR<ChatMemberUpdateWithoutUserInput, ChatMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput>
  }

  export type ChatMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatMemberWhereUniqueInput
    data: XOR<ChatMemberUpdateWithoutUserInput, ChatMemberUncheckedUpdateWithoutUserInput>
  }

  export type ChatMemberUpdateManyWithWhereWithoutUserInput = {
    where: ChatMemberScalarWhereInput
    data: XOR<ChatMemberUpdateManyMutationInput, ChatMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatMemberScalarWhereInput = {
    AND?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
    OR?: ChatMemberScalarWhereInput[]
    NOT?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
    id?: StringFilter<"ChatMember"> | string
    isAdmin?: BoolFilter<"ChatMember"> | boolean
    joinedAt?: DateTimeFilter<"ChatMember"> | Date | string
    createdAt?: DateTimeFilter<"ChatMember"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMember"> | Date | string
    chatId?: StringFilter<"ChatMember"> | string
    userId?: StringFilter<"ChatMember"> | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUploadedByInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    fileName?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    documentType?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    isConfidential?: BoolFilter<"Document"> | boolean
    expiryDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    tags?: StringNullableListFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    companyId?: StringFilter<"Document"> | string
    uploadedById?: StringFilter<"Document"> | string
  }

  export type GatePassUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: GatePassWhereUniqueInput
    update: XOR<GatePassUpdateWithoutCreatedByInput, GatePassUncheckedUpdateWithoutCreatedByInput>
    create: XOR<GatePassCreateWithoutCreatedByInput, GatePassUncheckedCreateWithoutCreatedByInput>
  }

  export type GatePassUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: GatePassWhereUniqueInput
    data: XOR<GatePassUpdateWithoutCreatedByInput, GatePassUncheckedUpdateWithoutCreatedByInput>
  }

  export type GatePassUpdateManyWithWhereWithoutCreatedByInput = {
    where: GatePassScalarWhereInput
    data: XOR<GatePassUpdateManyMutationInput, GatePassUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type GatePassScalarWhereInput = {
    AND?: GatePassScalarWhereInput | GatePassScalarWhereInput[]
    OR?: GatePassScalarWhereInput[]
    NOT?: GatePassScalarWhereInput | GatePassScalarWhereInput[]
    id?: StringFilter<"GatePass"> | string
    passNumber?: StringFilter<"GatePass"> | string
    type?: EnumGatePassTypeFilter<"GatePass"> | $Enums.GatePassType
    purpose?: StringNullableFilter<"GatePass"> | string | null
    visitorName?: StringNullableFilter<"GatePass"> | string | null
    visitorPhone?: StringNullableFilter<"GatePass"> | string | null
    visitorCompany?: StringNullableFilter<"GatePass"> | string | null
    vehicleNumber?: StringNullableFilter<"GatePass"> | string | null
    itemsCarried?: StringNullableFilter<"GatePass"> | string | null
    entryTime?: DateTimeNullableFilter<"GatePass"> | Date | string | null
    exitTime?: DateTimeNullableFilter<"GatePass"> | Date | string | null
    status?: EnumGatePassStatusFilter<"GatePass"> | $Enums.GatePassStatus
    validUntil?: DateTimeNullableFilter<"GatePass"> | Date | string | null
    notes?: StringNullableFilter<"GatePass"> | string | null
    createdAt?: DateTimeFilter<"GatePass"> | Date | string
    updatedAt?: DateTimeFilter<"GatePass"> | Date | string
    companyId?: StringFilter<"GatePass"> | string
    createdById?: StringFilter<"GatePass"> | string
    forUserId?: StringNullableFilter<"GatePass"> | string | null
  }

  export type GatePassUpsertWithWhereUniqueWithoutForUserInput = {
    where: GatePassWhereUniqueInput
    update: XOR<GatePassUpdateWithoutForUserInput, GatePassUncheckedUpdateWithoutForUserInput>
    create: XOR<GatePassCreateWithoutForUserInput, GatePassUncheckedCreateWithoutForUserInput>
  }

  export type GatePassUpdateWithWhereUniqueWithoutForUserInput = {
    where: GatePassWhereUniqueInput
    data: XOR<GatePassUpdateWithoutForUserInput, GatePassUncheckedUpdateWithoutForUserInput>
  }

  export type GatePassUpdateManyWithWhereWithoutForUserInput = {
    where: GatePassScalarWhereInput
    data: XOR<GatePassUpdateManyMutationInput, GatePassUncheckedUpdateManyWithoutForUserInput>
  }

  export type LeaveUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutUserInput, LeaveUncheckedUpdateWithoutUserInput>
    create: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutUserInput, LeaveUncheckedUpdateWithoutUserInput>
  }

  export type LeaveUpdateManyWithWhereWithoutUserInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaveScalarWhereInput = {
    AND?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    OR?: LeaveScalarWhereInput[]
    NOT?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    id?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    leaveType?: EnumLeaveTypeFilter<"Leave"> | $Enums.LeaveType
    reason?: StringFilter<"Leave"> | string
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    appliedDate?: DateTimeFilter<"Leave"> | Date | string
    approvedBy?: StringNullableFilter<"Leave"> | string | null
    rejectedBy?: StringNullableFilter<"Leave"> | string | null
    comments?: StringNullableFilter<"Leave"> | string | null
    totalDays?: IntFilter<"Leave"> | number
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    userId?: StringFilter<"Leave"> | string
    companyId?: StringFilter<"Leave"> | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    fileUrl?: StringNullableFilter<"Message"> | string | null
    fileName?: StringNullableFilter<"Message"> | string | null
    isPinned?: BoolFilter<"Message"> | boolean
    replyTo?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    chatId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
  }

  export type PerformanceReviewUpsertWithWhereUniqueWithoutReviewByInput = {
    where: PerformanceReviewWhereUniqueInput
    update: XOR<PerformanceReviewUpdateWithoutReviewByInput, PerformanceReviewUncheckedUpdateWithoutReviewByInput>
    create: XOR<PerformanceReviewCreateWithoutReviewByInput, PerformanceReviewUncheckedCreateWithoutReviewByInput>
  }

  export type PerformanceReviewUpdateWithWhereUniqueWithoutReviewByInput = {
    where: PerformanceReviewWhereUniqueInput
    data: XOR<PerformanceReviewUpdateWithoutReviewByInput, PerformanceReviewUncheckedUpdateWithoutReviewByInput>
  }

  export type PerformanceReviewUpdateManyWithWhereWithoutReviewByInput = {
    where: PerformanceReviewScalarWhereInput
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyWithoutReviewByInput>
  }

  export type PerformanceReviewScalarWhereInput = {
    AND?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
    OR?: PerformanceReviewScalarWhereInput[]
    NOT?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
    id?: StringFilter<"PerformanceReview"> | string
    reviewPeriodStart?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewPeriodEnd?: DateTimeFilter<"PerformanceReview"> | Date | string
    overallRating?: FloatNullableFilter<"PerformanceReview"> | number | null
    goalsAchieved?: IntNullableFilter<"PerformanceReview"> | number | null
    punctualityScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    qualityScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    communicationScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    teamworkScore?: FloatNullableFilter<"PerformanceReview"> | number | null
    comments?: StringNullableFilter<"PerformanceReview"> | string | null
    goals?: StringNullableFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewForId?: StringFilter<"PerformanceReview"> | string
    reviewById?: StringFilter<"PerformanceReview"> | string
    companyId?: StringFilter<"PerformanceReview"> | string
  }

  export type PerformanceReviewUpsertWithWhereUniqueWithoutReviewForInput = {
    where: PerformanceReviewWhereUniqueInput
    update: XOR<PerformanceReviewUpdateWithoutReviewForInput, PerformanceReviewUncheckedUpdateWithoutReviewForInput>
    create: XOR<PerformanceReviewCreateWithoutReviewForInput, PerformanceReviewUncheckedCreateWithoutReviewForInput>
  }

  export type PerformanceReviewUpdateWithWhereUniqueWithoutReviewForInput = {
    where: PerformanceReviewWhereUniqueInput
    data: XOR<PerformanceReviewUpdateWithoutReviewForInput, PerformanceReviewUncheckedUpdateWithoutReviewForInput>
  }

  export type PerformanceReviewUpdateManyWithWhereWithoutReviewForInput = {
    where: PerformanceReviewScalarWhereInput
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyWithoutReviewForInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssignedToInput, TaskUncheckedUpdateWithoutAssignedToInput>
    create: XOR<TaskCreateWithoutAssignedToInput, TaskUncheckedCreateWithoutAssignedToInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssignedToInput, TaskUncheckedUpdateWithoutAssignedToInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssignedToInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedHours?: FloatNullableFilter<"Task"> | number | null
    actualHours?: FloatNullableFilter<"Task"> | number | null
    progress?: IntFilter<"Task"> | number
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    assignedToId?: StringFilter<"Task"> | string
    createdById?: StringFilter<"Task"> | string
    departmentId?: StringNullableFilter<"Task"> | string | null
    companyId?: StringFilter<"Task"> | string
  }

  export type TaskUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCreatedByInput, TaskUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TaskCreateWithoutCreatedByInput, TaskUncheckedCreateWithoutCreatedByInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCreatedByInput, TaskUncheckedUpdateWithoutCreatedByInput>
  }

  export type TaskUpdateManyWithWhereWithoutCreatedByInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CreditsRechargeUpsertWithWhereUniqueWithoutPurchasedByInput = {
    where: CreditsRechargeWhereUniqueInput
    update: XOR<CreditsRechargeUpdateWithoutPurchasedByInput, CreditsRechargeUncheckedUpdateWithoutPurchasedByInput>
    create: XOR<CreditsRechargeCreateWithoutPurchasedByInput, CreditsRechargeUncheckedCreateWithoutPurchasedByInput>
  }

  export type CreditsRechargeUpdateWithWhereUniqueWithoutPurchasedByInput = {
    where: CreditsRechargeWhereUniqueInput
    data: XOR<CreditsRechargeUpdateWithoutPurchasedByInput, CreditsRechargeUncheckedUpdateWithoutPurchasedByInput>
  }

  export type CreditsRechargeUpdateManyWithWhereWithoutPurchasedByInput = {
    where: CreditsRechargeScalarWhereInput
    data: XOR<CreditsRechargeUpdateManyMutationInput, CreditsRechargeUncheckedUpdateManyWithoutPurchasedByInput>
  }

  export type CreditsRechargeScalarWhereInput = {
    AND?: CreditsRechargeScalarWhereInput | CreditsRechargeScalarWhereInput[]
    OR?: CreditsRechargeScalarWhereInput[]
    NOT?: CreditsRechargeScalarWhereInput | CreditsRechargeScalarWhereInput[]
    id?: StringFilter<"CreditsRecharge"> | string
    credits?: FloatFilter<"CreditsRecharge"> | number
    amountPaid?: FloatFilter<"CreditsRecharge"> | number
    transactionId?: StringNullableFilter<"CreditsRecharge"> | string | null
    paymentMethod?: StringNullableFilter<"CreditsRecharge"> | string | null
    paymentStatus?: StringFilter<"CreditsRecharge"> | string
    createdAt?: DateTimeFilter<"CreditsRecharge"> | Date | string
    updatedAt?: DateTimeFilter<"CreditsRecharge"> | Date | string
    companyId?: StringFilter<"CreditsRecharge"> | string
    purchasedById?: StringFilter<"CreditsRecharge"> | string
  }

  export type DepartmentUpsertWithoutUsersInput = {
    update: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutUsersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDepartmentsNestedInput
    headOfDept?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDeptId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutSubordinatesInput = {
    update: XOR<UserUpdateWithoutSubordinatesInput, UserUncheckedUpdateWithoutSubordinatesInput>
    create: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubordinatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubordinatesInput, UserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type UserUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
  }

  export type UserUncheckedUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
  }

  export type UserUpdateManyWithWhereWithoutManagerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutManagerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    firebaseId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    employeeId?: StringNullableFilter<"User"> | string | null
    designation?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    dateOfJoining?: DateTimeNullableFilter<"User"> | Date | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    address?: StringNullableFilter<"User"> | string | null
    emergencyContact?: StringNullableFilter<"User"> | string | null
    salary?: FloatNullableFilter<"User"> | number | null
    workingHoursPerDay?: FloatNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    departmentId?: StringNullableFilter<"User"> | string | null
    managerId?: StringNullableFilter<"User"> | string | null
    Salary?: IntNullableFilter<"User"> | number | null
  }

  export type UserCreateWithoutUserCompaniesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutUserCompaniesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutUserCompaniesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserCompaniesInput, UserUncheckedCreateWithoutUserCompaniesInput>
  }

  export type CompanyCreateWithoutUserCompaniesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    services?: ServiceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUserCompaniesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUserCompaniesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUserCompaniesInput, CompanyUncheckedCreateWithoutUserCompaniesInput>
  }

  export type UserUpsertWithoutUserCompaniesInput = {
    update: XOR<UserUpdateWithoutUserCompaniesInput, UserUncheckedUpdateWithoutUserCompaniesInput>
    create: XOR<UserCreateWithoutUserCompaniesInput, UserUncheckedCreateWithoutUserCompaniesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserCompaniesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserCompaniesInput, UserUncheckedUpdateWithoutUserCompaniesInput>
  }

  export type UserUpdateWithoutUserCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutUserCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type CompanyUpsertWithoutUserCompaniesInput = {
    update: XOR<CompanyUpdateWithoutUserCompaniesInput, CompanyUncheckedUpdateWithoutUserCompaniesInput>
    create: XOR<CompanyCreateWithoutUserCompaniesInput, CompanyUncheckedCreateWithoutUserCompaniesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUserCompaniesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUserCompaniesInput, CompanyUncheckedUpdateWithoutUserCompaniesInput>
  }

  export type CompanyUpdateWithoutUserCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUserCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCompanyCreateWithoutCompanyInput = {
    id?: string
    role?: $Enums.Role
    isActive?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserCompaniesInput
  }

  export type UserCompanyUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    role?: $Enums.Role
    isActive?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCompanyCreateOrConnectWithoutCompanyInput = {
    where: UserCompanyWhereUniqueInput
    create: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput>
  }

  export type UserCompanyCreateManyCompanyInputEnvelope = {
    data: UserCompanyCreateManyCompanyInput | UserCompanyCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionHistoryCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionHistoryUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCompanyInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCompanyInput, ServiceUncheckedCreateWithoutCompanyInput>
  }

  export type ServiceCreateManyCompanyInputEnvelope = {
    data: ServiceCreateManyCompanyInput | ServiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutCompanyInput = {
    id?: string
    action: $Enums.AuditLogAction
    tableName: string
    recordId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    description?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutCompanyInput = {
    id?: string
    action: $Enums.AuditLogAction
    tableName: string
    recordId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    description?: string | null
    createdAt?: Date | string
    userId: string
  }

  export type AuditLogCreateOrConnectWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogCreateManyCompanyInputEnvelope = {
    data: AuditLogCreateManyCompanyInput | AuditLogCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutCompanyInput = {
    id?: string
    name?: string | null
    type: $Enums.ChatType
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ChatMemberCreateNestedManyWithoutChatInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutCompanyInput = {
    id?: string
    name?: string | null
    type: $Enums.ChatType
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ChatMemberUncheckedCreateNestedManyWithoutChatInput
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutCompanyInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput>
  }

  export type ChatCreateManyCompanyInputEnvelope = {
    data: ChatCreateManyCompanyInput | ChatCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    headOfDept?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    tasks?: TaskCreateNestedManyWithoutDepartmentInput
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    headOfDeptId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutDepartmentInput
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutCompanyInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput>
  }

  export type DepartmentCreateManyCompanyInputEnvelope = {
    data: DepartmentCreateManyCompanyInput | DepartmentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutCompanyInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    documentType?: $Enums.DocumentType
    isConfidential?: boolean
    expiryDate?: Date | string | null
    tags?: DocumentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutDocumentUploadsInput
  }

  export type DocumentUncheckedCreateWithoutCompanyInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    documentType?: $Enums.DocumentType
    isConfidential?: boolean
    expiryDate?: Date | string | null
    tags?: DocumentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedById: string
  }

  export type DocumentCreateOrConnectWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentCreateManyCompanyInputEnvelope = {
    data: DocumentCreateManyCompanyInput | DocumentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type GatePassCreateWithoutCompanyInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutGatePassesCreatedInput
    forUser?: UserCreateNestedOneWithoutGatePassesForInput
  }

  export type GatePassUncheckedCreateWithoutCompanyInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    forUserId?: string | null
  }

  export type GatePassCreateOrConnectWithoutCompanyInput = {
    where: GatePassWhereUniqueInput
    create: XOR<GatePassCreateWithoutCompanyInput, GatePassUncheckedCreateWithoutCompanyInput>
  }

  export type GatePassCreateManyCompanyInputEnvelope = {
    data: GatePassCreateManyCompanyInput | GatePassCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category?: string | null
    unit: string
    currentStock?: number
    minimumStock?: number
    maximumStock?: number | null
    reorderLevel?: number | null
    unitPrice?: number | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: InventoryMovementCreateNestedManyWithoutItemInput
    supplierItems?: SupplierItemCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category?: string | null
    unit: string
    currentStock?: number
    minimumStock?: number
    maximumStock?: number | null
    reorderLevel?: number | null
    unitPrice?: number | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutItemInput
    supplierItems?: SupplierItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemCreateOrConnectWithoutCompanyInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutCompanyInput, InventoryItemUncheckedCreateWithoutCompanyInput>
  }

  export type InventoryItemCreateManyCompanyInputEnvelope = {
    data: InventoryItemCreateManyCompanyInput | InventoryItemCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutCompanyInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SupplierItemCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SupplierItemUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutCompanyInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput>
  }

  export type SupplierCreateManyCompanyInputEnvelope = {
    data: SupplierCreateManyCompanyInput | SupplierCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type WorkingDayCreateWithoutCompanyInput = {
    id?: string
    dayOfWeek: number
    isWorking?: boolean
    startTime?: string | null
    endTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkingDayUncheckedCreateWithoutCompanyInput = {
    id?: string
    dayOfWeek: number
    isWorking?: boolean
    startTime?: string | null
    endTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkingDayCreateOrConnectWithoutCompanyInput = {
    where: WorkingDayWhereUniqueInput
    create: XOR<WorkingDayCreateWithoutCompanyInput, WorkingDayUncheckedCreateWithoutCompanyInput>
  }

  export type WorkingDayCreateManyCompanyInputEnvelope = {
    data: WorkingDayCreateManyCompanyInput | WorkingDayCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CreditsRechargeCreateWithoutCompanyInput = {
    id?: string
    credits: number
    amountPaid: number
    transactionId?: string | null
    paymentMethod?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchasedBy: UserCreateNestedOneWithoutCreditsRechargesInput
  }

  export type CreditsRechargeUncheckedCreateWithoutCompanyInput = {
    id?: string
    credits: number
    amountPaid: number
    transactionId?: string | null
    paymentMethod?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchasedById: string
  }

  export type CreditsRechargeCreateOrConnectWithoutCompanyInput = {
    where: CreditsRechargeWhereUniqueInput
    create: XOR<CreditsRechargeCreateWithoutCompanyInput, CreditsRechargeUncheckedCreateWithoutCompanyInput>
  }

  export type CreditsRechargeCreateManyCompanyInputEnvelope = {
    data: CreditsRechargeCreateManyCompanyInput | CreditsRechargeCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TransactionHistoryCreateWithoutCompanyInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    numberOfDaysUsed?: number | null
    service?: ServiceCreateNestedOneWithoutTransactionsInput
    enabledBy?: UserCreateNestedOneWithoutEnabledServicesInput
  }

  export type TransactionHistoryUncheckedCreateWithoutCompanyInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    serviceId?: string | null
    numberOfDaysUsed?: number | null
    enabledById?: string | null
  }

  export type TransactionHistoryCreateOrConnectWithoutCompanyInput = {
    where: TransactionHistoryWhereUniqueInput
    create: XOR<TransactionHistoryCreateWithoutCompanyInput, TransactionHistoryUncheckedCreateWithoutCompanyInput>
  }

  export type TransactionHistoryCreateManyCompanyInputEnvelope = {
    data: TransactionHistoryCreateManyCompanyInput | TransactionHistoryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserCompanyUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserCompanyWhereUniqueInput
    update: XOR<UserCompanyUpdateWithoutCompanyInput, UserCompanyUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput>
  }

  export type UserCompanyUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserCompanyWhereUniqueInput
    data: XOR<UserCompanyUpdateWithoutCompanyInput, UserCompanyUncheckedUpdateWithoutCompanyInput>
  }

  export type UserCompanyUpdateManyWithWhereWithoutCompanyInput = {
    where: UserCompanyScalarWhereInput
    data: XOR<UserCompanyUpdateManyMutationInput, UserCompanyUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ServiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutCompanyInput, ServiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<ServiceCreateWithoutCompanyInput, ServiceUncheckedCreateWithoutCompanyInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutCompanyInput, ServiceUncheckedUpdateWithoutCompanyInput>
  }

  export type ServiceUpdateManyWithWhereWithoutCompanyInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: FloatFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    companyId?: StringFilter<"Service"> | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCompanyInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ChatUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutCompanyInput, ChatUncheckedUpdateWithoutCompanyInput>
    create: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutCompanyInput, ChatUncheckedUpdateWithoutCompanyInput>
  }

  export type ChatUpdateManyWithWhereWithoutCompanyInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    name?: StringNullableFilter<"Chat"> | string | null
    type?: EnumChatTypeFilter<"Chat"> | $Enums.ChatType
    description?: StringNullableFilter<"Chat"> | string | null
    isActive?: BoolFilter<"Chat"> | boolean
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    companyId?: StringFilter<"Chat"> | string
  }

  export type DepartmentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutCompanyInput, DepartmentUncheckedUpdateWithoutCompanyInput>
    create: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutCompanyInput, DepartmentUncheckedUpdateWithoutCompanyInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutCompanyInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutCompanyInput, DocumentUncheckedUpdateWithoutCompanyInput>
    create: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutCompanyInput, DocumentUncheckedUpdateWithoutCompanyInput>
  }

  export type DocumentUpdateManyWithWhereWithoutCompanyInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type GatePassUpsertWithWhereUniqueWithoutCompanyInput = {
    where: GatePassWhereUniqueInput
    update: XOR<GatePassUpdateWithoutCompanyInput, GatePassUncheckedUpdateWithoutCompanyInput>
    create: XOR<GatePassCreateWithoutCompanyInput, GatePassUncheckedCreateWithoutCompanyInput>
  }

  export type GatePassUpdateWithWhereUniqueWithoutCompanyInput = {
    where: GatePassWhereUniqueInput
    data: XOR<GatePassUpdateWithoutCompanyInput, GatePassUncheckedUpdateWithoutCompanyInput>
  }

  export type GatePassUpdateManyWithWhereWithoutCompanyInput = {
    where: GatePassScalarWhereInput
    data: XOR<GatePassUpdateManyMutationInput, GatePassUncheckedUpdateManyWithoutCompanyInput>
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutCompanyInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutCompanyInput, InventoryItemUncheckedUpdateWithoutCompanyInput>
    create: XOR<InventoryItemCreateWithoutCompanyInput, InventoryItemUncheckedCreateWithoutCompanyInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutCompanyInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutCompanyInput, InventoryItemUncheckedUpdateWithoutCompanyInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutCompanyInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutCompanyInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    sku?: StringFilter<"InventoryItem"> | string
    category?: StringNullableFilter<"InventoryItem"> | string | null
    unit?: StringFilter<"InventoryItem"> | string
    currentStock?: FloatFilter<"InventoryItem"> | number
    minimumStock?: FloatFilter<"InventoryItem"> | number
    maximumStock?: FloatNullableFilter<"InventoryItem"> | number | null
    reorderLevel?: FloatNullableFilter<"InventoryItem"> | number | null
    unitPrice?: FloatNullableFilter<"InventoryItem"> | number | null
    location?: StringNullableFilter<"InventoryItem"> | string | null
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    companyId?: StringFilter<"InventoryItem"> | string
  }

  export type SupplierUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutCompanyInput, SupplierUncheckedUpdateWithoutCompanyInput>
    create: XOR<SupplierCreateWithoutCompanyInput, SupplierUncheckedCreateWithoutCompanyInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutCompanyInput, SupplierUncheckedUpdateWithoutCompanyInput>
  }

  export type SupplierUpdateManyWithWhereWithoutCompanyInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    gstNumber?: StringNullableFilter<"Supplier"> | string | null
    panNumber?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    companyId?: StringFilter<"Supplier"> | string
  }

  export type WorkingDayUpsertWithWhereUniqueWithoutCompanyInput = {
    where: WorkingDayWhereUniqueInput
    update: XOR<WorkingDayUpdateWithoutCompanyInput, WorkingDayUncheckedUpdateWithoutCompanyInput>
    create: XOR<WorkingDayCreateWithoutCompanyInput, WorkingDayUncheckedCreateWithoutCompanyInput>
  }

  export type WorkingDayUpdateWithWhereUniqueWithoutCompanyInput = {
    where: WorkingDayWhereUniqueInput
    data: XOR<WorkingDayUpdateWithoutCompanyInput, WorkingDayUncheckedUpdateWithoutCompanyInput>
  }

  export type WorkingDayUpdateManyWithWhereWithoutCompanyInput = {
    where: WorkingDayScalarWhereInput
    data: XOR<WorkingDayUpdateManyMutationInput, WorkingDayUncheckedUpdateManyWithoutCompanyInput>
  }

  export type WorkingDayScalarWhereInput = {
    AND?: WorkingDayScalarWhereInput | WorkingDayScalarWhereInput[]
    OR?: WorkingDayScalarWhereInput[]
    NOT?: WorkingDayScalarWhereInput | WorkingDayScalarWhereInput[]
    id?: StringFilter<"WorkingDay"> | string
    dayOfWeek?: IntFilter<"WorkingDay"> | number
    isWorking?: BoolFilter<"WorkingDay"> | boolean
    startTime?: StringNullableFilter<"WorkingDay"> | string | null
    endTime?: StringNullableFilter<"WorkingDay"> | string | null
    createdAt?: DateTimeFilter<"WorkingDay"> | Date | string
    updatedAt?: DateTimeFilter<"WorkingDay"> | Date | string
    companyId?: StringFilter<"WorkingDay"> | string
  }

  export type CreditsRechargeUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CreditsRechargeWhereUniqueInput
    update: XOR<CreditsRechargeUpdateWithoutCompanyInput, CreditsRechargeUncheckedUpdateWithoutCompanyInput>
    create: XOR<CreditsRechargeCreateWithoutCompanyInput, CreditsRechargeUncheckedCreateWithoutCompanyInput>
  }

  export type CreditsRechargeUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CreditsRechargeWhereUniqueInput
    data: XOR<CreditsRechargeUpdateWithoutCompanyInput, CreditsRechargeUncheckedUpdateWithoutCompanyInput>
  }

  export type CreditsRechargeUpdateManyWithWhereWithoutCompanyInput = {
    where: CreditsRechargeScalarWhereInput
    data: XOR<CreditsRechargeUpdateManyMutationInput, CreditsRechargeUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TransactionHistoryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TransactionHistoryWhereUniqueInput
    update: XOR<TransactionHistoryUpdateWithoutCompanyInput, TransactionHistoryUncheckedUpdateWithoutCompanyInput>
    create: XOR<TransactionHistoryCreateWithoutCompanyInput, TransactionHistoryUncheckedCreateWithoutCompanyInput>
  }

  export type TransactionHistoryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TransactionHistoryWhereUniqueInput
    data: XOR<TransactionHistoryUpdateWithoutCompanyInput, TransactionHistoryUncheckedUpdateWithoutCompanyInput>
  }

  export type TransactionHistoryUpdateManyWithWhereWithoutCompanyInput = {
    where: TransactionHistoryScalarWhereInput
    data: XOR<TransactionHistoryUpdateManyMutationInput, TransactionHistoryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyCreateWithoutServicesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutServicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutServicesInput, CompanyUncheckedCreateWithoutServicesInput>
  }

  export type TransactionHistoryCreateWithoutServiceInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    numberOfDaysUsed?: number | null
    company: CompanyCreateNestedOneWithoutTransactionHistoryInput
    enabledBy?: UserCreateNestedOneWithoutEnabledServicesInput
  }

  export type TransactionHistoryUncheckedCreateWithoutServiceInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    companyId: string
    numberOfDaysUsed?: number | null
    enabledById?: string | null
  }

  export type TransactionHistoryCreateOrConnectWithoutServiceInput = {
    where: TransactionHistoryWhereUniqueInput
    create: XOR<TransactionHistoryCreateWithoutServiceInput, TransactionHistoryUncheckedCreateWithoutServiceInput>
  }

  export type TransactionHistoryCreateManyServiceInputEnvelope = {
    data: TransactionHistoryCreateManyServiceInput | TransactionHistoryCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutServicesInput = {
    update: XOR<CompanyUpdateWithoutServicesInput, CompanyUncheckedUpdateWithoutServicesInput>
    create: XOR<CompanyCreateWithoutServicesInput, CompanyUncheckedCreateWithoutServicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutServicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutServicesInput, CompanyUncheckedUpdateWithoutServicesInput>
  }

  export type CompanyUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type TransactionHistoryUpsertWithWhereUniqueWithoutServiceInput = {
    where: TransactionHistoryWhereUniqueInput
    update: XOR<TransactionHistoryUpdateWithoutServiceInput, TransactionHistoryUncheckedUpdateWithoutServiceInput>
    create: XOR<TransactionHistoryCreateWithoutServiceInput, TransactionHistoryUncheckedCreateWithoutServiceInput>
  }

  export type TransactionHistoryUpdateWithWhereUniqueWithoutServiceInput = {
    where: TransactionHistoryWhereUniqueInput
    data: XOR<TransactionHistoryUpdateWithoutServiceInput, TransactionHistoryUncheckedUpdateWithoutServiceInput>
  }

  export type TransactionHistoryUpdateManyWithWhereWithoutServiceInput = {
    where: TransactionHistoryScalarWhereInput
    data: XOR<TransactionHistoryUpdateManyMutationInput, TransactionHistoryUncheckedUpdateManyWithoutServiceInput>
  }

  export type CompanyCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    services?: ServiceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDepartmentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
  }

  export type UserCreateWithoutHeadedDepartmentsInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutHeadedDepartmentsInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutHeadedDepartmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
  }

  export type TaskCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedTo: UserCreateNestedOneWithoutTasksAssignedInput
    createdBy: UserCreateNestedOneWithoutTasksCreatedInput
  }

  export type TaskUncheckedCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId: string
    createdById: string
    companyId: string
  }

  export type TaskCreateOrConnectWithoutDepartmentInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput>
  }

  export type TaskCreateManyDepartmentInputEnvelope = {
    data: TaskCreateManyDepartmentInput | TaskCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDepartmentInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutDepartmentInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserCreateManyDepartmentInputEnvelope = {
    data: UserCreateManyDepartmentInput | UserCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutDepartmentsInput = {
    update: XOR<CompanyUpdateWithoutDepartmentsInput, CompanyUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDepartmentsInput, CompanyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type CompanyUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutHeadedDepartmentsInput = {
    update: XOR<UserUpdateWithoutHeadedDepartmentsInput, UserUncheckedUpdateWithoutHeadedDepartmentsInput>
    create: XOR<UserCreateWithoutHeadedDepartmentsInput, UserUncheckedCreateWithoutHeadedDepartmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHeadedDepartmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHeadedDepartmentsInput, UserUncheckedUpdateWithoutHeadedDepartmentsInput>
  }

  export type UserUpdateWithoutHeadedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutHeadedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutDepartmentInput, TaskUncheckedUpdateWithoutDepartmentInput>
    create: XOR<TaskCreateWithoutDepartmentInput, TaskUncheckedCreateWithoutDepartmentInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutDepartmentInput, TaskUncheckedUpdateWithoutDepartmentInput>
  }

  export type TaskUpdateManyWithWhereWithoutDepartmentInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type UserUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
  }

  export type UserUpdateManyWithWhereWithoutDepartmentInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type UserCreateWithoutAttendancesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutAttendancesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutAttendancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
  }

  export type UserUpsertWithoutAttendancesInput = {
    update: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type UserCreateWithoutLeavesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutLeavesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutLeavesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeavesInput, UserUncheckedCreateWithoutLeavesInput>
  }

  export type UserUpsertWithoutLeavesInput = {
    update: XOR<UserUpdateWithoutLeavesInput, UserUncheckedUpdateWithoutLeavesInput>
    create: XOR<UserCreateWithoutLeavesInput, UserUncheckedCreateWithoutLeavesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeavesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeavesInput, UserUncheckedUpdateWithoutLeavesInput>
  }

  export type UserUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type CompanyCreateWithoutWorkingDaysInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    services?: ServiceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWorkingDaysInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWorkingDaysInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWorkingDaysInput, CompanyUncheckedCreateWithoutWorkingDaysInput>
  }

  export type CompanyUpsertWithoutWorkingDaysInput = {
    update: XOR<CompanyUpdateWithoutWorkingDaysInput, CompanyUncheckedUpdateWithoutWorkingDaysInput>
    create: XOR<CompanyCreateWithoutWorkingDaysInput, CompanyUncheckedCreateWithoutWorkingDaysInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWorkingDaysInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWorkingDaysInput, CompanyUncheckedUpdateWithoutWorkingDaysInput>
  }

  export type CompanyUpdateWithoutWorkingDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWorkingDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateWithoutTasksAssignedInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutTasksAssignedInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutTasksAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
  }

  export type UserCreateWithoutTasksCreatedInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutTasksCreatedInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutTasksCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
  }

  export type DepartmentCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDepartmentsInput
    headOfDept?: UserCreateNestedOneWithoutHeadedDepartmentsInput
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    headOfDeptId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutTasksInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutTasksInput, DepartmentUncheckedCreateWithoutTasksInput>
  }

  export type UserUpsertWithoutTasksAssignedInput = {
    update: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type UserUpdateWithoutTasksAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type UserUpsertWithoutTasksCreatedInput = {
    update: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type UserUpdateWithoutTasksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type DepartmentUpsertWithoutTasksInput = {
    update: XOR<DepartmentUpdateWithoutTasksInput, DepartmentUncheckedUpdateWithoutTasksInput>
    create: XOR<DepartmentCreateWithoutTasksInput, DepartmentUncheckedCreateWithoutTasksInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutTasksInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutTasksInput, DepartmentUncheckedUpdateWithoutTasksInput>
  }

  export type DepartmentUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDepartmentsNestedInput
    headOfDept?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDeptId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type ChatMemberCreateWithoutChatInput = {
    id?: string
    isAdmin?: boolean
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutChatMembersInput
  }

  export type ChatMemberUncheckedCreateWithoutChatInput = {
    id?: string
    isAdmin?: boolean
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ChatMemberCreateOrConnectWithoutChatInput = {
    where: ChatMemberWhereUniqueInput
    create: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput>
  }

  export type ChatMemberCreateManyChatInputEnvelope = {
    data: ChatMemberCreateManyChatInput | ChatMemberCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutChatsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    services?: ServiceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutChatsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutChatsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutChatsInput, CompanyUncheckedCreateWithoutChatsInput>
  }

  export type MessageCreateWithoutChatInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    fileUrl?: string | null
    fileName?: string | null
    isPinned?: boolean
    replyTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutChatInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    fileUrl?: string | null
    fileName?: string | null
    isPinned?: boolean
    replyTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
  }

  export type MessageCreateOrConnectWithoutChatInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageCreateManyChatInputEnvelope = {
    data: MessageCreateManyChatInput | MessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type ChatMemberUpsertWithWhereUniqueWithoutChatInput = {
    where: ChatMemberWhereUniqueInput
    update: XOR<ChatMemberUpdateWithoutChatInput, ChatMemberUncheckedUpdateWithoutChatInput>
    create: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput>
  }

  export type ChatMemberUpdateWithWhereUniqueWithoutChatInput = {
    where: ChatMemberWhereUniqueInput
    data: XOR<ChatMemberUpdateWithoutChatInput, ChatMemberUncheckedUpdateWithoutChatInput>
  }

  export type ChatMemberUpdateManyWithWhereWithoutChatInput = {
    where: ChatMemberScalarWhereInput
    data: XOR<ChatMemberUpdateManyMutationInput, ChatMemberUncheckedUpdateManyWithoutChatInput>
  }

  export type CompanyUpsertWithoutChatsInput = {
    update: XOR<CompanyUpdateWithoutChatsInput, CompanyUncheckedUpdateWithoutChatsInput>
    create: XOR<CompanyCreateWithoutChatsInput, CompanyUncheckedCreateWithoutChatsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutChatsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutChatsInput, CompanyUncheckedUpdateWithoutChatsInput>
  }

  export type CompanyUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
  }

  export type MessageUpdateManyWithWhereWithoutChatInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChatInput>
  }

  export type ChatCreateWithoutMembersInput = {
    id?: string
    name?: string | null
    type: $Enums.ChatType
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutChatsInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutMembersInput = {
    id?: string
    name?: string | null
    type: $Enums.ChatType
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutMembersInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutChatMembersInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutChatMembersInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutChatMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatMembersInput, UserUncheckedCreateWithoutChatMembersInput>
  }

  export type ChatUpsertWithoutMembersInput = {
    update: XOR<ChatUpdateWithoutMembersInput, ChatUncheckedUpdateWithoutMembersInput>
    create: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMembersInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMembersInput, ChatUncheckedUpdateWithoutMembersInput>
  }

  export type ChatUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatTypeFieldUpdateOperationsInput | $Enums.ChatType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutChatsNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatTypeFieldUpdateOperationsInput | $Enums.ChatType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type UserUpsertWithoutChatMembersInput = {
    update: XOR<UserUpdateWithoutChatMembersInput, UserUncheckedUpdateWithoutChatMembersInput>
    create: XOR<UserCreateWithoutChatMembersInput, UserUncheckedCreateWithoutChatMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatMembersInput, UserUncheckedUpdateWithoutChatMembersInput>
  }

  export type UserUpdateWithoutChatMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutChatMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    name?: string | null
    type: $Enums.ChatType
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ChatMemberCreateNestedManyWithoutChatInput
    company: CompanyCreateNestedOneWithoutChatsInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    name?: string | null
    type: $Enums.ChatType
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    members?: ChatMemberUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatTypeFieldUpdateOperationsInput | $Enums.ChatType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatMemberUpdateManyWithoutChatNestedInput
    company?: CompanyUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatTypeFieldUpdateOperationsInput | $Enums.ChatType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    members?: ChatMemberUncheckedUpdateManyWithoutChatNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type CompanyCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    services?: ServiceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutInventoryItemsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutInventoryItemsInput, CompanyUncheckedCreateWithoutInventoryItemsInput>
  }

  export type InventoryMovementCreateWithoutItemInput = {
    id?: string
    movementType: $Enums.InventoryMovementType
    quantity: number
    unitPrice?: number | null
    reference?: string | null
    notes?: string | null
    movedBy: string
    createdAt?: Date | string
  }

  export type InventoryMovementUncheckedCreateWithoutItemInput = {
    id?: string
    movementType: $Enums.InventoryMovementType
    quantity: number
    unitPrice?: number | null
    reference?: string | null
    notes?: string | null
    movedBy: string
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput>
  }

  export type InventoryMovementCreateManyItemInputEnvelope = {
    data: InventoryMovementCreateManyItemInput | InventoryMovementCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type SupplierItemCreateWithoutItemInput = {
    id?: string
    supplierPrice?: number | null
    leadTime?: number | null
    isPreferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutItemsInput
  }

  export type SupplierItemUncheckedCreateWithoutItemInput = {
    id?: string
    supplierPrice?: number | null
    leadTime?: number | null
    isPreferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId: string
  }

  export type SupplierItemCreateOrConnectWithoutItemInput = {
    where: SupplierItemWhereUniqueInput
    create: XOR<SupplierItemCreateWithoutItemInput, SupplierItemUncheckedCreateWithoutItemInput>
  }

  export type SupplierItemCreateManyItemInputEnvelope = {
    data: SupplierItemCreateManyItemInput | SupplierItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutInventoryItemsInput = {
    update: XOR<CompanyUpdateWithoutInventoryItemsInput, CompanyUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<CompanyCreateWithoutInventoryItemsInput, CompanyUncheckedCreateWithoutInventoryItemsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutInventoryItemsInput, CompanyUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type CompanyUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutItemInput, InventoryMovementUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutItemInput, InventoryMovementUncheckedUpdateWithoutItemInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutItemInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutItemInput>
  }

  export type InventoryMovementScalarWhereInput = {
    AND?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    OR?: InventoryMovementScalarWhereInput[]
    NOT?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    movementType?: EnumInventoryMovementTypeFilter<"InventoryMovement"> | $Enums.InventoryMovementType
    quantity?: FloatFilter<"InventoryMovement"> | number
    unitPrice?: FloatNullableFilter<"InventoryMovement"> | number | null
    reference?: StringNullableFilter<"InventoryMovement"> | string | null
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    movedBy?: StringFilter<"InventoryMovement"> | string
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    itemId?: StringFilter<"InventoryMovement"> | string
  }

  export type SupplierItemUpsertWithWhereUniqueWithoutItemInput = {
    where: SupplierItemWhereUniqueInput
    update: XOR<SupplierItemUpdateWithoutItemInput, SupplierItemUncheckedUpdateWithoutItemInput>
    create: XOR<SupplierItemCreateWithoutItemInput, SupplierItemUncheckedCreateWithoutItemInput>
  }

  export type SupplierItemUpdateWithWhereUniqueWithoutItemInput = {
    where: SupplierItemWhereUniqueInput
    data: XOR<SupplierItemUpdateWithoutItemInput, SupplierItemUncheckedUpdateWithoutItemInput>
  }

  export type SupplierItemUpdateManyWithWhereWithoutItemInput = {
    where: SupplierItemScalarWhereInput
    data: XOR<SupplierItemUpdateManyMutationInput, SupplierItemUncheckedUpdateManyWithoutItemInput>
  }

  export type SupplierItemScalarWhereInput = {
    AND?: SupplierItemScalarWhereInput | SupplierItemScalarWhereInput[]
    OR?: SupplierItemScalarWhereInput[]
    NOT?: SupplierItemScalarWhereInput | SupplierItemScalarWhereInput[]
    id?: StringFilter<"SupplierItem"> | string
    supplierPrice?: FloatNullableFilter<"SupplierItem"> | number | null
    leadTime?: IntNullableFilter<"SupplierItem"> | number | null
    isPreferred?: BoolFilter<"SupplierItem"> | boolean
    createdAt?: DateTimeFilter<"SupplierItem"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierItem"> | Date | string
    supplierId?: StringFilter<"SupplierItem"> | string
    itemId?: StringFilter<"SupplierItem"> | string
  }

  export type InventoryItemCreateWithoutMovementsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category?: string | null
    unit: string
    currentStock?: number
    minimumStock?: number
    maximumStock?: number | null
    reorderLevel?: number | null
    unitPrice?: number | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInventoryItemsInput
    supplierItems?: SupplierItemCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateWithoutMovementsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category?: string | null
    unit: string
    currentStock?: number
    minimumStock?: number
    maximumStock?: number | null
    reorderLevel?: number | null
    unitPrice?: number | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    supplierItems?: SupplierItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemCreateOrConnectWithoutMovementsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutMovementsInput, InventoryItemUncheckedCreateWithoutMovementsInput>
  }

  export type InventoryItemUpsertWithoutMovementsInput = {
    update: XOR<InventoryItemUpdateWithoutMovementsInput, InventoryItemUncheckedUpdateWithoutMovementsInput>
    create: XOR<InventoryItemCreateWithoutMovementsInput, InventoryItemUncheckedCreateWithoutMovementsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutMovementsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutMovementsInput, InventoryItemUncheckedUpdateWithoutMovementsInput>
  }

  export type InventoryItemUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: FloatFieldUpdateOperationsInput | number
    minimumStock?: FloatFieldUpdateOperationsInput | number
    maximumStock?: NullableFloatFieldUpdateOperationsInput | number | null
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInventoryItemsNestedInput
    supplierItems?: SupplierItemUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: FloatFieldUpdateOperationsInput | number
    minimumStock?: FloatFieldUpdateOperationsInput | number
    maximumStock?: NullableFloatFieldUpdateOperationsInput | number | null
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    supplierItems?: SupplierItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SupplierItemCreateWithoutSupplierInput = {
    id?: string
    supplierPrice?: number | null
    leadTime?: number | null
    isPreferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    item: InventoryItemCreateNestedOneWithoutSupplierItemsInput
  }

  export type SupplierItemUncheckedCreateWithoutSupplierInput = {
    id?: string
    supplierPrice?: number | null
    leadTime?: number | null
    isPreferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    itemId: string
  }

  export type SupplierItemCreateOrConnectWithoutSupplierInput = {
    where: SupplierItemWhereUniqueInput
    create: XOR<SupplierItemCreateWithoutSupplierInput, SupplierItemUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierItemCreateManySupplierInputEnvelope = {
    data: SupplierItemCreateManySupplierInput | SupplierItemCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutSuppliersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    services?: ServiceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSuppliersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSuppliersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSuppliersInput, CompanyUncheckedCreateWithoutSuppliersInput>
  }

  export type SupplierItemUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierItemWhereUniqueInput
    update: XOR<SupplierItemUpdateWithoutSupplierInput, SupplierItemUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierItemCreateWithoutSupplierInput, SupplierItemUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierItemUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierItemWhereUniqueInput
    data: XOR<SupplierItemUpdateWithoutSupplierInput, SupplierItemUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierItemUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierItemScalarWhereInput
    data: XOR<SupplierItemUpdateManyMutationInput, SupplierItemUncheckedUpdateManyWithoutSupplierInput>
  }

  export type CompanyUpsertWithoutSuppliersInput = {
    update: XOR<CompanyUpdateWithoutSuppliersInput, CompanyUncheckedUpdateWithoutSuppliersInput>
    create: XOR<CompanyCreateWithoutSuppliersInput, CompanyUncheckedCreateWithoutSuppliersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSuppliersInput, CompanyUncheckedUpdateWithoutSuppliersInput>
  }

  export type CompanyUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type InventoryItemCreateWithoutSupplierItemsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category?: string | null
    unit: string
    currentStock?: number
    minimumStock?: number
    maximumStock?: number | null
    reorderLevel?: number | null
    unitPrice?: number | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInventoryItemsInput
    movements?: InventoryMovementCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateWithoutSupplierItemsInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category?: string | null
    unit: string
    currentStock?: number
    minimumStock?: number
    maximumStock?: number | null
    reorderLevel?: number | null
    unitPrice?: number | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemCreateOrConnectWithoutSupplierItemsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutSupplierItemsInput, InventoryItemUncheckedCreateWithoutSupplierItemsInput>
  }

  export type SupplierCreateWithoutItemsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSuppliersInput
  }

  export type SupplierUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type SupplierCreateOrConnectWithoutItemsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutItemsInput, SupplierUncheckedCreateWithoutItemsInput>
  }

  export type InventoryItemUpsertWithoutSupplierItemsInput = {
    update: XOR<InventoryItemUpdateWithoutSupplierItemsInput, InventoryItemUncheckedUpdateWithoutSupplierItemsInput>
    create: XOR<InventoryItemCreateWithoutSupplierItemsInput, InventoryItemUncheckedCreateWithoutSupplierItemsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutSupplierItemsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutSupplierItemsInput, InventoryItemUncheckedUpdateWithoutSupplierItemsInput>
  }

  export type InventoryItemUpdateWithoutSupplierItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: FloatFieldUpdateOperationsInput | number
    minimumStock?: FloatFieldUpdateOperationsInput | number
    maximumStock?: NullableFloatFieldUpdateOperationsInput | number | null
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInventoryItemsNestedInput
    movements?: InventoryMovementUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutSupplierItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: FloatFieldUpdateOperationsInput | number
    minimumStock?: FloatFieldUpdateOperationsInput | number
    maximumStock?: NullableFloatFieldUpdateOperationsInput | number | null
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    movements?: InventoryMovementUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SupplierUpsertWithoutItemsInput = {
    update: XOR<SupplierUpdateWithoutItemsInput, SupplierUncheckedUpdateWithoutItemsInput>
    create: XOR<SupplierCreateWithoutItemsInput, SupplierUncheckedCreateWithoutItemsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutItemsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutItemsInput, SupplierUncheckedUpdateWithoutItemsInput>
  }

  export type SupplierUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type SupplierUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyCreateWithoutGatePassesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    services?: ServiceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutGatePassesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutGatePassesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutGatePassesInput, CompanyUncheckedCreateWithoutGatePassesInput>
  }

  export type UserCreateWithoutGatePassesCreatedInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutGatePassesCreatedInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutGatePassesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGatePassesCreatedInput, UserUncheckedCreateWithoutGatePassesCreatedInput>
  }

  export type UserCreateWithoutGatePassesForInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutGatePassesForInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutGatePassesForInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGatePassesForInput, UserUncheckedCreateWithoutGatePassesForInput>
  }

  export type CompanyUpsertWithoutGatePassesInput = {
    update: XOR<CompanyUpdateWithoutGatePassesInput, CompanyUncheckedUpdateWithoutGatePassesInput>
    create: XOR<CompanyCreateWithoutGatePassesInput, CompanyUncheckedCreateWithoutGatePassesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutGatePassesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutGatePassesInput, CompanyUncheckedUpdateWithoutGatePassesInput>
  }

  export type CompanyUpdateWithoutGatePassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutGatePassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutGatePassesCreatedInput = {
    update: XOR<UserUpdateWithoutGatePassesCreatedInput, UserUncheckedUpdateWithoutGatePassesCreatedInput>
    create: XOR<UserCreateWithoutGatePassesCreatedInput, UserUncheckedCreateWithoutGatePassesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGatePassesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGatePassesCreatedInput, UserUncheckedUpdateWithoutGatePassesCreatedInput>
  }

  export type UserUpdateWithoutGatePassesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutGatePassesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type UserUpsertWithoutGatePassesForInput = {
    update: XOR<UserUpdateWithoutGatePassesForInput, UserUncheckedUpdateWithoutGatePassesForInput>
    create: XOR<UserCreateWithoutGatePassesForInput, UserUncheckedCreateWithoutGatePassesForInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGatePassesForInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGatePassesForInput, UserUncheckedUpdateWithoutGatePassesForInput>
  }

  export type UserUpdateWithoutGatePassesForInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutGatePassesForInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type CompanyCreateWithoutDocumentsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    services?: ServiceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDocumentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutDocumentUploadsInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutDocumentUploadsInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutDocumentUploadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentUploadsInput, UserUncheckedCreateWithoutDocumentUploadsInput>
  }

  export type CompanyUpsertWithoutDocumentsInput = {
    update: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type CompanyUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutDocumentUploadsInput = {
    update: XOR<UserUpdateWithoutDocumentUploadsInput, UserUncheckedUpdateWithoutDocumentUploadsInput>
    create: XOR<UserCreateWithoutDocumentUploadsInput, UserUncheckedCreateWithoutDocumentUploadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentUploadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentUploadsInput, UserUncheckedUpdateWithoutDocumentUploadsInput>
  }

  export type UserUpdateWithoutDocumentUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type UserCreateWithoutReviewsGivenInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutReviewsGivenInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutReviewsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
  }

  export type UserCreateWithoutPerformanceReviewsInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutPerformanceReviewsInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutPerformanceReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPerformanceReviewsInput, UserUncheckedCreateWithoutPerformanceReviewsInput>
  }

  export type UserUpsertWithoutReviewsGivenInput = {
    update: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateWithoutReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type UserUpsertWithoutPerformanceReviewsInput = {
    update: XOR<UserUpdateWithoutPerformanceReviewsInput, UserUncheckedUpdateWithoutPerformanceReviewsInput>
    create: XOR<UserCreateWithoutPerformanceReviewsInput, UserUncheckedCreateWithoutPerformanceReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPerformanceReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPerformanceReviewsInput, UserUncheckedUpdateWithoutPerformanceReviewsInput>
  }

  export type UserUpdateWithoutPerformanceReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutPerformanceReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type CompanyCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    services?: ServiceCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAuditLogsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type CompanyUpsertWithoutAuditLogsInput = {
    update: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type CompanyCreateWithoutCreditsRechargesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    services?: ServiceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCreditsRechargesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    transactionHistory?: TransactionHistoryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCreditsRechargesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCreditsRechargesInput, CompanyUncheckedCreateWithoutCreditsRechargesInput>
  }

  export type UserCreateWithoutCreditsRechargesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    enabledServices?: TransactionHistoryCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutCreditsRechargesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    enabledServices?: TransactionHistoryUncheckedCreateNestedManyWithoutEnabledByInput
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutCreditsRechargesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditsRechargesInput, UserUncheckedCreateWithoutCreditsRechargesInput>
  }

  export type CompanyUpsertWithoutCreditsRechargesInput = {
    update: XOR<CompanyUpdateWithoutCreditsRechargesInput, CompanyUncheckedUpdateWithoutCreditsRechargesInput>
    create: XOR<CompanyCreateWithoutCreditsRechargesInput, CompanyUncheckedCreateWithoutCreditsRechargesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCreditsRechargesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCreditsRechargesInput, CompanyUncheckedUpdateWithoutCreditsRechargesInput>
  }

  export type CompanyUpdateWithoutCreditsRechargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCreditsRechargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    transactionHistory?: TransactionHistoryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutCreditsRechargesInput = {
    update: XOR<UserUpdateWithoutCreditsRechargesInput, UserUncheckedUpdateWithoutCreditsRechargesInput>
    create: XOR<UserCreateWithoutCreditsRechargesInput, UserUncheckedCreateWithoutCreditsRechargesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreditsRechargesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreditsRechargesInput, UserUncheckedUpdateWithoutCreditsRechargesInput>
  }

  export type UserUpdateWithoutCreditsRechargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreditsRechargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type CompanyCreateWithoutTransactionHistoryInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyCreateNestedManyWithoutCompanyInput
    services?: ServiceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTransactionHistoryInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    industry?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Country?: string | null
    totalCredits?: number
    usedCredits?: number
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    gatePasses?: GatePassUncheckedCreateNestedManyWithoutCompanyInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutCompanyInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCompanyInput
    workingDays?: WorkingDayUncheckedCreateNestedManyWithoutCompanyInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTransactionHistoryInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTransactionHistoryInput, CompanyUncheckedCreateWithoutTransactionHistoryInput>
  }

  export type ServiceCreateWithoutTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type ServiceCreateOrConnectWithoutTransactionsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutTransactionsInput, ServiceUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutEnabledServicesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Salary?: number | null
    userCompanies?: UserCompanyCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberCreateNestedManyWithoutUserInput
    documentUploads?: DocumentCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassCreateNestedManyWithoutForUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeCreateNestedManyWithoutPurchasedByInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    subordinates?: UserCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutEnabledServicesInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    managerId?: string | null
    Salary?: number | null
    userCompanies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadOfDeptInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chatMembers?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    documentUploads?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    gatePassesCreated?: GatePassUncheckedCreateNestedManyWithoutCreatedByInput
    gatePassesFor?: GatePassUncheckedCreateNestedManyWithoutForUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewsGiven?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewByInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutReviewForInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatedByInput
    creditsRecharges?: CreditsRechargeUncheckedCreateNestedManyWithoutPurchasedByInput
    subordinates?: UserUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutEnabledServicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnabledServicesInput, UserUncheckedCreateWithoutEnabledServicesInput>
  }

  export type CompanyUpsertWithoutTransactionHistoryInput = {
    update: XOR<CompanyUpdateWithoutTransactionHistoryInput, CompanyUncheckedUpdateWithoutTransactionHistoryInput>
    create: XOR<CompanyCreateWithoutTransactionHistoryInput, CompanyUncheckedCreateWithoutTransactionHistoryInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTransactionHistoryInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTransactionHistoryInput, CompanyUncheckedUpdateWithoutTransactionHistoryInput>
  }

  export type CompanyUpdateWithoutTransactionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUpdateManyWithoutCompanyNestedInput
    services?: ServiceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTransactionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    totalCredits?: FloatFieldUpdateOperationsInput | number
    usedCredits?: FloatFieldUpdateOperationsInput | number
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    gatePasses?: GatePassUncheckedUpdateManyWithoutCompanyNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutCompanyNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCompanyNestedInput
    workingDays?: WorkingDayUncheckedUpdateManyWithoutCompanyNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ServiceUpsertWithoutTransactionsInput = {
    update: XOR<ServiceUpdateWithoutTransactionsInput, ServiceUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ServiceCreateWithoutTransactionsInput, ServiceUncheckedCreateWithoutTransactionsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutTransactionsInput, ServiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type ServiceUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutEnabledServicesInput = {
    update: XOR<UserUpdateWithoutEnabledServicesInput, UserUncheckedUpdateWithoutEnabledServicesInput>
    create: XOR<UserCreateWithoutEnabledServicesInput, UserUncheckedCreateWithoutEnabledServicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnabledServicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnabledServicesInput, UserUncheckedUpdateWithoutEnabledServicesInput>
  }

  export type UserUpdateWithoutEnabledServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutEnabledServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type TransactionHistoryCreateManyEnabledByInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    companyId: string
    serviceId?: string | null
    numberOfDaysUsed?: number | null
  }

  export type UserCompanyCreateManyUserInput = {
    id?: string
    companyId: string
    role?: $Enums.Role
    isActive?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateManyHeadOfDeptInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type AttendanceCreateManyUserInput = {
    id?: string
    clockInTime?: Date | string | null
    clockOutTime?: Date | string | null
    workingHours?: number | null
    overtimeHours?: number | null
    status?: $Enums.AttendanceStatus
    location?: string | null
    notes?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: $Enums.AuditLogAction
    tableName: string
    recordId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    description?: string | null
    createdAt?: Date | string
    companyId: string
  }

  export type ChatMemberCreateManyUserInput = {
    id?: string
    isAdmin?: boolean
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chatId: string
  }

  export type DocumentCreateManyUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    documentType?: $Enums.DocumentType
    isConfidential?: boolean
    expiryDate?: Date | string | null
    tags?: DocumentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type GatePassCreateManyCreatedByInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    forUserId?: string | null
  }

  export type GatePassCreateManyForUserInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    createdById: string
  }

  export type LeaveCreateManyUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    leaveType: $Enums.LeaveType
    reason: string
    status?: $Enums.LeaveStatus
    appliedDate?: Date | string
    approvedBy?: string | null
    rejectedBy?: string | null
    comments?: string | null
    totalDays: number
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    fileUrl?: string | null
    fileName?: string | null
    isPinned?: boolean
    replyTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chatId: string
  }

  export type PerformanceReviewCreateManyReviewByInput = {
    id?: string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    overallRating?: number | null
    goalsAchieved?: number | null
    punctualityScore?: number | null
    qualityScore?: number | null
    communicationScore?: number | null
    teamworkScore?: number | null
    comments?: string | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewForId: string
    companyId: string
  }

  export type PerformanceReviewCreateManyReviewForInput = {
    id?: string
    reviewPeriodStart: Date | string
    reviewPeriodEnd: Date | string
    overallRating?: number | null
    goalsAchieved?: number | null
    punctualityScore?: number | null
    qualityScore?: number | null
    communicationScore?: number | null
    teamworkScore?: number | null
    comments?: string | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewById: string
    companyId: string
  }

  export type TaskCreateManyAssignedToInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    departmentId?: string | null
    companyId: string
  }

  export type TaskCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId: string
    departmentId?: string | null
    companyId: string
  }

  export type CreditsRechargeCreateManyPurchasedByInput = {
    id?: string
    credits: number
    amountPaid: number
    transactionId?: string | null
    paymentMethod?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type UserCreateManyManagerInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    Salary?: number | null
  }

  export type TransactionHistoryUpdateWithoutEnabledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutTransactionHistoryNestedInput
    service?: ServiceUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionHistoryUncheckedUpdateWithoutEnabledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionHistoryUncheckedUpdateManyWithoutEnabledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCompanyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUserCompaniesNestedInput
  }

  export type UserCompanyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCompanyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutHeadOfDeptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDepartmentsNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutHeadOfDeptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutHeadOfDeptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditLogActionFieldUpdateOperationsInput | $Enums.AuditLogAction
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditLogActionFieldUpdateOperationsInput | $Enums.AuditLogAction
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditLogActionFieldUpdateOperationsInput | $Enums.AuditLogAction
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ChatMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type GatePassUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutGatePassesNestedInput
    forUser?: UserUpdateOneWithoutGatePassesForNestedInput
  }

  export type GatePassUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    forUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GatePassUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    forUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GatePassUpdateWithoutForUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutGatePassesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutGatePassesCreatedNestedInput
  }

  export type GatePassUncheckedUpdateWithoutForUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type GatePassUncheckedUpdateManyWithoutForUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    appliedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    appliedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type LeaveUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    appliedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    totalDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceReviewUpdateWithoutReviewByInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    goalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    punctualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    teamworkScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    reviewFor?: UserUpdateOneRequiredWithoutPerformanceReviewsNestedInput
  }

  export type PerformanceReviewUncheckedUpdateWithoutReviewByInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    goalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    punctualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    teamworkScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewForId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutReviewByInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    goalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    punctualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    teamworkScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewForId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceReviewUpdateWithoutReviewForInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    goalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    punctualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    teamworkScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    reviewBy?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
  }

  export type PerformanceReviewUncheckedUpdateWithoutReviewForInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    goalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    punctualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    teamworkScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewById?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutReviewForInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    overallRating?: NullableFloatFieldUpdateOperationsInput | number | null
    goalsAchieved?: NullableIntFieldUpdateOperationsInput | number | null
    punctualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    teamworkScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewById?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    department?: DepartmentUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedTo?: UserUpdateOneRequiredWithoutTasksAssignedNestedInput
    department?: DepartmentUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CreditsRechargeUpdateWithoutPurchasedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCreditsRechargesNestedInput
  }

  export type CreditsRechargeUncheckedUpdateWithoutPurchasedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CreditsRechargeUncheckedUpdateManyWithoutPurchasedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCompanyCreateManyCompanyInput = {
    id?: string
    userId: string
    role?: $Enums.Role
    isActive?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyCompanyInput = {
    id?: string
    action: $Enums.AuditLogAction
    tableName: string
    recordId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    description?: string | null
    createdAt?: Date | string
    userId: string
  }

  export type ChatCreateManyCompanyInput = {
    id?: string
    name?: string | null
    type: $Enums.ChatType
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    headOfDeptId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyCompanyInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    fileUrl: string
    fileSize?: number | null
    mimeType?: string | null
    documentType?: $Enums.DocumentType
    isConfidential?: boolean
    expiryDate?: Date | string | null
    tags?: DocumentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedById: string
  }

  export type GatePassCreateManyCompanyInput = {
    id?: string
    passNumber: string
    type: $Enums.GatePassType
    purpose?: string | null
    visitorName?: string | null
    visitorPhone?: string | null
    visitorCompany?: string | null
    vehicleNumber?: string | null
    itemsCarried?: string | null
    entryTime?: Date | string | null
    exitTime?: Date | string | null
    status?: $Enums.GatePassStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    forUserId?: string | null
  }

  export type InventoryItemCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    sku: string
    category?: string | null
    unit: string
    currentStock?: number
    minimumStock?: number
    maximumStock?: number | null
    reorderLevel?: number | null
    unitPrice?: number | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateManyCompanyInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkingDayCreateManyCompanyInput = {
    id?: string
    dayOfWeek: number
    isWorking?: boolean
    startTime?: string | null
    endTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditsRechargeCreateManyCompanyInput = {
    id?: string
    credits: number
    amountPaid: number
    transactionId?: string | null
    paymentMethod?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchasedById: string
  }

  export type TransactionHistoryCreateManyCompanyInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    serviceId?: string | null
    numberOfDaysUsed?: number | null
    enabledById?: string | null
  }

  export type UserCompanyUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserCompaniesNestedInput
  }

  export type UserCompanyUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCompanyUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionHistoryUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionHistoryUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditLogActionFieldUpdateOperationsInput | $Enums.AuditLogAction
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditLogActionFieldUpdateOperationsInput | $Enums.AuditLogAction
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditLogActionFieldUpdateOperationsInput | $Enums.AuditLogAction
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatTypeFieldUpdateOperationsInput | $Enums.ChatType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatMemberUpdateManyWithoutChatNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatTypeFieldUpdateOperationsInput | $Enums.ChatType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatMemberUncheckedUpdateManyWithoutChatNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatTypeFieldUpdateOperationsInput | $Enums.ChatType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    headOfDept?: UserUpdateOneWithoutHeadedDepartmentsNestedInput
    tasks?: TaskUpdateManyWithoutDepartmentNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDeptId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutDepartmentNestedInput
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDeptId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutDocumentUploadsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type GatePassUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutGatePassesCreatedNestedInput
    forUser?: UserUpdateOneWithoutGatePassesForNestedInput
  }

  export type GatePassUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    forUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GatePassUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumGatePassTypeFieldUpdateOperationsInput | $Enums.GatePassType
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    visitorName?: NullableStringFieldUpdateOperationsInput | string | null
    visitorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    visitorCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    itemsCarried?: NullableStringFieldUpdateOperationsInput | string | null
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGatePassStatusFieldUpdateOperationsInput | $Enums.GatePassStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    forUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryItemUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: FloatFieldUpdateOperationsInput | number
    minimumStock?: FloatFieldUpdateOperationsInput | number
    maximumStock?: NullableFloatFieldUpdateOperationsInput | number | null
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUpdateManyWithoutItemNestedInput
    supplierItems?: SupplierItemUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: FloatFieldUpdateOperationsInput | number
    minimumStock?: FloatFieldUpdateOperationsInput | number
    maximumStock?: NullableFloatFieldUpdateOperationsInput | number | null
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUncheckedUpdateManyWithoutItemNestedInput
    supplierItems?: SupplierItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    currentStock?: FloatFieldUpdateOperationsInput | number
    minimumStock?: FloatFieldUpdateOperationsInput | number
    maximumStock?: NullableFloatFieldUpdateOperationsInput | number | null
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SupplierItemUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SupplierItemUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingDayUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    isWorking?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingDayUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    isWorking?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingDayUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    isWorking?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditsRechargeUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchasedBy?: UserUpdateOneRequiredWithoutCreditsRechargesNestedInput
  }

  export type CreditsRechargeUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchasedById?: StringFieldUpdateOperationsInput | string
  }

  export type CreditsRechargeUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchasedById?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionHistoryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
    service?: ServiceUpdateOneWithoutTransactionsNestedInput
    enabledBy?: UserUpdateOneWithoutEnabledServicesNestedInput
  }

  export type TransactionHistoryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
    enabledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionHistoryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
    enabledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionHistoryCreateManyServiceInput = {
    id?: string
    creditsUsed: number
    description?: string | null
    createdAt?: Date | string
    companyId: string
    numberOfDaysUsed?: number | null
    enabledById?: string | null
  }

  export type TransactionHistoryUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutTransactionHistoryNestedInput
    enabledBy?: UserUpdateOneWithoutEnabledServicesNestedInput
  }

  export type TransactionHistoryUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
    enabledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionHistoryUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditsUsed?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    numberOfDaysUsed?: NullableIntFieldUpdateOperationsInput | number | null
    enabledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.TaskPriority
    startDate?: Date | string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    estimatedHours?: number | null
    actualHours?: number | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId: string
    createdById: string
    companyId: string
  }

  export type UserCreateManyDepartmentInput = {
    id?: string
    firebaseId?: string | null
    email: string
    fullName: string
    phone?: string | null
    profileImage?: string | null
    employeeId?: string | null
    designation?: string | null
    role?: $Enums.Role
    isActive?: boolean
    dateOfJoining?: Date | string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: string | null
    salary?: number | null
    workingHoursPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    Salary?: number | null
  }

  export type TaskUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedTo?: UserUpdateOneRequiredWithoutTasksAssignedNestedInput
    createdBy?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
  }

  export type TaskUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUpdateManyWithoutPurchasedByNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: UserUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
    enabledServices?: TransactionHistoryUncheckedUpdateManyWithoutEnabledByNestedInput
    userCompanies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadOfDeptNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chatMembers?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    documentUploads?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    gatePassesCreated?: GatePassUncheckedUpdateManyWithoutCreatedByNestedInput
    gatePassesFor?: GatePassUncheckedUpdateManyWithoutForUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewsGiven?: PerformanceReviewUncheckedUpdateManyWithoutReviewByNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutReviewForNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatedByNestedInput
    creditsRecharges?: CreditsRechargeUncheckedUpdateManyWithoutPurchasedByNestedInput
    subordinates?: UserUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firebaseId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    workingHoursPerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChatMemberCreateManyChatInput = {
    id?: string
    isAdmin?: boolean
    joinedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type MessageCreateManyChatInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    fileUrl?: string | null
    fileName?: string | null
    isPinned?: boolean
    replyTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
  }

  export type ChatMemberUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatMembersNestedInput
  }

  export type ChatMemberUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMemberUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    replyTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryMovementCreateManyItemInput = {
    id?: string
    movementType: $Enums.InventoryMovementType
    quantity: number
    unitPrice?: number | null
    reference?: string | null
    notes?: string | null
    movedBy: string
    createdAt?: Date | string
  }

  export type SupplierItemCreateManyItemInput = {
    id?: string
    supplierPrice?: number | null
    leadTime?: number | null
    isPreferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierId: string
  }

  export type InventoryMovementUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    movementType?: EnumInventoryMovementTypeFieldUpdateOperationsInput | $Enums.InventoryMovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SupplierItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierItemCreateManySupplierInput = {
    id?: string
    supplierPrice?: number | null
    leadTime?: number | null
    isPreferred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    itemId: string
  }

  export type SupplierItemUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutSupplierItemsNestedInput
  }

  export type SupplierItemUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierItemUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}